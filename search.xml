<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spark和Hadoop的异同点分析</title>
      <link href="/2022/06/10/hadoop%E5%92%8Cspark/"/>
      <url>/2022/06/10/hadoop%E5%92%8Cspark/</url>
      
        <content type="html"><![CDATA[<h3 id="Spark和Hadoop的异同点分析"><a href="#Spark和Hadoop的异同点分析" class="headerlink" title="Spark和Hadoop的异同点分析"></a>Spark和Hadoop的异同点分析</h3><p>   <a href="about:blank#_7">一、两者实现原理的比较</a></p><ul><li><a href="about:blank#__17">二、 两者多方面的对比</a></li><li><a href="about:blank#SparkMR_39">三、Spark和MR两者之间的详细对比分析（重点）</a></li><li><ul><li><a href="about:blank#31__41">3.1 速度</a></li></ul></li><li><a href="about:blank#32__46">3.2 容错性</a></li><li><a href="about:blank#33__52">3.3 适用性</a></li><li><a href="about:blank#34__58">3.4 框架和生态</a></li><li><a href="about:blank#35__63">3.5 运行环境</a></li><li><a href="about:blank#_74">四、三大分布式计算框架系统</a></li></ul><p>（1）<code>Spark</code>：是分布式计算平台，是一个用scala语言编写的计算框架，基于内存的快速、通用、可扩展的大数据分析引擎 。</p><p>（2）<code>Hadoop</code>：是分布式管理、存储、计算的生态系统；<br>其中包括三大部分：HDFS（存储）、MapReduce（计算）、Yarn（资源调度）</p><h2 id="一、两者实现原理的比较"><a href="#一、两者实现原理的比较" class="headerlink" title="一、两者实现原理的比较"></a>一、两者实现原理的比较</h2><p>1、Hadoop和Spark都是<code>并行计算</code>，两者都是用MR模型进行计算 。Hadoop一个作业称为一个Job，<code>Job里面分为Map Task和Reduce Task阶段</code>，每个Task都在自己的进程中运行，当Task结束时，进程也会随之结束。</p><p>2、Spark用户提交的任务称为<code>application</code>，一个application对应一个SparkContext，app中存在多个job，每触发一次action操作就会产生一个job。这些job可以并行或串行执行，每个job中有多个stage，stage是shuffle过程中DAGScheduler通过RDD之间的依赖关系划分job而来的，每个stage里面有多个task，组成taskset，由TaskScheduler分发到各个executor中执行；executor的生命周期是和app一样的，即使没有job运行也是存在的，所以task可以快速启动读取<code>内存</code>进行计算。</p><p>所以，spark比MR快的原因也在这，MR启动就需要申请资源，用完就销毁，但是spark把进程拿到以后，这个进程会一直存在，即使没有job在跑，所以后边的job可以直接启动，不需要再重新申请资源。</p><blockquote><p>注意：一个Application ——&gt; 多个job ——&gt;一个job多个stage ——&gt; 一个stage多个task</p></blockquote><h2 id="二、-两者多方面的对比"><a href="#二、-两者多方面的对比" class="headerlink" title="二、 两者多方面的对比"></a>二、 两者多方面的对比</h2><p>（1）Spark对标于Hadoop中的计算模块MR，但是速度和效率比MR要快得多；</p><p>（2）Spark没有提供文件管理系统，所以，它必须和其他的分布式文件系统进行集成才能运作，它<code>只是一个计算分析框架</code>，专门用来对分布式存储的数据进行计算处理，它<code>本身并不能存储数据</code>；</p><p>（3）Spark可以使用Hadoop的HDFS或者其他云数据平台进行数据存储，但是<code>一般使用HDFS来进行存储</code>；</p><p>（4）Spark可以使用基于HDFS的HBase数据库，也可以使用HDFS的数据文件，还可以通过jdbc连接使用Mysql数据库数据；<code>Spark可以对数据库数据进行修改删除</code>，而HDFS只能对数据进行追加和全表删除；</p><p>（5）Spark数据处理速度<code>秒杀</code>Hadoop中MR；</p><p>（6）Spark处理数据的设计模式与MR不一样，Hadoop是从HDFS读取数据，通过MR将中间结果写入HDFS；然后再重新从HDFS读取数据进行MR，再刷写到HDFS，这个过程涉及多次落盘操作，多次磁盘IO，效率并不高；而Spark的设计模式是读取集群中的数据后，在<code>内存</code>中存储和运算，直到全部运算完毕后，再存储到集群中；</p><p>（7）Spark是由于Hadoop中MR效率低下而产生的高效率快速计算引擎，批处理速度比MR快近10倍，内存中的数据分析速度比Hadoop快近100倍（源自官网描述）；</p><p>（8）Spark中RDD一般存放在内存中，如果内存不够存放数据，会同时使用磁盘存储数据；通过RDD之间的血缘连接、数据存入内存中切断血缘关系等机制，可以实现灾难恢复，当数据丢失时可以恢复数据；这一点与Hadoop类似，Hadoop基于磁盘读写，天生数据具备可恢复性；</p><p>（9）Spark引进了内存集群计算的概念，可<code>在内存集群计算中将数据集缓存在内存中</code>，以缩短访问延迟；</p><p>（10）Spark中通过DAG有向无环图可以实现良好的容错。</p><h2 id="三、Spark和MR两者之间的详细对比分析（重点）"><a href="#三、Spark和MR两者之间的详细对比分析（重点）" class="headerlink" title="三、Spark和MR两者之间的详细对比分析（重点）"></a>三、Spark和MR两者之间的详细对比分析（重点）</h2><h3 id="3-1-速度"><a href="#3-1-速度" class="headerlink" title="3.1 速度"></a>3.1 速度</h3><p>（1）spark把运算的中间数据存放在<code>内存</code>，迭代计算效率更高；</p><p>（2）mapreduce的中间结果需要保存到<code>磁盘</code>， 这样必然会有磁盘io操做，影响性能。</p><h3 id="3-2-容错性"><a href="#3-2-容错性" class="headerlink" title="3.2 容错性"></a>3.2 容错性</h3><p>（1）spark容错性高，它通过<code>弹性分布式数据集RDD</code>来实现高效容错，RDD是一组分布式的存储在节点内存中的<code>只读</code>性质的数据集，这些集合是弹性的，某一部分丢失或者出错，可以通过整个数据集的计算流程的血缘关系来实现重建；</p><p>（2）mapreduce的容错可能只能重新计算了，成本较高。</p><h3 id="3-3-适用性"><a href="#3-3-适用性" class="headerlink" title="3.3 适用性"></a>3.3 适用性</h3><p>（1）spark更加通用，spark提供了transformation和action这两大类的多个功能API，另外还有流式处理 sparkstreaming模块、图计算GraphX等等；</p><p>（2）mapreduce只提供了map和reduce两种操作，流计算以及其他模块的支持比较缺乏。</p><h3 id="3-4-框架和生态"><a href="#3-4-框架和生态" class="headerlink" title="3.4 框架和生态"></a>3.4 框架和生态</h3><p>（1）Spark框架和生态更为复杂适用范围更广，首先由RDD、血缘lineage、执行时的有向无环图DAG、stage划分等等，很多时候spark作业都需要根据不同的业务场景的需要进行调优，以达到性能要求。</p><p>（2）MR框架及其生态相对较为简单，对性能的要求也相对较弱，但是运行较为稳定，<code>适合长期后台运行以及离线海量数据挖掘计算</code>。</p><h3 id="3-5-运行环境"><a href="#3-5-运行环境" class="headerlink" title="3.5 运行环境"></a>3.5 运行环境</h3><p>（1）spark大致有四种运行模式：</p><blockquote><p><code>local</code>：本地运行<br><code>standalone</code>：使用Spark自带的资源管理框架，运行spark的应用（<strong>常用</strong>）<br><code>yarn</code>：将spark应用类似mr一样，提交到yarn上运行 （<strong>常用</strong>）<br><code>mesos</code>：类似yarn的一种资源管理框架</p></blockquote><p>（2）MR运行在YARN上</p><h2 id="四、三大分布式计算框架系统"><a href="#四、三大分布式计算框架系统" class="headerlink" title="四、三大分布式计算框架系统"></a>四、三大分布式计算框架系统</h2><p>（1）<code>Mapreduce</code>适合处理海量离线的静态数据；</p><p>（2）<code>Spark</code>对实时的数据做批处理；</p><p>（3）<code>Storm/Flink</code>对实时在线的数据做流式处理。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 数据同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dataX剖析</title>
      <link href="/2022/06/10/dataX/"/>
      <url>/2022/06/10/dataX/</url>
      
        <content type="html"><![CDATA[<p>整个流程大致如下<br><img src="https://img-blog.csdnimg.cn/20200825180616261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ljaGFuZzU3Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>先看下官方的介绍，了解下功能和结构。再进行源码的剖析</strong><br>DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jbG91ZC5naXRodWJ1c2VyY29udGVudC5jb20vYXNzZXRzLzEwNjcxNzUvMTc4Nzk4NDEvOTNiN2ZjMWMtNjkyNy0xMWU2LThjZGEtN2NmODQyMGZjNjVmLnBuZw?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p><p>DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader&#x2F;Writer插件，纳入到整个同步框架中。</p><p>Reader：Reader为数据采集模块，负责采集数据源的数据，将数据发送给Framework。</p><p>Writer： Writer为数据写入模块，负责不断向Framework取数据，并将数据写入到目的端。</p><p>Framework：Framework用于连接reader和writer，作为两者的数据传输通道，并处理缓冲，流控，并发，数据转换等核心技术问题。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jbG91ZC5naXRodWJ1c2VyY29udGVudC5jb20vYXNzZXRzLzEwNjcxNzUvMTc4Nzk4ODQvZWM3ZTM2ZjQtNjkyNy0xMWU2LThmNWYtZmZjNDNkNmE0NjhiLnBuZw?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br>DataX3.0核心架构<br>DataX 3.0 开源版本支持单机多线程模式完成同步作业运行，按一个DataX作业生命周期的时序图，从整体架构设计非常简要说明DataX各个模块相互关系<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jbG91ZC5naXRodWJ1c2VyY29udGVudC5jb20vYXNzZXRzLzEwNjcxNzUvMTc4NTA4NDkvYWE2Yzk1YTgtNjg5MS0xMWU2LTk0YjctMzlmMGFiNWFmM2I0LnBuZw?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br>核心模块<br>DataX完成单个数据同步的作业，我们称之为Job，DataX接受到一个Job之后，将启动一个进程来完成整个作业同步过程。DataX Job模块是单个作业的中枢管理节点，承担了数据清理、子任务切分(将单一作业计算转化为多个子Task)、TaskGroup管理等功能。</p><p>DataXJob启动后，会根据不同的源端切分策略，将Job切分成多个小的Task(子任务)，以便于并发执行。Task便是DataX作业的最小单元，每一个Task都会负责一部分数据的同步工作。</p><p>切分多个Task之后，DataX Job会调用Scheduler模块，根据配置的并发数据量，将拆分成的Task重新组合，组装成TaskGroup(任务组)。每一个TaskGroup负责以一定的并发运行完毕分配好的所有Task，默认单个任务组的并发数量为5。</p><p>每一个Task都由TaskGroup负责启动，Task启动后，会固定启动Reader—&gt;Channel—&gt;Writer的线程来完成任务同步工作。</p><p>DataX作业运行起来之后， Job监控并等待多个TaskGroup模块任务完成，等待所有TaskGroup任务完成后Job成功退出。否则，异常退出，进程退出值非0</p><p>DataX任务切分<br>例如用户提交了一个DataX作业，并且配置了10个并发，目的是将一个100张分表的mysql数据同步到目标库。 任务切分过程：</p><p>DataXJob根据分库分表切分成了100个Task。</p><p>根据10个并发，每个TaskGroup默认执行5个task(TaskGroup执行task数量可以设置)DataX计算共需要分配2个TaskGroup。</p><p>2个TaskGroup平分切分好的100个Task，每一个TaskGroup负责以5个并发共计运行50个Task</p><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a><a href="https://blog.csdn.net/ychang577/article/details/108226450"></a>源码剖析</h2><p>任务执行的入口类为Engine</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 入参参数</span><br><span class="line">     * -mode standalone</span><br><span class="line">     * -jobid -1</span><br><span class="line">     * -job E:\\workspace\\datax\\job\\job1.json</span><br><span class="line">     */</span><br><span class="line">    String[] param = &#123;&quot;-mode&quot;, &quot;standalone&quot;, &quot;-jobid&quot;, &quot;-1&quot;, &quot;-job&quot;, &quot;E:\\workspace\\datax\\job\\job1.json&quot;&#125;;</span><br><span class="line">    System.setProperty(&quot;datax.home&quot;, &quot;E:\\workspace\\DataX-master\\core\\src\\main&quot;);</span><br><span class="line">    args = param;</span><br><span class="line">    int exitCode = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        Engine.entry(args);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Job的核心配置</strong>主要包括三个配置</p><blockquote><p>core.json DataX核心配置</p></blockquote><blockquote><p>job.json 本次任务配置</p></blockquote><blockquote><p>plugin.json 本次任务使用到read , write 插件配置</p></blockquote><p>Engine#entry</p><p>1、解析命令行参数 -mode -jobid -job 获取jobid, 和job配置文件路径，执行模式(standalone, local, Distrubuted)</p><p>2、解析本次任务配置，创建新的Engine,执行start()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void entry(final String[] args) throws Throwable &#123;</span><br><span class="line">    Options options = new Options();</span><br><span class="line">    options.addOption(&quot;job&quot;, true, &quot;Job config.&quot;);</span><br><span class="line">    options.addOption(&quot;jobid&quot;, true, &quot;Job unique id.&quot;);</span><br><span class="line">    options.addOption(&quot;mode&quot;, true, &quot;Job runtime mode.&quot;);</span><br><span class="line">    BasicParser parser = new BasicParser();</span><br><span class="line">    CommandLine cl = parser.parse(options, args);   //解析命令参数</span><br><span class="line">    String jobPath = cl.getOptionValue(&quot;job&quot;);</span><br><span class="line">    // 如果用户没有明确指定jobid, 则 datax.py 会指定 jobid 默认值为-1</span><br><span class="line">    String jobIdString = cl.getOptionValue(&quot;jobid&quot;);</span><br><span class="line">    RUNTIME_MODE = cl.getOptionValue(&quot;mode&quot;);</span><br><span class="line">    /**</span><br><span class="line">        * 解析本次job配置</span><br><span class="line">         * Configuration 包括3部分</span><br><span class="line">         * 1、job.json   任务配置</span><br><span class="line">         * 2. core.json  DataX配置</span><br><span class="line">         * 3. plugin.json 插件配置,例如插件类路径...</span><br><span class="line">         */</span><br><span class="line">    Configuration configuration = ConfigParser.parse(jobPath);</span><br><span class="line">    long jobId;</span><br><span class="line">    if (!&quot;-1&quot;.equalsIgnoreCase(jobIdString)) &#123;</span><br><span class="line">        jobId = Long.parseLong(jobIdString);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // only for dsc &amp; ds &amp; datax 3 update</span><br><span class="line">        String dscJobUrlPatternString = &quot;/instance/(\\d&#123;1,&#125;)/config.xml&quot;;</span><br><span class="line">        String dsJobUrlPatternString = &quot;/inner/job/(\\d&#123;1,&#125;)/config&quot;;</span><br><span class="line">        String dsTaskGroupUrlPatternString = &quot;/inner/job/(\\d&#123;1,&#125;)/taskGroup/&quot;;</span><br><span class="line">        List&lt;String&gt; patternStringList = Arrays.asList(dscJobUrlPatternString,</span><br><span class="line">                dsJobUrlPatternString, dsTaskGroupUrlPatternString);</span><br><span class="line">        jobId = parseJobIdFromUrl(patternStringList, jobPath);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isStandAloneMode = &quot;standalone&quot;.equalsIgnoreCase(RUNTIME_MODE);</span><br><span class="line">    if (!isStandAloneMode &amp;&amp; jobId == -1) &#123;</span><br><span class="line">        // 如果不是 standalone 模式，那么 jobId 一定不能为-1</span><br><span class="line">        throw DataXException.asDataXException(FrameworkErrorCode.CONFIG_ERROR, &quot;非 standalone 模式必须在 URL 中提供有效的 jobId.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    configuration.set(CoreConstant.DATAX_CORE_CONTAINER_JOB_ID, jobId);</span><br><span class="line">    //打印vmInfo</span><br><span class="line">    VMInfo vmInfo = VMInfo.getVmInfo();</span><br><span class="line">    if (vmInfo != null) &#123;</span><br><span class="line">        LOG.info(vmInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(&quot;\n&quot; + Engine.filterJobConfiguration(configuration) + &quot;\n&quot;);</span><br><span class="line">    LOG.debug(configuration.toJSON());</span><br><span class="line">    ConfigurationValidate.doValidate(configuration);</span><br><span class="line">    Engine engine = new Engine();</span><br><span class="line">    //通过配置创建一个JobContainer对象.执行start方法</span><br><span class="line">    engine.start(configuration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Engine#start</p><p>1、首先绑定下列转换信息，比如时间格式，时区，编码等,在core.json中的common.column配置项</p><p>2、设置插件配置</p><p>3、创建JobContainer ,并且启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public void start(Configuration allConf) &#123;</span><br><span class="line">    // 绑定column转换信息 时间格式，时区，编码等,在core.json中的common.column配置项</span><br><span class="line">    ColumnCast.bind(allConf);   </span><br><span class="line">    //初始化PluginLoader，可以获取各种插件配置</span><br><span class="line">    LoadUtil.bind(allConf);</span><br><span class="line">    //core.container.model 容器模式，默认是job</span><br><span class="line">    boolean isJob = !(&quot;taskGroup&quot;.equalsIgnoreCase(allConf</span><br><span class="line">            .getString(CoreConstant.DATAX_CORE_CONTAINER_MODEL)));</span><br><span class="line">    //JobContainer会在schedule后再行进行设置和调整值</span><br><span class="line">    int channelNumber =0;</span><br><span class="line">    AbstractContainer container;</span><br><span class="line">    long instanceId;</span><br><span class="line">    int taskGroupId = -1;</span><br><span class="line">    if (isJob) &#123;</span><br><span class="line">        allConf.set(CoreConstant.DATAX_CORE_CONTAINER_JOB_MODE, RUNTIME_MODE);</span><br><span class="line">        container = new JobContainer(allConf);</span><br><span class="line">        instanceId = allConf.getLong(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_JOB_ID, 0);</span><br><span class="line">​</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        container = new TaskGroupContainer(allConf);</span><br><span class="line">        instanceId = allConf.getLong(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_JOB_ID);</span><br><span class="line">        taskGroupId = allConf.getInt(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_ID);</span><br><span class="line">        channelNumber = allConf.getInt(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_CHANNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    //缺省打开perfTrace</span><br><span class="line">    boolean traceEnable = allConf.getBool(CoreConstant.DATAX_CORE_CONTAINER_TRACE_ENABLE, true);</span><br><span class="line">    boolean perfReportEnable = allConf.getBool(CoreConstant.DATAX_CORE_REPORT_DATAX_PERFLOG, true);</span><br><span class="line">    //standlone模式的datax shell任务不进行汇报</span><br><span class="line">    if(instanceId == -1)&#123;</span><br><span class="line">        perfReportEnable = false;</span><br><span class="line">    &#125;</span><br><span class="line">    int priority = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        priority = Integer.parseInt(System.getenv(&quot;SKYNET_PRIORITY&quot;));</span><br><span class="line">    &#125;catch (NumberFormatException e)&#123;</span><br><span class="line">        LOG.warn(&quot;prioriy set to 0, because NumberFormatException, the value is: &quot;+System.getProperty(&quot;PROIORY&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    Configuration jobInfoConfig = allConf.getConfiguration(CoreConstant.DATAX_JOB_JOBINFO);</span><br><span class="line">    //初始化PerfTrace</span><br><span class="line">    PerfTrace perfTrace = PerfTrace.getInstance(isJob, instanceId, taskGroupId, priority, traceEnable);</span><br><span class="line">    perfTrace.setJobInfo(jobInfoConfig,perfReportEnable,channelNumber);</span><br><span class="line">    /**</span><br><span class="line">     * JobContainer.start方法是整个框架核心,</span><br><span class="line">     * 依次执行job的#preHandler,#init,#prepare,#split,#schedule,#post,#postHandler方法</span><br><span class="line">     * 最重要的是#init,#split,#schedule</span><br><span class="line">     */</span><br><span class="line">    container.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JobContainer#start</p><p>任务容器启动器</p><p>preHandler 前置操作，加载job插件等 . (未使用到)</p><p>init 初始化read , write 插件。 这个过程会对数据源，表，列进行校验</p><p>initJobWriter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void init() &#123;</span><br><span class="line">    //..省略部分代码</span><br><span class="line">    //必须先Reader ，后Writer</span><br><span class="line">    this.jobReader = this.initJobReader(jobPluginCollector);</span><br><span class="line">    this.jobWriter = this.initJobWriter(jobPluginCollector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>initJobReader、initJobWriter 初始化插件中，使用了URLCloassLoader对插件类进行加载。解决了类冲突的问题。因此用户可以使用自己的类&#x2F;jar包自定义插件。</p><p>jobReader.init()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private Reader.Job initJobReader(</span><br><span class="line">        JobPluginCollector jobPluginCollector) &#123;</span><br><span class="line">    //获取读插件名称</span><br><span class="line">    this.readerPluginName = this.configuration.getString(</span><br><span class="line">            CoreConstant.DATAX_JOB_CONTENT_READER_NAME);    //job.content[0].reader.name</span><br><span class="line">    //根据读插件类名称,加载插件的lib包加载到jvm中</span><br><span class="line">    classLoaderSwapper.setCurrentThreadClassLoader(LoadUtil.getJarLoader(</span><br><span class="line">            PluginType.READER, this.readerPluginName)); //重置插件jar classLoader</span><br><span class="line">    //创建一个读对象</span><br><span class="line">    Reader.Job jobReader = (Reader.Job) LoadUtil.loadJobPlugin(</span><br><span class="line">            PluginType.READER, this.readerPluginName);</span><br><span class="line">    // 设置reader的jobConfig</span><br><span class="line">    jobReader.setPluginJobConf(this.configuration.getConfiguration(</span><br><span class="line">            CoreConstant.DATAX_JOB_CONTENT_READER_PARAMETER));</span><br><span class="line">    // 设置reader的readerConfig</span><br><span class="line">    jobReader.setPeerPluginJobConf(this.configuration.getConfiguration(</span><br><span class="line">            CoreConstant.DATAX_JOB_CONTENT_WRITER_PARAMETER));</span><br><span class="line">    jobReader.setJobPluginCollector(jobPluginCollector);</span><br><span class="line">    jobReader.init();   //读插件初始化(可以见具体读插件实现类,例如MysqlReader)</span><br><span class="line">    //重置回归原classLoader</span><br><span class="line">    classLoaderSwapper.restoreCurrentThreadClassLoader();</span><br><span class="line">    return jobReader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<br>以MysqlReader为例jobReader#init</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static class Job extends Reader.Job &#123;</span><br><span class="line">    ///...省略其他代码</span><br><span class="line">    @Override</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        this.originalConfig = super.getPluginJobConf(); //Job配置</span><br><span class="line">        Integer userConfigedFetchSize = this.originalConfig.getInt(Constant.FETCH_SIZE);</span><br><span class="line">        if (userConfigedFetchSize != null) &#123;</span><br><span class="line">            LOG.warn(&quot;对 mysqlreader 不需要配置 fetchSize, mysqlreader 将会忽略这项配置. 如果您不想再看到此警告,请去除fetchSize 配置.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.originalConfig.set(Constant.FETCH_SIZE, Integer.MIN_VALUE);</span><br><span class="line">        this.commonRdbmsReaderJob = new CommonRdbmsReader.Job(DATABASE_TYPE);</span><br><span class="line">        this.commonRdbmsReaderJob.init(this.originalConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    ///...省略其他代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以MysqlWriter为例</p><p>jobWriter.init();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private Writer.Job initJobWriter(</span><br><span class="line">        JobPluginCollector jobPluginCollector) &#123;</span><br><span class="line">    this.writerPluginName = this.configuration.getString(</span><br><span class="line">            CoreConstant.DATAX_JOB_CONTENT_WRITER_NAME);</span><br><span class="line">    classLoaderSwapper.setCurrentThreadClassLoader(LoadUtil.getJarLoader(</span><br><span class="line">            PluginType.WRITER, this.writerPluginName));</span><br><span class="line">    Writer.Job jobWriter = (Writer.Job) LoadUtil.loadJobPlugin(</span><br><span class="line">            PluginType.WRITER, this.writerPluginName);</span><br><span class="line">    //...省略部分代码</span><br><span class="line">    jobWriter.init();</span><br><span class="line">    classLoaderSwapper.restoreCurrentThreadClassLoader();</span><br><span class="line">    return jobWriter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>jobWriter#init</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static class Job extends Writer.Job &#123;</span><br><span class="line">    //...省略部分代码</span><br><span class="line">    @Override</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        this.originalConfig = super.getPluginJobConf();</span><br><span class="line">        this.commonRdbmsWriterJob = new CommonRdbmsWriter.Job(DATABASE_TYPE);</span><br><span class="line">        this.commonRdbmsWriterJob.init(this.originalConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>prepare read, write插件做一些前置操作</p><p>实现为具体插件类的prepare方法</p><p>split 任务拆分</p><p>schedule 首先完成的工作是把上一步reader和writer split的结果整合到具体taskGroupContainer中,同时不同的执行模式调用不同的调度策略，将所有任务调度起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 执行reader和writer最细粒度的切分，需要注意的是，writer的切分结果要参照reader的切分结果，</span><br><span class="line"> * 达到切分后数目相等，才能满足1：1的通道模型，所以这里可以将reader和writer的配置整合到一起，</span><br><span class="line"> * 然后，为避免顺序给读写端带来长尾影响，将整合的结果shuffler掉</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">private int split() &#123;</span><br><span class="line">    //设置channel数量</span><br><span class="line">    this.adjustChannelNumber();</span><br><span class="line">    if (this.needChannelNumber &lt;= 0) &#123;</span><br><span class="line">        this.needChannelNumber = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Configuration&gt; readerTaskConfigs = this</span><br><span class="line">            .doReaderSplit(this.needChannelNumber);</span><br><span class="line">    int taskNumber = readerTaskConfigs.size();</span><br><span class="line">    List&lt;Configuration&gt; writerTaskConfigs = this</span><br><span class="line">            .doWriterSplit(taskNumber);</span><br><span class="line">    //job.content[0].transformer</span><br><span class="line">    List&lt;Configuration&gt; transformerList = this.configuration.getListConfiguration(CoreConstant.DATAX_JOB_CONTENT_TRANSFORMER);</span><br><span class="line">    //合并读任务配置、写任务配置、transformer配置</span><br><span class="line">    //输入是reader和writer的parameter list，输出是content下面元素的list</span><br><span class="line">    List&lt;Configuration&gt; contentConfig = mergeReaderAndWriterTaskConfigs(</span><br><span class="line">            readerTaskConfigs, writerTaskConfigs, transformerList);</span><br><span class="line">    //job.content 合并后的总配置</span><br><span class="line">    this.configuration.set(CoreConstant.DATAX_JOB_CONTENT, contentConfig);</span><br><span class="line">    return contentConfig.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置管道数量 adjustChannelNumber()</p><p>1、配置 job.setting.speed.byte (jobByte)， 则必须设置 core.transport.channel.speed.byte (coreByte) ，channelNumber &#x3D; coreByte &#x2F; jobByte &gt; 0 ? coreByte &#x2F; jobByte : 1</p><p>2、配置job.setting.speed.record (jobRecord) , 则必须配置core.transport.channel.speed.record（coreRecord）</p><p>channelNumber &#x3D; coreRecord&#x2F; jobRecord&gt; 0 ? coreRecord&#x2F; jobRecord: 1</p><p>如果上面2个任意配置了一个或2个，取较小值为channelNumber ，如果没有配置。则必须要配置job.setting.speed.channel 作为管道数量</p><p>下面切分读任务和写任务，最后把读写任务配置合并<br>#doReaderSplit 读切分任务是read插件实现的<br>我这里使用的是mysqlreader 插件，最后还是引用的框架的split实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Configuration&gt; split(int adviceNumber) &#123;</span><br><span class="line">    return this.commonRdbmsReaderJob.split(this.originalConfig, adviceNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#doWriterSplit写切分任务<br>写切分任务数量是根据读切分后的数量而来，写任务必须与读任务数一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;Configuration&gt; doWriterSplit(int readerTaskNumber) &#123;</span><br><span class="line">    classLoaderSwapper.setCurrentThreadClassLoader(LoadUtil.getJarLoader(</span><br><span class="line">            PluginType.WRITER, this.writerPluginName));</span><br><span class="line">​</span><br><span class="line">    List&lt;Configuration&gt; writerSlicesConfigs = this.jobWriter</span><br><span class="line">            .split(readerTaskNumber);</span><br><span class="line">    if (writerSlicesConfigs == null || writerSlicesConfigs.size() &lt;= 0) &#123;</span><br><span class="line">        throw DataXException.asDataXException(</span><br><span class="line">                FrameworkErrorCode.PLUGIN_SPLIT_ERROR,</span><br><span class="line">                &quot;writer切分的task不能小于等于0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    classLoaderSwapper.restoreCurrentThreadClassLoader();</span><br><span class="line">    return writerSlicesConfigs;</span><br><span class="line">&#125;</span><br><span class="line">public List&lt;Configuration&gt; split(int mandatoryNumber) &#123;</span><br><span class="line">    return this.commonRdbmsWriterJob.split(this.originalConfig, mandatoryNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切分读任务：</p><p>1、table模式 ：当没有配置splitPk时，任务数量与table数量一样.比如table配置了2个(user_info, user_info_1) 则生成2任务个配置</p><p>2、table模式 ：配置splitPk时，配合channel一起使用。任务数 &#x3D; (向上取整)(channel&#x2F;table数量) ,当任务数 &gt; 1 .会重新切分任务</p><p>最终任务数 &#x3D; 任务数 * 5 + 1 。 （这里程序实际根据job配置的splitPk请求了数据库，并且把查询出的pk范围分别加入到每个任务的pk条件中去）。 例如user_info表pk为user_id. 最终的sql会加上 and user_id &gt; 下限 and user_id &lt; 上限.</p><p>3、querySql模式 ：有几条querySql ， 生成相同数量的任务配置</p><p>切分写任务</p><p>1、写单表的时，生成tabel表数量的任务 或者 querySql数量相等的任务</p><p>2、多表时，生成和表数量相同的任务</p><p>schedule执行任务<br>1、首先拿到任务组执行任务数量配置，再结合切分后任务数量对任务进行分组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int channelsPerTaskGroup = this.configuration.getInt(</span><br><span class="line">        CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_CHANNEL, 5);</span><br><span class="line">int taskNumber = this.configuration.getList(</span><br><span class="line">        CoreConstant.DATAX_JOB_CONTENT).size();</span><br><span class="line">this.needChannelNumber = Math.min(this.needChannelNumber, taskNumber);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;通过获取配置信息得到每个taskGroup需要运行哪些tasks任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Configuration&gt; taskGroupConfigs = JobAssignUtil.assignFairly(this.configuration,</span><br><span class="line">      this.needChannelNumber, channelsPerTaskGroup);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、创建任务执行器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AbstractScheduler scheduler = initStandaloneScheduler(this.configuration);</span><br><span class="line">private AbstractScheduler initStandaloneScheduler(Configuration configuration) &#123;</span><br><span class="line">        AbstractContainerCommunicator containerCommunicator = new StandAloneJobContainerCommunicator(configuration);</span><br><span class="line">        super.setContainerCommunicator(containerCommunicator);</span><br><span class="line">​</span><br><span class="line">        return new StandAloneScheduler(containerCommunicator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、执行任务</p><p>scheduler.schedule(taskGroupConfigs); &#x2F;&#x2F;schedule方法先获取收集信息的属性，比如说间隔多长时间汇报,休眠时间等<br>&#x2F;&#x2F;然后开启任务<br>startAllTaskGroup(configurations); &#x2F;&#x2F;重点，这里开启执行任务<br>&#x2F;&#x2F;后面代码是收集打印任务的汇报信息<br>4、创建线程池，提交任务</p><p>创建了一个与任务数量大小一致的固定线程池，满足完成当前任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void startAllTaskGroup(List&lt;Configuration&gt; configurations) &#123;</span><br><span class="line">    //创建一个任务数量大小的固定线程池</span><br><span class="line">    this.taskGroupContainerExecutorService = Executors</span><br><span class="line">            .newFixedThreadPool(configurations.size());</span><br><span class="line">    for (Configuration taskGroupConfiguration : configurations) &#123;</span><br><span class="line">        TaskGroupContainerRunner taskGroupContainerRunner = newTaskGroupContainerRunner(taskGroupConfiguration);</span><br><span class="line">        this.taskGroupContainerExecutorService.execute(taskGroupContainerRunner);</span><br><span class="line">    &#125;</span><br><span class="line">    this.taskGroupContainerExecutorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、容器组启动</p><p>TaskGroupContainer类为执行任务的承载容器，重点关注</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TaskGroupContainerRunner implements Runnable &#123;</span><br><span class="line">   private TaskGroupContainer taskGroupContainer;</span><br><span class="line">   private State state;</span><br><span class="line">   public TaskGroupContainerRunner(TaskGroupContainer taskGroup) &#123;</span><br><span class="line">        this.taskGroupContainer = taskGroup;</span><br><span class="line">        this.state = State.SUCCEEDED;</span><br><span class="line">    &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">            Thread.currentThread().setName(</span><br><span class="line">                    String.format(&quot;taskGroup-%d&quot;, this.taskGroupContainer.getTaskGroupId()));</span><br><span class="line">            this.taskGroupContainer.start();    //开始执行任务</span><br><span class="line">         this.state = State.SUCCEEDED;</span><br><span class="line">      &#125; catch (Throwable e) &#123;</span><br><span class="line">         this.state = State.FAILED;</span><br><span class="line">         throw DataXException.asDataXException(</span><br><span class="line">               FrameworkErrorCode.RUNTIME_ERROR, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<br>TaskGroupContainer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">public class TaskGroupContainer extends AbstractContainer &#123;</span><br><span class="line">    private static final Logger LOG = LoggerFactory</span><br><span class="line">            .getLogger(TaskGroupContainer.class);</span><br><span class="line">    //当前taskGroup所属jobId</span><br><span class="line">    private long jobId;</span><br><span class="line">    //当前taskGroupId</span><br><span class="line">    private int taskGroupId;</span><br><span class="line">    //使用的channel类</span><br><span class="line">    private String channelClazz;</span><br><span class="line">    //task收集器使用的类</span><br><span class="line">    private String taskCollectorClass;</span><br><span class="line">​</span><br><span class="line">    private TaskMonitor taskMonitor = TaskMonitor.getInstance();</span><br><span class="line">​</span><br><span class="line">    public TaskGroupContainer(Configuration configuration) &#123;</span><br><span class="line">        super(configuration);</span><br><span class="line">        initCommunicator(configuration);    //初始化通信器</span><br><span class="line">        this.jobId = this.configuration.getLong(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_JOB_ID);</span><br><span class="line">        //core.container.taskGroup.id 任务组id</span><br><span class="line">        this.taskGroupId = this.configuration.getInt(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_ID);</span><br><span class="line">        //管道实现类 core.transport.channel.class</span><br><span class="line">        this.channelClazz = this.configuration.getString(</span><br><span class="line">                CoreConstant.DATAX_CORE_TRANSPORT_CHANNEL_CLASS);</span><br><span class="line">        //任务收集器 core.statistics.collector.plugin.taskClass</span><br><span class="line">        this.taskCollectorClass = this.configuration.getString(</span><br><span class="line">                CoreConstant.DATAX_CORE_STATISTICS_COLLECTOR_PLUGIN_TASKCLASS);</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 状态check时间间隔，较短，可以把任务及时分发到对应channel中</span><br><span class="line">             * core.container.taskGroup.sleepInterval</span><br><span class="line">             */</span><br><span class="line">            int sleepIntervalInMillSec = this.configuration.getInt(</span><br><span class="line">                    CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_SLEEPINTERVAL, 100);</span><br><span class="line">            /**</span><br><span class="line">             * 状态汇报时间间隔，稍长，避免大量汇报</span><br><span class="line">             * core.container.taskGroup.reportInterval</span><br><span class="line">             */</span><br><span class="line">            long reportIntervalInMillSec = this.configuration.getLong(</span><br><span class="line">                    CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_REPORTINTERVAL,</span><br><span class="line">                    10000);</span><br><span class="line">            /**</span><br><span class="line">             * 2分钟汇报一次性能统计</span><br><span class="line">             */</span><br><span class="line">            //core.container.taskGroup.channel</span><br><span class="line">            // 获取channel数目</span><br><span class="line">            int channelNumber = this.configuration.getInt(</span><br><span class="line">                    CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_CHANNEL);</span><br><span class="line">            //最大重试次数 core.container.task.failOver.maxRetryTimes 默认1次</span><br><span class="line">            int taskMaxRetryTimes = this.configuration.getInt(</span><br><span class="line">                    CoreConstant.DATAX_CORE_CONTAINER_TASK_FAILOVER_MAXRETRYTIMES, 1);</span><br><span class="line">            //任务组重试间隔时间 core.container.task.failOver.retryIntervalInMsec</span><br><span class="line">            long taskRetryIntervalInMsec = this.configuration.getLong(</span><br><span class="line">                    CoreConstant.DATAX_CORE_CONTAINER_TASK_FAILOVER_RETRYINTERVALINMSEC, 10000);</span><br><span class="line">            //core.container.task.failOver.maxWaitInMsec</span><br><span class="line">            long taskMaxWaitInMsec = this.configuration.getLong(CoreConstant.DATAX_CORE_CONTAINER_TASK_FAILOVER_MAXWAITINMSEC, 60000);</span><br><span class="line">            //获取当前任务组所有任务配置</span><br><span class="line">            List&lt;Configuration&gt; taskConfigs = this.configuration</span><br><span class="line">                    .getListConfiguration(CoreConstant.DATAX_JOB_CONTENT);</span><br><span class="line">            int taskCountInThisTaskGroup = taskConfigs.size();</span><br><span class="line">            LOG.info(String.format(</span><br><span class="line">                    &quot;taskGroupId=[%d] start [%d] channels for [%d] tasks.&quot;,</span><br><span class="line">                    this.taskGroupId, channelNumber, taskCountInThisTaskGroup));</span><br><span class="line">            //任务组注册通信器</span><br><span class="line">            this.containerCommunicator.registerCommunication(taskConfigs);</span><br><span class="line">            //taskId与task配置</span><br><span class="line">            Map&lt;Integer, Configuration&gt; taskConfigMap = buildTaskConfigMap(taskConfigs);</span><br><span class="line">            List&lt;Configuration&gt; taskQueue = buildRemainTasks(taskConfigs); //待运行task列表</span><br><span class="line">            Map&lt;Integer, TaskExecutor&gt; taskFailedExecutorMap = new HashMap&lt;Integer, TaskExecutor&gt;();            //taskId与上次失败实例</span><br><span class="line">            List&lt;TaskExecutor&gt; runTasks = new ArrayList&lt;TaskExecutor&gt;(channelNumber); //正在运行task</span><br><span class="line">            Map&lt;Integer, Long&gt; taskStartTimeMap = new HashMap&lt;Integer, Long&gt;(); //任务开始时间</span><br><span class="line">            long lastReportTimeStamp = 0;</span><br><span class="line">            Communication lastTaskGroupContainerCommunication = new Communication();</span><br><span class="line">           //这里开始进入循环作业</span><br><span class="line">            while (true) &#123;</span><br><span class="line">               //1.判断task状态</span><br><span class="line">               boolean failedOrKilled = false;</span><br><span class="line">               Map&lt;Integer, Communication&gt; communicationMap = containerCommunicator.getCommunicationMap();  //任务id对应通信器,用来收集任务作业情况</span><br><span class="line">               for(Map.Entry&lt;Integer, Communication&gt; entry : communicationMap.entrySet())&#123;</span><br><span class="line">                  Integer taskId = entry.getKey();</span><br><span class="line">                  Communication taskCommunication = entry.getValue();</span><br><span class="line">                    if(!taskCommunication.isFinished())&#123;</span><br><span class="line">                        continue;   //当前任务未结束,继续执行</span><br><span class="line">                    &#125;</span><br><span class="line">                    //已经结束的任务,从正在运行的任务集合中移除</span><br><span class="line">                    TaskExecutor taskExecutor = removeTask(runTasks, taskId);</span><br><span class="line">                    //上面从runTasks里移除了，因此对应在monitor里移除</span><br><span class="line">                    taskMonitor.removeTask(taskId);</span><br><span class="line">                    //失败，看task是否支持failover，重试次数未超过最大限制</span><br><span class="line">                  if(taskCommunication.getState() == State.FAILED)&#123;</span><br><span class="line">                        taskFailedExecutorMap.put(taskId, taskExecutor);</span><br><span class="line">                     if(taskExecutor.supportFailOver() &amp;&amp; taskExecutor.getAttemptCount() &lt; taskMaxRetryTimes)&#123;</span><br><span class="line">                            taskExecutor.shutdown(); //关闭老的executor</span><br><span class="line">                            containerCommunicator.resetCommunication(taskId); //将task的状态重置</span><br><span class="line">                        Configuration taskConfig = taskConfigMap.get(taskId);</span><br><span class="line">                        taskQueue.add(taskConfig); //重新加入任务列表</span><br><span class="line">                     &#125;else&#123;</span><br><span class="line">                        failedOrKilled = true;</span><br><span class="line">                         break;</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;else if(taskCommunication.getState() == State.KILLED)&#123;</span><br><span class="line">                     failedOrKilled = true;</span><br><span class="line">                     break;</span><br><span class="line">                  &#125;else if(taskCommunication.getState() == State.SUCCEEDED)&#123;</span><br><span class="line">                        Long taskStartTime = taskStartTimeMap.get(taskId);</span><br><span class="line">                        if(taskStartTime != null)&#123;</span><br><span class="line">                            Long usedTime = System.currentTimeMillis() - taskStartTime;</span><br><span class="line">                            LOG.info(&quot;taskGroup[&#123;&#125;] taskId[&#123;&#125;] is successed, used[&#123;&#125;]ms&quot;,</span><br><span class="line">                                    this.taskGroupId, taskId, usedTime);</span><br><span class="line">                            //usedTime*1000*1000 转换成PerfRecord记录的ns，这里主要是简单登记，进行最长任务的打印。因此增加特定静态方法</span><br><span class="line">                            PerfRecord.addPerfRecord(taskGroupId, taskId, PerfRecord.PHASE.TASK_TOTAL,taskStartTime, usedTime * 1000L * 1000L);</span><br><span class="line">                            taskStartTimeMap.remove(taskId);</span><br><span class="line">                            taskConfigMap.remove(taskId);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">                // 2.发现该taskGroup下taskExecutor的总状态失败则汇报错误</span><br><span class="line">                if (failedOrKilled) &#123;</span><br><span class="line">                    lastTaskGroupContainerCommunication = reportTaskGroupCommunication(</span><br><span class="line">                            lastTaskGroupContainerCommunication, taskCountInThisTaskGroup);</span><br><span class="line">​</span><br><span class="line">                    throw DataXException.asDataXException(</span><br><span class="line">                            FrameworkErrorCode.PLUGIN_RUNTIME_ERROR, lastTaskGroupContainerCommunication.getThrowable());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //3.有任务未执行，且正在运行的任务数小于最大通道限制</span><br><span class="line">                Iterator&lt;Configuration&gt; iterator = taskQueue.iterator();</span><br><span class="line">                while(iterator.hasNext() &amp;&amp; runTasks.size() &lt; channelNumber)&#123;</span><br><span class="line">                    Configuration taskConfig = iterator.next();</span><br><span class="line">                    Integer taskId = taskConfig.getInt(CoreConstant.TASK_ID);</span><br><span class="line">                    int attemptCount = 1;</span><br><span class="line">                    TaskExecutor lastExecutor = taskFailedExecutorMap.get(taskId);</span><br><span class="line">                    if(lastExecutor!=null)&#123;</span><br><span class="line">                        attemptCount = lastExecutor.getAttemptCount() + 1;</span><br><span class="line">                        long now = System.currentTimeMillis();</span><br><span class="line">                        long failedTime = lastExecutor.getTimeStamp();</span><br><span class="line">                        if(now - failedTime &lt; taskRetryIntervalInMsec)&#123;  //未到等待时间，继续留在队列</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if(!lastExecutor.isShutdown())&#123; //上次失败的task仍未结束</span><br><span class="line">                            if(now - failedTime &gt; taskMaxWaitInMsec)&#123;</span><br><span class="line">                                markCommunicationFailed(taskId);</span><br><span class="line">                                reportTaskGroupCommunication(lastTaskGroupContainerCommunication, taskCountInThisTaskGroup);</span><br><span class="line">                                throw DataXException.asDataXException(CommonErrorCode.WAIT_TIME_EXCEED, &quot;task failover等待超时&quot;);</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                lastExecutor.shutdown(); //再次尝试关闭</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            LOG.info(&quot;taskGroup[&#123;&#125;] taskId[&#123;&#125;] attemptCount[&#123;&#125;] has already shutdown&quot;,</span><br><span class="line">                                    this.taskGroupId, taskId, lastExecutor.getAttemptCount());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Configuration taskConfigForRun = taskMaxRetryTimes &gt; 1 ? taskConfig.clone() : taskConfig;</span><br><span class="line">                   TaskExecutor taskExecutor = new TaskExecutor(taskConfigForRun, attemptCount);</span><br><span class="line">                    taskStartTimeMap.put(taskId, System.currentTimeMillis());</span><br><span class="line">                   taskExecutor.doStart();</span><br><span class="line">​</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    runTasks.add(taskExecutor); //继续添加到运行的任务集合</span><br><span class="line">                    //上面，增加task到runTasks列表，因此在monitor里注册。</span><br><span class="line">                    taskMonitor.registerTask(taskId, this.containerCommunicator.getCommunication(taskId));</span><br><span class="line">                  //刚刚已经添加了task，这里把任务id从失败map移除</span><br><span class="line">                    taskFailedExecutorMap.remove(taskId);</span><br><span class="line">                    LOG.info(&quot;taskGroup[&#123;&#125;] taskId[&#123;&#125;] attemptCount[&#123;&#125;] is started&quot;,</span><br><span class="line">                            this.taskGroupId, taskId, attemptCount);</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">                //4.任务列表为空，executor已结束, 搜集状态为success---&gt;成功</span><br><span class="line">                if (taskQueue.isEmpty() &amp;&amp; isAllTaskDone(runTasks) &amp;&amp; containerCommunicator.collectState() == State.SUCCEEDED) &#123;</span><br><span class="line">                   // 成功的情况下，也需要汇报一次。否则在任务结束非常快的情况下，采集的信息将会不准确</span><br><span class="line">                    lastTaskGroupContainerCommunication = reportTaskGroupCommunication(</span><br><span class="line">                            lastTaskGroupContainerCommunication, taskCountInThisTaskGroup);</span><br><span class="line">                    LOG.info(&quot;taskGroup[&#123;&#125;] completed it&#x27;s tasks.&quot;, this.taskGroupId);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 5.如果当前时间已经超出汇报时间的interval，那么我们需要马上汇报</span><br><span class="line">                long now = System.currentTimeMillis();</span><br><span class="line">                if (now - lastReportTimeStamp &gt; reportIntervalInMillSec) &#123;</span><br><span class="line">                    lastTaskGroupContainerCommunication = reportTaskGroupCommunication(</span><br><span class="line">                            lastTaskGroupContainerCommunication, taskCountInThisTaskGroup);</span><br><span class="line">                    lastReportTimeStamp = now;</span><br><span class="line">                    //taskMonitor对于正在运行的task，每reportIntervalInMillSec进行检查</span><br><span class="line">                    for(TaskExecutor taskExecutor:runTasks)&#123;   taskMonitor.report(taskExecutor.getTaskId(),this.containerCommunicator.getCommunication(taskExecutor.getTaskId()));</span><br><span class="line">                    &#125;</span><br><span class="line">​</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(sleepIntervalInMillSec);</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            //6.最后还要汇报一次</span><br><span class="line">            reportTaskGroupCommunication(lastTaskGroupContainerCommunication, taskCountInThisTaskGroup);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            Communication nowTaskGroupContainerCommunication = this.containerCommunicator.collect();</span><br><span class="line">            if (nowTaskGroupContainerCommunication.getThrowable() == null) &#123;</span><br><span class="line">                nowTaskGroupContainerCommunication.setThrowable(e);</span><br><span class="line">            &#125;</span><br><span class="line">            nowTaskGroupContainerCommunication.setState(State.FAILED);</span><br><span class="line">            this.containerCommunicator.report(nowTaskGroupContainerCommunication);</span><br><span class="line">            throw DataXException.asDataXException(</span><br><span class="line">                    FrameworkErrorCode.RUNTIME_ERROR, e);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(!PerfTrace.getInstance().isJob())&#123;</span><br><span class="line">                //最后打印cpu的平均消耗，GC的统计</span><br><span class="line">                VMInfo vmInfo = VMInfo.getVmInfo();</span><br><span class="line">                if (vmInfo != null) &#123;</span><br><span class="line">                    vmInfo.getDelta(false);</span><br><span class="line">                    LOG.info(vmInfo.totalString());</span><br><span class="line">                &#125;</span><br><span class="line">                LOG.info(PerfTrace.getInstance().summarizeNoException());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TaskExecute 具体执行类<br>开启了2个线程，分别进行读操作和写操作。</p><p>数据处理：读操作（ReaderRunner）把从数据库中读出来的每条数据封装为一个个Record放入Channel中,当数据读完时，写入一个TerminateRecord标识结束</p><p>写操作（WriterRunner）不断从Channel中读取Record，直到读到TerminateRecord标识数据以取完</p><p>ReaderRunner分别执行#init, #prepare, #startRead, #post 并记录每个阶段的处理信息(数据量，数据大小…)</p><p>WriterRunner分别执行#init, #prepare, #start, #post 并记录每个阶段的处理信息(数据量，数据大小…)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class TaskExecutor &#123;</span><br><span class="line">    private Configuration taskConfig;   //当前任务配置项</span><br><span class="line">    private Channel channel;    //管道 用于缓存读出来的数据</span><br><span class="line">    private Thread readerThread;    //读线程</span><br><span class="line">    private Thread writerThread;    //写线程</span><br><span class="line">    private ReaderRunner readerRunner;</span><br><span class="line">    private WriterRunner writerRunner;</span><br><span class="line">​</span><br><span class="line">    /**</span><br><span class="line">     * 该处的taskCommunication在多处用到：</span><br><span class="line">     * 1. channel</span><br><span class="line">     * 2. readerRunner和writerRunner</span><br><span class="line">     * 3. reader和writer的taskPluginCollector</span><br><span class="line">     */</span><br><span class="line">    private Communication taskCommunication;</span><br><span class="line">​</span><br><span class="line">    public TaskExecutor(Configuration taskConf, int attemptCount) &#123;</span><br><span class="line">        // 获取该taskExecutor的配置</span><br><span class="line">        this.taskConfig = taskConf;</span><br><span class="line">        //...</span><br><span class="line">        /**</span><br><span class="line">         * 由taskId得到该taskExecutor的Communication</span><br><span class="line">         * 要传给readerRunner和writerRunner，同时要传给channel作统计用</span><br><span class="line">         */</span><br><span class="line">        this.taskCommunication = containerCommunicator</span><br><span class="line">                .getCommunication(taskId);</span><br><span class="line">        //实例化存储读数据的管道</span><br><span class="line">        this.channel = ClassUtil.instantiate(channelClazz,</span><br><span class="line">                Channel.class, configuration);</span><br><span class="line">        this.channel.setCommunication(this.taskCommunication);</span><br><span class="line">        /**</span><br><span class="line">         * 获取transformer的参数</span><br><span class="line">         */</span><br><span class="line">        List&lt;TransformerExecution&gt; transformerInfoExecs = TransformerUtil.buildTransformerInfo(taskConfig);</span><br><span class="line">        /**</span><br><span class="line">         * 生成writerThread</span><br><span class="line">         */</span><br><span class="line">        writerRunner = (WriterRunner) generateRunner(PluginType.WRITER);</span><br><span class="line">        this.writerThread = new Thread(writerRunner,</span><br><span class="line">                String.format(&quot;%d-%d-%d-writer&quot;,</span><br><span class="line">                        jobId, taskGroupId, this.taskId));</span><br><span class="line">        //通过设置thread的contextClassLoader，即可实现同步和主程序不通的加载器</span><br><span class="line">        this.writerThread.setContextClassLoader(LoadUtil.getJarLoader(</span><br><span class="line">                PluginType.WRITER, this.taskConfig.getString(</span><br><span class="line">                        CoreConstant.JOB_WRITER_NAME)));</span><br><span class="line">        /**</span><br><span class="line">         * 生成readerThread</span><br><span class="line">         */</span><br><span class="line">        readerRunner = (ReaderRunner) generateRunner(PluginType.READER,transformerInfoExecs);</span><br><span class="line">        this.readerThread = new Thread(readerRunner,</span><br><span class="line">                String.format(&quot;%d-%d-%d-reader&quot;,</span><br><span class="line">                        jobId, taskGroupId, this.taskId));</span><br><span class="line">        /**</span><br><span class="line">         * 通过设置thread的contextClassLoader，即可实现同步和主程序不通的加载器</span><br><span class="line">         */</span><br><span class="line">        this.readerThread.setContextClassLoader(LoadUtil.getJarLoader(</span><br><span class="line">                PluginType.READER, this.taskConfig.getString(</span><br><span class="line">                        CoreConstant.JOB_READER_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    public void doStart() &#123;</span><br><span class="line">        this.writerThread.start();</span><br><span class="line">        // reader没有起来，writer不可能结束</span><br><span class="line">        if (!this.writerThread.isAlive() || this.taskCommunication.getState() == State.FAILED) &#123;</span><br><span class="line">            throw DataXException.asDataXException(</span><br><span class="line">                    FrameworkErrorCode.RUNTIME_ERROR,</span><br><span class="line">                    this.taskCommunication.getThrowable());</span><br><span class="line">        &#125;</span><br><span class="line">        this.readerThread.start();</span><br><span class="line">        // 这里reader可能很快结束</span><br><span class="line">        if (!this.readerThread.isAlive() &amp;&amp; this.taskCommunication.getState() == State.FAILED) &#123;</span><br><span class="line">            // 这里有可能出现Reader线上启动即挂情况 对于这类情况 需要立刻抛出异常</span><br><span class="line">            throw DataXException.asDataXException(</span><br><span class="line">                    FrameworkErrorCode.RUNTIME_ERROR,</span><br><span class="line">                    this.taskCommunication.getThrowable());</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以MySqlReader插件为例，ReaderRunner在执行#init, #prepare, #startRead, #post 时，实现在MysqlReader中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static class Task extends Reader.Task &#123;</span><br><span class="line">    public void startRead(RecordSender recordSender) &#123;</span><br><span class="line">        int fetchSize = this.readerSliceConfig.getInt(Constant.FETCH_SIZE);</span><br><span class="line">        //mysqlReader调commonRdbmsReaderTask读数据</span><br><span class="line">        this.commonRdbmsReaderTask.startRead(this.readerSliceConfig, recordSender,</span><br><span class="line">                super.getTaskPluginCollector(), fetchSize);</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public void startRead(Configuration readerSliceConfig,</span><br><span class="line">                      RecordSender recordSender,</span><br><span class="line">                      TaskPluginCollector taskPluginCollector, int fetchSize) &#123;</span><br><span class="line">    //获取job配置中的querySql</span><br><span class="line">    String querySql = readerSliceConfig.getString(Key.QUERY_SQL);</span><br><span class="line">    //获取job配置中的tabelName   querySql和table 不能并存,否则程序会提示配置错误</span><br><span class="line">    String table = readerSliceConfig.getString(Key.TABLE);</span><br><span class="line">    PerfTrace.getInstance().addTaskDetails(taskId, table + &quot;,&quot; + basicMsg);</span><br><span class="line">    LOG.info(&quot;Begin to read record by Sql: [&#123;&#125;\n] &#123;&#125;.&quot;,</span><br><span class="line">            querySql, basicMsg);</span><br><span class="line">    PerfRecord queryPerfRecord = new PerfRecord(taskGroupId,taskId, PerfRecord.PHASE.SQL_QUERY);</span><br><span class="line">    queryPerfRecord.start();</span><br><span class="line">    //获取数据库连接</span><br><span class="line">    Connection conn = DBUtil.getConnection(this.dataBaseType, jdbcUrl,</span><br><span class="line">            username, password);</span><br><span class="line">​</span><br><span class="line">    // session config .etc related</span><br><span class="line">    DBUtil.dealWithSessionConfig(conn, readerSliceConfig,</span><br><span class="line">            this.dataBaseType, basicMsg);</span><br><span class="line">    int columnNumber = 0;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        rs = DBUtil.query(conn, querySql, fetchSize);   //拿数据</span><br><span class="line">        queryPerfRecord.end();</span><br><span class="line">        //获取表原信息</span><br><span class="line">        ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line">        columnNumber = metaData.getColumnCount();</span><br><span class="line">        //这个统计干净的result_Next时间</span><br><span class="line">        PerfRecord allResultPerfRecord = new PerfRecord(taskGroupId, taskId, PerfRecord.PHASE.RESULT_NEXT_ALL);</span><br><span class="line">        allResultPerfRecord.start();</span><br><span class="line">        long rsNextUsedTime = 0;</span><br><span class="line">        long lastTime = System.nanoTime();</span><br><span class="line">        while (rs.next()) &#123;</span><br><span class="line">            rsNextUsedTime += (System.nanoTime() - lastTime);</span><br><span class="line">            //将读的数据放入recordSender对象的channel中</span><br><span class="line">            this.transportOneRecord(recordSender, rs,</span><br><span class="line">                    metaData, columnNumber, mandatoryEncoding, taskPluginCollector);</span><br><span class="line">            lastTime = System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        allResultPerfRecord.end(rsNextUsedTime);</span><br><span class="line">        //目前大盘是依赖这个打印，而之前这个Finish read record是包含了sql查询和result next的全部时间</span><br><span class="line">        LOG.info(&quot;Finished read record by Sql: [&#123;&#125;\n] &#123;&#125;.&quot;,</span><br><span class="line">                querySql, basicMsg);</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">        throw RdbmsException.asQueryException(this.dataBaseType, e, querySql, table, username);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        DBUtil.closeDBResources(null, conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">protected Record transportOneRecord(RecordSender recordSender, ResultSet rs, </span><br><span class="line">        ResultSetMetaData metaData, int columnNumber, String mandatoryEncoding, </span><br><span class="line">        TaskPluginCollector taskPluginCollector) &#123;</span><br><span class="line">    //每条数据组装一个record</span><br><span class="line">    Record record = buildRecord(recordSender,rs,metaData,columnNumber,mandatoryEncoding,taskPluginCollector); </span><br><span class="line">    //record放入recordSender缓存</span><br><span class="line">    recordSender.sendToWriter(record);</span><br><span class="line">    return record;</span><br><span class="line">&#125;</span><br><span class="line">flush</span><br><span class="line">public void sendToWriter(Record record) &#123;</span><br><span class="line">   //...</span><br><span class="line">   boolean isFull = (this.bufferIndex &gt;= this.bufferSize || this.memoryBytes.get() + record.getMemorySize() &gt; this.byteCapacity);</span><br><span class="line">   if (isFull) &#123;</span><br><span class="line">      flush();  //这里会把buffer放入channel中</span><br><span class="line">   &#125;</span><br><span class="line">   //放入集合列表</span><br><span class="line">   this.buffer.add(record);</span><br><span class="line">   this.bufferIndex++;</span><br><span class="line">   memoryBytes.addAndGet(record.getMemorySize());</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">public void flush() &#123;</span><br><span class="line">    //...</span><br><span class="line">    this.channel.pushAll(this.buffer);</span><br><span class="line">    //...清空buffer</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看完#flush可能会有个疑问,这里要进行判断是否ifFull才把buffer放入channel。那最后一批不满足ifFull条件的数据如何处理？</p><p>写入<br>taskReader.startRead(recordSender); &#x2F;&#x2F;读插件开始读<br>recordSender.terminate(); &#x2F;&#x2F;把缓存中剩余数据写如recordSender的channel中，并且写入TerminateRecord打上结束标记<br>至此读任务就结束了</p><p>接下来看写任务</p><p>以MySqlWriter插件为例，WriterRunner分别执行#init, #prepare, #start, #post， 实现在MySqlWriter中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static class Task extends Writer.Task &#123;</span><br><span class="line">    //TODO 改用连接池，确保每次获取的连接都是可用的（注意：连接可能需要每次都初始化其 session）</span><br><span class="line">    public void startWrite(RecordReceiver recordReceiver) &#123;</span><br><span class="line">        this.commonRdbmsWriterTask.startWrite(recordReceiver, this.writerSliceConfig,</span><br><span class="line">                super.getTaskPluginCollector());</span><br><span class="line">    &#125;</span><br><span class="line">     //...</span><br><span class="line">&#125;</span><br><span class="line">public void startWrite(RecordReceiver recordReceiver,</span><br><span class="line">                       Configuration writerSliceConfig,</span><br><span class="line">                       TaskPluginCollector taskPluginCollector) &#123;</span><br><span class="line">    Connection connection = DBUtil.getConnection(this.dataBaseType,</span><br><span class="line">            this.jdbcUrl, username, password);</span><br><span class="line">    DBUtil.dealWithSessionConfig(connection, writerSliceConfig,</span><br><span class="line">            this.dataBaseType, BASIC_MESSAGE);</span><br><span class="line">    startWriteWithConnection(recordReceiver, taskPluginCollector, connection);  //开始写</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;…清空缓存,关闭资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void startWriteWithConnection(RecordReceiver recordReceiver, TaskPluginCollector taskPluginCollector, Connection connection) &#123;</span><br><span class="line">    this.taskPluginCollector = taskPluginCollector;</span><br><span class="line">    // 用于写入数据的时候的类型根据目的表字段类型转换</span><br><span class="line">    this.resultSetMetaData = DBUtil.getColumnMetaData(connection,</span><br><span class="line">            this.table, StringUtils.join(this.columns, &quot;,&quot;));</span><br><span class="line">    // 写数据库的SQL语句</span><br><span class="line">    calcWriteRecordSql();</span><br><span class="line">    List&lt;Record&gt; writeBuffer = new ArrayList&lt;Record&gt;(this.batchSize);</span><br><span class="line">    int bufferBytes = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        Record record;</span><br><span class="line">        while ((record = recordReceiver.getFromReader()) != null) &#123;</span><br><span class="line">            //...读列与写列数量不一致，会抛异常,这里省略</span><br><span class="line">            //写缓存添加数据</span><br><span class="line">            writeBuffer.add(record);</span><br><span class="line">            bufferBytes += record.getMemorySize();</span><br><span class="line">            if (writeBuffer.size() &gt;= batchSize || bufferBytes &gt;= batchByteSize) &#123;</span><br><span class="line">                doBatchInsert(connection, writeBuffer); //开始批量写</span><br><span class="line">                writeBuffer.clear();</span><br><span class="line">                bufferBytes = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!writeBuffer.isEmpty()) &#123;</span><br><span class="line">            doBatchInsert(connection, writeBuffer);</span><br><span class="line">            writeBuffer.clear();</span><br><span class="line">            bufferBytes = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //...清空缓存,关闭资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写任务是批量操作,值得注意的是，当批量写操作出现错误时，程序会争取再执行一次写操作,对每条数据分别进行写操作</p><p>在#doOneInsert中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">protected void doBatchInsert(Connection connection, List&lt;Record&gt; buffer)</span><br><span class="line">        throws SQLException &#123;</span><br><span class="line">    PreparedStatement preparedStatement = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        connection.setAutoCommit(false);</span><br><span class="line">        preparedStatement = connection</span><br><span class="line">                .prepareStatement(this.writeRecordSql);</span><br><span class="line">        for (Record record : buffer) &#123;</span><br><span class="line">            preparedStatement = fillPreparedStatement(</span><br><span class="line">                    preparedStatement, record);</span><br><span class="line">            preparedStatement.addBatch();   //批量提交</span><br><span class="line">        &#125;</span><br><span class="line">        preparedStatement.executeBatch();   //批量执行</span><br><span class="line">        connection.commit();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        LOG.warn(&quot;回滚此次写入, 采用每次写入一行方式提交. 因为:&quot; + e.getMessage());</span><br><span class="line">        connection.rollback();</span><br><span class="line">        doOneInsert(connection, buffer);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw DataXException.asDataXException(</span><br><span class="line">                DBUtilErrorCode.WRITE_DATA_ERROR, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        DBUtil.closeDBResources(preparedStatement, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">protected void doOneInsert(Connection connection, List&lt;Record&gt; buffer) &#123;</span><br><span class="line">    PreparedStatement preparedStatement = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        connection.setAutoCommit(true);</span><br><span class="line">        preparedStatement = connection</span><br><span class="line">                .prepareStatement(this.writeRecordSql);</span><br><span class="line">        for (Record record : buffer) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                preparedStatement = fillPreparedStatement(</span><br><span class="line">                        preparedStatement, record);</span><br><span class="line">                preparedStatement.execute();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                LOG.debug(e.toString());</span><br><span class="line">                this.taskPluginCollector.collectDirtyRecord(record, e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 最后不要忘了关闭 preparedStatement</span><br><span class="line">                preparedStatement.clearParameters();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        //...抛异常</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //...关闭资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此写操作完毕</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://blog.csdn.net/ychang577/article/details/108226450"></a>总结</h2><p>整个应用，采用framework + read plugin + write plugin方式。对于核心配置文件core.json ，任务配置文件 job.json, 插件配置文件plugin.json 程序已经处理。并且结合Communication收集处理数据指标。我们只需要实现<br>Reader , Reader.Job , Reader.Task<br>Writer , Writer.Job , Writer.Task<br>根据项目的需求进行处理即可</p><p>本文转自 <a href="https://blog.csdn.net/ychang577/article/details/108226450">https://blog.csdn.net/ychang577/article/details/108226450</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 数据同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构网址</title>
      <link href="/2022/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BD%91%E5%9D%80/"/>
      <url>/2022/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BD%91%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h3 id="这是一个可以观察各种数据结构的网址"><a href="#这是一个可以观察各种数据结构的网址" class="headerlink" title="这是一个可以观察各种数据结构的网址"></a>这是一个可以观察各种数据结构的网址</h3><p><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea代码神器</title>
      <link href="/2022/03/16/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6(%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8)/"/>
      <url>/2022/03/16/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6(%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8)/</url>
      
        <content type="html"><![CDATA[<h2 id="Copilot"><a href="#Copilot" class="headerlink" title="Copilot"></a>Copilot</h2><blockquote><p>我愿称之为最强插件。</p></blockquote><p>首先是github copilot的官网地址 ：<a href="https://copilot.github.com/">https://copilot.github.com/</a></p><p>进去之后自己看吧，贼拉牛逼，预判了我。</p>]]></content>
      
      
      <categories>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2022/02/10/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2022/02/10/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>什么是代理？<br>代理：替别人干事。<br>代理的本质，就是”中介”，主要是要搞懂，这个中介在代替client，还是代替server</p><p>“替真正的client”，向server申请服务的是正向代理<br>正向代理是client的行为，目的是为了伪造出”client身份”</p><p>“替真正的server”，给client提供服务的是反向代理<br>反向代理是server方的行为，目标是伪造出”server身份”</p><p>正向代理：<br>A通过正向代理访问C，C并不知道A来过，他看到的ip是B，D，E，F，G。（伪造client身份）</p><p>反向代理：<br>有一个nginx服务器，nginx隐藏了sever，可以通过nginx做一些安全处理（ddos），nginx通过转发到后台的服务架构（是伪造出”server身份）。<br><img src="https://img-blog.csdnimg.cn/20200320121055610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc3NTk2Mw==,size_16,color_FFFFFF,t_70" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 代理 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短链接服务系统开发？</title>
      <link href="/2022/02/05/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
      <url>/2022/02/05/%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://javadoop.com/">回首页</a></p><h1 id="短链接服务系统开发"><a href="#短链接服务系统开发" class="headerlink" title="短链接服务系统开发"></a>短链接服务系统开发</h1><p><a href="https://javadoop.com/post/download?userName=hongjie&postName=url-shortener"></a></p><p>最近上了一个比较大的系统，基于消息推送的需要，花了点时间做了一个短链服务，实现思路其实很简单，这里简单介绍下实现细节，以及一些优化过程。</p><p><strong>目录：</strong></p><h2 id="功能简单描述"><a href="#功能简单描述" class="headerlink" title="功能简单描述"></a>功能简单描述</h2><p>功能很简单，实现将长网址缩短的功能，如：</p><p><img src="https://www.javadoop.com/blogimages/url-shortener/2.png" alt="2"></p><p>为什么要转短链？因为要控制每条短信的字数，对于公司来说，短信里面的字可都是钱呀。</p><p>为什么不用 t.cn，url.cn 等短链服务呢，它们生成的链接不是更短吗？是的，它们确实能实现更短的链接，可是要收钱的，而且这里面充满了商业数据呀。</p><p>短链服务总的来说，就做两件事：</p><ol><li>将长链接变为短链接，当然是越短越好</li><li>用户点击短链接的时候，实现自动跳转到原来的长链接</li></ol><h2 id="长链转短链"><a href="#长链转短链" class="headerlink" title="长链转短链"></a>长链转短链</h2><p>在转短链的时候，我们其实就是要将一个长长的链接映射为只有 4 到 7 个字母的字符串。这里我用了 MySQL 来存储，存放 short_key 和 original_url 的记录。</p><p>数据表很简单，最主要的列有以下几个：</p><ul><li>id: 逻辑主键，BIGINT</li><li>short_key: 短链中的字符串，域名部分一般不需要加进去，<strong>加入唯一索引 unique</strong></li><li>original_url: 原长网址，限 256 字符</li><li>另外，基于业务需要，可以加入业务标识 biz、过期时间 expire_time 等。</li></ul><p>在生成 key 的时候，一种最简单的实现方式是使用随机字符串，因为是随机码，所以可能会出现失败，通常就需要重试。随着记录越来越多，就越容易发生 key 重复的情况，这种方案显然不适合数据量大的场景。</p><p>我们不容易保证我们随机生成的 key 不重复，但是我们容易实现的就是 id 不重复，我们只要想个办法把 id 和 key 一一对应起来就可以了。</p><blockquote><p>单表场景，直接使用数据库自增 id 就能实现 id 唯一。多库多表，大家肯定都有一个全局发号器来生成唯一 id。</p><p>直接将 id 放在短链上可以吗？这样就不需要使用 key 了。功能上是没有问题的，不过问题就是还是会太长，然后由于 id 通常都是基本自增的，会引发很多问题，如被别人用一个简单的脚本给遍历出来。</p></blockquote><p>接下来，我们讨论怎么将 id 变为 key。</p><p>在短链中，我们通常可以使用的字符有 a-z、A-Z 和 0-9 共 62 个字符，所以，接下来，我们其实就是要将 10 进制的 id 转换为 <strong>62 进制</strong>的字符串。</p><p>转换方法很简单，大家都学过二进制和十进制之间的转换，这里贴下简单的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static final String BASE = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;</span><br><span class="line"></span><br><span class="line">public static String toBase62(long num) &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    int targetBase = BASE.length();</span><br><span class="line">    do &#123;</span><br><span class="line">        int i = (int) (num % targetBase);</span><br><span class="line">        sb.append(BASE.charAt(i));</span><br><span class="line">        num /= targetBase;</span><br><span class="line">    &#125; while (num &gt; 0);</span><br><span class="line"></span><br><span class="line">    return sb.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，十进制的 id 总是能生成一个唯一的 key，同样地，我们也可以通过 key 还原出 id。</p><p>在分库分表的时候，我们可以选择使用 id 来做分表键，也可以使用 key 来做分表键。如果是使用 id 的话，因为前端过来都是 key，所以需要先将 key 转换为 id。<strong>这里我们将使用 key 做分表键</strong>。</p><p>本文不会用到 62 进制转 10 进制，不过也贴出来让大家参考下吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static long toBase10(String input) &#123;</span><br><span class="line">    int srcBase = BASE.length();</span><br><span class="line">    long id = 0;</span><br><span class="line">    String r = new StringBuilder(input).reverse().toString();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; r.length(); i++) &#123;</span><br><span class="line">        int charIndex = BASE.indexOf(r.charAt(i));</span><br><span class="line">        id += charIndex * (long) Math.pow(srcBase, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="短链转长链"><a href="#短链转长链" class="headerlink" title="短链转长链"></a>短链转长链</h2><p>这一步非常简单，用户点击我们发给他们的短信中的短链，请求发送到我们的解析系统中，我们根据 key 到数据库中找原来的长链接，然后做个 302 跳转就可以了。</p><p>这里贴下 Spring MVC 的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;key&#125;&quot;)</span><br><span class="line">public String lookup(@PathVariable String key) &#123;</span><br><span class="line">    String originalUrl = shortenerService.lookup(key);</span><br><span class="line">    if (StringUtils.isBlank(originalUrl)) &#123;</span><br><span class="line">        // 如果没有找到长链接，跳转到我们的 m 站，这里其实定制一个 404 页面比较好</span><br><span class="line">        return &quot;redirect:https://m.zhongan.com&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;redirect:&quot; + originalUrl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="细节优化"><a href="#细节优化" class="headerlink" title="细节优化"></a>细节优化</h2><p><strong>1、加入随机码</strong></p><p>62 进制用更短的字符串能表示更大的数，使得我们可以使用更少的字符，同时不会让用户直接知道我们的 id 大小，但是稍微懂一点技术的，很容易就能将 62 进制转换为 10 进制，在行家眼里，和直接使用 id 没什么区别。</p><p>下面，我们就来优化这部分。</p><p>首先，上面的代码中，我们可以打乱这个 BASE 字符串，因为如果不打乱的话，那么 62 进制中就会有 XXb &#x3D; XXa + 1，如 10 进制的 999998 和 999999 转换为 62进制以后，分别为 4C90 和 4C91，大家是不是发现有点不妥。</p><p>接下来，我们可以考虑加随机字符串，如固定在开头或结尾加 2 位随机字符串，不过这样的话，就会使得我们的短链活生生地加了 2 位。</p><p>这里简单介绍下我的做法，使得生成的 key 不那么有规律，不那么容易被遍历出来。</p><p><img src="https://www.javadoop.com/blogimages/url-shortener/1.png" alt="1"></p><p>我们得到 id 以后，先在其二进制表示的固定位置插入随机位。如上图所示，从低位开始，每 5 位后面插入一个随机位，直到高位都是 0 就不再插入。</p><p>一定要对每个 id 进行一样的处理，一开始就确定下来固定的位置，如可以每 4 位插一个随机位，也可以在固定第 10 位、第 17 位、第 xx 位等，这样才能保证算法的安全性：两个不一样的数，在固定位置都插入随机位，结果一定不一样。</p><blockquote><p>由于我们会<strong>浪费</strong>掉一些位，所以最大可以表示的数会受影响，不过 64 位的 long 值是一个很大的数，是允许我们奢侈浪费一些的。</p><p>还有，前面提到高位为 0 就不再插入，那是为了不至于一开始就往高位插入了 1 导致我们刚开始的值就特别大，转换出来需要更长的字符串。</p></blockquote><p>这里我贴下我的插入随机位实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static long insertRandomBitPer5Bits(long val) &#123;</span><br><span class="line">    long result = val;</span><br><span class="line">    long high = val;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        if (high == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        int pos = 5 + 5 * i + i;</span><br><span class="line">        high = result &gt;&gt; pos;</span><br><span class="line">        result = ((high &lt;&lt; 1 | RandomUtils.nextInt(0, 2)) &lt;&lt; pos)</span><br><span class="line">                | (result &amp; (-1L &gt;&gt;&gt; (64 - pos)));</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，我们 10 进制的 999998 和 999999 就可能被转换为 16U06 和 XpJX。因为有随机位的存在，所以会有好几种可能。到这里，是不是觉得生成出来的字符串就好多了，相邻的两个数出来的两个字符串没什么规律了。</p><p>另外，建议 id 从一个中等模式的大小开始，如 100w，而不是从 1 开始，这个应该很好理解。</p><p><strong>2、加入缓存</strong></p><p>为了提高效率，我们应该使用适当的缓存，在系统中，我分别使用了一个读缓存和一个写缓存。</p><p>通常，我们使用读缓存 (key &#x3D;&gt; originalUrl) 可以获得很多好处，大家想想，如果我们往一批用户的手机发送同一个短链，可能大家都是在收到短信的几分钟内打开链接的，这个时候读缓存就能大大提高读性能。</p><p>至于写请求，接口来了一个 originalUrl，我们不能去数据库中查询是否已经有这条记录，所以两条一模一样的链接我们会生成两个不一样的短链接，当然，通常我们也是允许这种情况的。</p><blockquote><p>这里我指的是在分库分表的场景中，我们只能使用 key 来查找，已经不支持使用 original_url 进行数据库查找了。</p></blockquote><p>由于存在短时间内使用两条一模一样的长链接拿过来转短链的情况，所以我们可以维护一个写缓存 (originalUrl &#x3D;&gt; key)，这里使用 originalUrl 做键，如设置最大允许缓存最近 10000 条，过期时间 1 小时，根据自己实际情况来设置即可。这里写缓存能不能提高效率，取决于我们的业务。</p><p>由于生成短链的接口一般是提供给其他各个业务系统使用的，所以其实可以由调用方来决定是否要使用写缓存，这样能得到最好的效果。如果调用方知道自己接下来需要批量转换的长链是不会重复的，那么调用方可以设置不使用缓存，而对于一般性的场景，默认开启写缓存。</p><p><strong>3、数据库大小写</strong></p><p>这里再提最后一点，也是我自己踩的坑，有点低级失误了。一定要检查下自己的数据表是不是大小写敏感的。</p><p>在大小写不敏感的情况下，3rtX 和 3Rtx 被认为是相同的。</p><p>解决办法如下，设置列为 utf8_bin：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `xxx` MODIFY `short_key` CHAR(10) CHARACTER SET utf8 COLLATE utf8_bin;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>这个系统非常简单，性能瓶颈其实都集中在数据库中，前面我们也说了可以通过缓存来适当提高性能。</p><p>这里，我们不考虑缓存，来看下应该怎么设计数据库和表。</p><p>首先，我们应该预估一个适当的量，如按照自己的业务规模，预估接下来 2 年或更长时间，大概会增长到什么量级的数据。</p><p>如预估未来可能需要存放 50-100 亿条记录，然后我们大概按照单表 1000w 数据来设计，那么就需要 500-1000 张表，那么我们可以定 512 张表，512 张表我们可以考虑放 2 个或 4 个库。</p><p>我们使用 key 来做分表键，同时在 key 上加唯一索引，对于单表 1000w 这种级别，查询性能一般都差不了。</p><p>我没有在生产环境做过压测，测试环境中使用单库 2 张表，在不使用缓存的情况下，写操作可以比较轻松地达到 3000 TPS，基本上也就满足我们的需求了。本来测试环境各种硬件资源就和生产环境没法比，更何况我们生产环境会设置多库多表来分散压力。</p><p>（全文完）</p><p>本文转自 <a href="https://javadoop.com/post/url-shortener">https://javadoop.com/post/url-shortener</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-binlog</title>
      <link href="/2022/01/10/mysql-binlog/"/>
      <url>/2022/01/10/mysql-binlog/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/8e7e288c41b1">MySQL如何开启binlog？binlog三种模式的分析</a></p><blockquote><p>前提，创建表t，并插入数据，语句如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `a` int(11) DEFAULT NULL,</span><br><span class="line">  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `t_modified`(`t_modified`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(1,1,&#x27;2018-11-13&#x27;);</span><br><span class="line">insert into t values(2,2,&#x27;2018-11-12&#x27;);</span><br><span class="line">insert into t values(3,3,&#x27;2018-11-11&#x27;);</span><br><span class="line">insert into t values(4,4,&#x27;2018-11-10&#x27;);</span><br><span class="line">insert into t values(5,5,&#x27;2018-11-09&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="判断MySQL是否已经开启binlog"><a href="#判断MySQL是否已经开启binlog" class="headerlink" title="判断MySQL是否已经开启binlog?"></a>判断MySQL是否已经开启binlog?</h4><p>登录mysql，执行：SHOW VARIABLES LIKE ‘log_bin’;</p><ul><li>OFF：关闭</li><li>ON：开启</li></ul><h4 id="如何开启binlog日志？"><a href="#如何开启binlog日志？" class="headerlink" title="如何开启binlog日志？"></a>如何开启binlog日志？</h4><p>找到my.cnf ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@basedir;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果还是找不到文件的位置，可以执行下面命令，可以得到mysql的配置文件的默认加载顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql --help | grep &#x27;Default options&#x27; -A 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Default options are read from the following files in the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到mysql优先加载<code>/etc/my.cnf</code>中的配置。</p><p>所以需要在<code>/etc/my.cnf</code>中mysqld节添加开启binlog的配置，如下有两种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#第一种方式:</span><br><span class="line">#开启binlog日志</span><br><span class="line">log_bin=ON</span><br><span class="line">#binlog日志的基本文件名</span><br><span class="line">log_bin_basename=/var/lib/mysql/mysql-bin</span><br><span class="line">#binlog文件的索引文件，管理所有binlog文件</span><br><span class="line">log_bin_index=/var/lib/mysql/mysql-bin.index</span><br><span class="line">#配置serverid</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line">#第二种方式:</span><br><span class="line">#此一行等同于上面log_bin三行</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin</span><br><span class="line">#配置serverid</span><br><span class="line">server-id=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改完配置后，重启mysql。执行<code>SHOW VARIABLES LIKE &#39;log_bin&#39;;</code> Value 值为 ON即可。</p><h3 id="binlog的配置简介"><a href="#binlog的配置简介" class="headerlink" title="binlog的配置简介"></a>binlog的配置简介</h3><p>MySQL配置文件my.cnf文件中的mysqld节的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#设置日志三种格式：STATEMENT、ROW、MIXED 。</span><br><span class="line">binlog_format = mixed</span><br><span class="line">#设置日志路径，注意路经需要mysql用户有权限写</span><br><span class="line">log-bin = /data/mysql/logs/mysql-bin.log</span><br><span class="line">#设置binlog清理时间</span><br><span class="line">expire_logs_days = 7</span><br><span class="line">#binlog每个日志文件大小</span><br><span class="line">max_binlog_size = 100m</span><br><span class="line">#binlog缓存大小</span><br><span class="line">binlog_cache_size = 4m</span><br><span class="line">#最大binlog缓存大小</span><br><span class="line">max_binlog_cache_size = 512m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重启MySQL生效，如果不方便重启服务，也可以直接修改对应的变量即可。</p><h3 id="binlog的三种模式比较"><a href="#binlog的三种模式比较" class="headerlink" title="binlog的三种模式比较"></a>binlog的三种模式比较</h3><p>binlog的格式也有三种：<code>STATEMENT</code>、<code>ROW</code>、<code>MIXED</code>。</p><ul><li><code>STATMENT</code>模式：基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。<br>优点：不需要记录每一条SQL语句与每行的数据变化，这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。<br>缺点：在某些情况下会导致master-slave中的数据不一致(比如：<code>delete from t where a&gt;=4 and t_modified&lt;=&#39;2018-11-10&#39; limit 1;</code>在主库执行这个语句的时候，如果使用的是a索引，会删除<code>(4,4,&#39;2018-11-10&#39;)</code>这条记录，如果使用的是t_modified的索引则会删除<code>insert into t values(5,5,&#39;2018-11-09&#39;);</code>所以在执行这条sql语句的时候提示：<br><code>Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. The statement is unsafe because it uses a LIMIT clause. This is unsafe because the set of rows included cannot be predicted.</code><br>由于 statement 格式下，记录到 binlog 里的是语句原文，因此可能会出现这样一种情况：在主库执行这条 SQL 语句的时候，用的是索引 a；而在备库执行这条 SQL 语句的时候，却使用了索引 t_modified。因此，MySQL 认为这样写是有风险的。<br><code>sleep()</code>函数， <code>last_insert_id()</code>，以及<code>user-defined functions(udf)</code>等也会出现问题)；</li><li><code>ROW</code>基于行的复制(row-based replication, RBR)格式：不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了。<br>优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。<br>缺点：会产生大量的日志，尤其是alter table的时候会让日志暴涨。</li><li><code>MIXED</code>混合模式复制(mixed-based replication, MBR)：以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。</li></ul><h3 id="列举几个关于binlog常用的命令"><a href="#列举几个关于binlog常用的命令" class="headerlink" title="列举几个关于binlog常用的命令"></a>列举几个关于binlog常用的命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#查看日志开启状态 </span><br><span class="line">show variables like &#x27;log_%&#x27;;</span><br><span class="line">#查看所有binlog日志列表</span><br><span class="line">show master logs;</span><br><span class="line">#查看最新一个binlog日志的编号名称，及其最后一个操作事件结束点 </span><br><span class="line">show master status;</span><br><span class="line">#刷新log日志，立刻产生一个新编号的binlog日志文件，跟重启一个效果 </span><br><span class="line">flush logs;</span><br><span class="line">#清空所有binlog日志 </span><br><span class="line">reset master;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="binlog中到底记录了什么内容？如何分析binlog日志？"><a href="#binlog中到底记录了什么内容？如何分析binlog日志？" class="headerlink" title="binlog中到底记录了什么内容？如何分析binlog日志？"></a>binlog中到底记录了什么内容？如何分析binlog日志？</h3><p>开启binlog日志之后，我们在登录mysql，在控制台执行一条sql语句：<code>delete from t where a&gt;=4 and t_modified&lt;=&#39;2018-11-10&#39; limit 1;</code><br>查看当前的binlog日志文件<code>show master status;</code>;<br>笔者得到的是<code>mysql-bin.000005</code>，根据binlog日志文件的配置，我们可以去存储binlog的日志文件下面看看<code>cd /var/lib/mysql/</code>,可以看到文件夹下面有<code>mysql-bin.000005</code>文件。<br>执行：cat mysql-bin.000005，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@mysql]# cat mysql-bin.000005</span><br><span class="line">n</span><br><span class="line"> MZ]w&#123;5.7.27-log</span><br><span class="line">_               MZ]8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**4Z]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，里面的内容根本没法阅读。</p><p>因为binlog日志文件：mysql-bin.000005是二进制文件，没法用vi等打开，这时就需要mysql的自带的mysqlbinlog工具进行解码，执行：<code>mysqlbinlog mysql-bin.000005</code>可以将二进制文件转为可阅读的sql语句。</p><h3 id="分析对比binlog的ROW模式和STATEMENT模式下的日志："><a href="#分析对比binlog的ROW模式和STATEMENT模式下的日志：" class="headerlink" title="分析对比binlog的ROW模式和STATEMENT模式下的日志："></a>分析对比binlog的<code>ROW</code>模式和<code>STATEMENT</code>模式下的日志：</h3><p><code>ROW</code>模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;</span><br><span class="line">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;</span><br><span class="line">DELIMITER /*!*/;</span><br><span class="line"># at 4</span><br><span class="line">#190819 15:35:46 server id 1  end_log_pos 123 CRC32 0x2bfa58f0  Start: binlog v 4, server v 5.7.27-log created 190819 15:35:46 at startup</span><br><span class="line"># Warning: this binlog is either in use or was not closed properly.</span><br><span class="line">ROLLBACK/*!*/;</span><br><span class="line">BINLOG &#x27;</span><br><span class="line">UlFaXQ8BAAAAdwAAAHsAAAABAAQANS43LjI3LWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAABSUVpdEzgNAAgAEgAEBAQEEgAAXwAEGggAAAAICAgCAAAACgoKKioAEjQA</span><br><span class="line">AfBY+is=</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"># at 123</span><br><span class="line">#190819 15:35:46 server id 1  end_log_pos 154 CRC32 0xe4e91c8f  Previous-GTIDs</span><br><span class="line"># [empty]</span><br><span class="line"># at 154</span><br><span class="line">#190819 15:36:19 server id 1  end_log_pos 219 CRC32 0xcc3dc023  Anonymous_GTID  last_committed=0        sequence_number=1       rbr_only=yes</span><br><span class="line">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 219</span><br><span class="line">#190819 15:36:19 server id 1  end_log_pos 305 CRC32 0xd39f98cf  Query   thread_id=2     exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1566200179/*!*/;</span><br><span class="line">SET @@session.pseudo_thread_id=2/*!*/;</span><br><span class="line">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class="line">SET @@session.sql_mode=1436549152/*!*/;</span><br><span class="line">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class="line">/*!\C utf8 *//*!*/;</span><br><span class="line">SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=8/*!*/;</span><br><span class="line">SET @@session.time_zone=&#x27;SYSTEM&#x27;/*!*/;</span><br><span class="line">SET @@session.lc_time_names=0/*!*/;</span><br><span class="line">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 305</span><br><span class="line">#190819 15:36:19 server id 1  end_log_pos 358 CRC32 0x56a1e39d  Table_map: `mysql_test`.`t` mapped to number 108</span><br><span class="line"># at 358</span><br><span class="line">#190819 15:36:19 server id 1  end_log_pos 406 CRC32 0xc91237b0  Delete_rows: table id 108 flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG &#x27;</span><br><span class="line">c1FaXRMBAAAANQAAAGYBAAAAAGwAAAAAAAEACm15c3FsX3Rlc3QAAXQAAwMDEQEAAp3joVY=</span><br><span class="line">c1FaXSABAAAAMAAAAJYBAAAAAGwAAAAAAAEAAgAD//gEAAAABAAAAFvlrwCwNxLJ</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line">### DELETE FROM `mysql_test`.`t`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=4 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=4 /* INT meta=0 nullable=1 is_null=0 */</span><br><span class="line">###   @3=1541779200 /* TIMESTAMP(0) meta=0 nullable=0 is_null=0 */</span><br><span class="line"># at 406</span><br><span class="line">#190819 15:36:19 server id 1  end_log_pos 437 CRC32 0x7898ebf6  Xid = 13</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;AUTOMATIC&#x27; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>STATEMENT</code>模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;</span><br><span class="line">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;</span><br><span class="line">DELIMITER /*!*/;</span><br><span class="line"># at 4</span><br><span class="line">#190819 16:19:48 server id 1  end_log_pos 123 CRC32 0xec3e6426  Start: binlog v 4, server v 5.7.27-log created 190819 16:19:48 at startup</span><br><span class="line"># Warning: this binlog is either in use or was not closed properly.</span><br><span class="line">ROLLBACK/*!*/;</span><br><span class="line">BINLOG &#x27;</span><br><span class="line">pFtaXQ8BAAAAdwAAAHsAAAABAAQANS43LjI3LWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAACkW1pdEzgNAAgAEgAEBAQEEgAAXwAEGggAAAAICAgCAAAACgoKKioAEjQA</span><br><span class="line">ASZkPuw=</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"># at 123</span><br><span class="line">#190819 16:19:48 server id 1  end_log_pos 154 CRC32 0xc6db211a  Previous-GTIDs</span><br><span class="line"># [empty]</span><br><span class="line"># at 154</span><br><span class="line">#190819 16:20:01 server id 1  end_log_pos 219 CRC32 0x1960cba5  Anonymous_GTID  last_committed=0        sequence_number=1       rbr_only=no</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 219</span><br><span class="line">#190819 16:20:01 server id 1  end_log_pos 318 CRC32 0x11eecb38  Query   thread_id=2     exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1566202801/*!*/;</span><br><span class="line">SET @@session.pseudo_thread_id=2/*!*/;</span><br><span class="line">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class="line">SET @@session.sql_mode=1436549152/*!*/;</span><br><span class="line">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class="line">/*!\C utf8 *//*!*/;</span><br><span class="line">SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=8/*!*/;</span><br><span class="line">SET @@session.time_zone=&#x27;SYSTEM&#x27;/*!*/;</span><br><span class="line">SET @@session.lc_time_names=0/*!*/;</span><br><span class="line">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 318</span><br><span class="line">#190819 16:20:01 server id 1  end_log_pos 473 CRC32 0x390d1f96  Query   thread_id=2     exec_time=0     error_code=0</span><br><span class="line">use `mysql_test`/*!*/;</span><br><span class="line">SET TIMESTAMP=1566202801/*!*/;</span><br><span class="line">delete from t where a&gt;=4 and t_modified&lt;=&#x27;2018-11-10&#x27; limit 1</span><br><span class="line">/*!*/;</span><br><span class="line"># at 473</span><br><span class="line">#190819 16:20:01 server id 1  end_log_pos 504 CRC32 0x2f35c773  Xid = 13</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;AUTOMATIC&#x27; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到<code>ROW</code>模式下，binlog日志中的begin和commit之间并没有sql语句。<br>在<code>STATEMENT</code>模式下，binlog日志中的begin和commit之间是一条sql语句。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程简单聊聊？</title>
      <link href="/2021/12/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/12/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简单聊一下多线程"><a href="#简单聊一下多线程" class="headerlink" title="简单聊一下多线程"></a>简单聊一下多线程</h1><p> 线程 &amp;&amp; 进程？</p><ul><li><p>进程：系统进行资源分配和调度的独立单位，每个进程都有自己内存空间和系统资源，多处理机环境下的进程调度，分派，切换时要耗费较大时间和空间开销。</p></li><li><p>线程：线程就是进程调度的基本功能（单位）。</p></li></ul><p> 为什么使用多线程？</p><ul><li>提高系统资源利用率（Cpu），现在系统基本都是多核，只用单线程就只用到了一个核心。</li></ul><p>像我们日常工作中，web系统用的是Tomcat，Tomcat处理每一个请求都会从线程池里边拿线程处理。</p><p>还有连接数据库的连接池 Druid&#x2F;C3P0&#x2F;DBCP 都用了多线程。</p><p>然后我在工作中其实有很多场景可以用多线程：<br>有一个自定义报表的场景：用户必须进行全表查询，还有导表等等，可以分片，统一返回。<br>还有像我们的开票功能，在生成订单的时候开一个线程同步去开票。</p><p>如何保证线程安全？</p><ul><li>1、保证操作原子性，cas 可以用automic类。</li><li>2、操作可见行，volatile</li><li>3、涉及线程控制，一次多少个线程，CountDownLatch&#x2F;Semaphore</li><li>4、集合考虑 java.util.concurrent下面的包</li><li>5、synchorized无法满足，考虑lock下面的包 CopyOnWriteArrayList CopyOnWriteArraySet</li></ul><p>死锁，如何避免？</p><ul><li>加锁顺序，用hash值的大小来固定</li><li>缩小加锁范围，共享变量才加锁</li><li>使用可释放的定时锁</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证消息的可靠性传输？（如何处理消息丢失的问题）</title>
      <link href="/2021/12/02/rabbitmq%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF/"/>
      <url>/2021/12/02/rabbitmq%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>这个是肯定的，用 MQ 有个基本原则，就是数据不能多一条，也不能少一条，不能多，就是重复消费和幂等性问题。不能少，就是说这数据别搞丢了。那这个问题你必须得考虑一下。</p><p>如果说你这个是用 MQ 来传递非常核心的消息，比如说计费、扣费的一些消息，那必须确保这个 MQ 传递过程中绝对不会把计费消息给弄丢。</p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="生产者弄丢了数据"><a href="#生产者弄丢了数据" class="headerlink" title="生产者弄丢了数据"></a>生产者弄丢了数据</h2><p>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</p><p>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务 <code>channel.txSelect</code> ，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 <code>channel.txRollback</code> ，然后重试发送消息；如果收到了消息，那么可以提交事务 <code>channel.txCommit</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 开启事务</span><br><span class="line">channel.txSelect</span><br><span class="line">try &#123;</span><br><span class="line">    // 这里发送消息</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    channel.txRollback</span><br><span class="line"></span><br><span class="line">    // 这里再次重发这条消息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 提交事务</span><br><span class="line">channel.txCommit</span><br></pre></td></tr></table></figure><p>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上<strong>吞吐量会下来，因为太耗性能</strong>。</p><p>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 <code>confirm</code> 模式，在生产者那里设置开启 confirm 模式之后，你每次写的消息都会分配一个唯一的 <code>id</code>，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 <code>ack</code> 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 <code>nack</code> 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p><p>事务机制和 <code>confirm</code> 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 <code>confirm</code> 机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p><p>所以一般在生产者这块避免数据丢失，都是用 <code>confirm</code> 机制的。</p><h2 id="RabbitMQ-弄丢了数据"><a href="#RabbitMQ-弄丢了数据" class="headerlink" title="RabbitMQ 弄丢了数据"></a>RabbitMQ 弄丢了数据</h2><p>就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。</p><p>设置持久化有两个步骤：</p><ul><li>创建 queue 的时候将其设置为持久化。这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li><li>第二个是发送消息的时候将消息的 deliveryMode 设置为 2。就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li></ul><p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p><p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p><p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code> ，你也是可以自己重发的。</p><h2 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h2><p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p><p>这个时候得用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack ，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="消费端弄丢了数据-1"><a href="#消费端弄丢了数据-1" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h2><p>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p><p>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要关闭自动提交 offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p><p>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p><h2 id="Kafka-弄丢了数据"><a href="#Kafka-弄丢了数据" class="headerlink" title="Kafka 弄丢了数据"></a>Kafka 弄丢了数据</h2><p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p><p>生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</p><p>所以此时一般是要求起码设置如下 4 个参数：</p><p>给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。<br>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。<br>在 producer 端设置 acks&#x3D;all ：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。<br>在 producer 端设置 retries&#x3D;MAX （很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。<br>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><h2 id="生产者会不会弄丢数据？"><a href="#生产者会不会弄丢数据？" class="headerlink" title="生产者会不会弄丢数据？"></a>生产者会不会弄丢数据？</h2><p>如果按照上述的思路设置了 acks&#x3D;all ，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QPS、TPS、并发数</title>
      <link href="/2021/09/30/QPS%E3%80%81TPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0/"/>
      <url>/2021/09/30/QPS%E3%80%81TPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-平均响应时长（每个用户请求）"><a href="#1-平均响应时长（每个用户请求）" class="headerlink" title="1. 平均响应时长（每个用户请求）"></a>1. 平均响应时长（每个用户请求）</h1><ul><li>公式：Time token for tests&#x2F;（Complete requests&#x2F;Concurrency Level）</li><li>用户平均请求等待时间 &#x3D; 总耗时 &#x2F;（总请求数 &#x2F; 并发数）<blockquote><p> 结合1、2 &#x3D;&#x3D;&gt; 用户平均请求等待时间 &#x3D; 服务器平均请求等待时间 * 并发数</p></blockquote></li></ul><h1 id="2-服务器平均请求等待时间（每个请求）"><a href="#2-服务器平均请求等待时间（每个请求）" class="headerlink" title="2. 服务器平均请求等待时间（每个请求）"></a>2. 服务器平均请求等待时间（每个请求）</h1><ul><li>公式：总耗时 &#x2F; 总请求数</li></ul><h1 id="3-QPS（每秒能够相应的查询次数）"><a href="#3-QPS（每秒能够相应的查询次数）" class="headerlink" title="3. QPS（每秒能够相应的查询次数）"></a>3. QPS（每秒能够相应的查询次数）</h1><ul><li>公式：QPS &#x3D; 并发数 &#x2F; 平均响应时长<blockquote><p>结合1、3 &#x3D;&#x3D;&gt; QPS &#x3D; 总请求数 &#x2F; 总耗时</p></blockquote></li></ul><h1 id="4-TPS"><a href="#4-TPS" class="headerlink" title="4.TPS"></a>4.TPS</h1><ul><li>每秒钟处理完的事务次数，一般TPS是对整个系统来讲的。一个应用系统1s能完成多少事务处理</li></ul><h1 id="5-并发数（系统同时处理的request-或-事务数）"><a href="#5-并发数（系统同时处理的request-或-事务数）" class="headerlink" title="5. 并发数（系统同时处理的request 或 事务数）"></a>5. 并发数（系统同时处理的request 或 事务数）</h1><ul><li>公式：并发数 &#x3D; QPS * 平均响应时长<blockquote><p>指系统可以同时承载的正常使用系统功能的用户的数量</p></blockquote></li></ul><h1 id="6-吞吐量"><a href="#6-吞吐量" class="headerlink" title="6. 吞吐量"></a>6. 吞吐量</h1><ul><li>F &#x3D; VU * R &#x2F; T</li><li>其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间<blockquote><p>一个系统吞吐量通常由QPS(TPS)、并发数两个因素决定，在应用场景访问压力下，只要某一项达到系统最高值或超标，系统超负荷工作、上下文切换、内存等其他消耗导致系统性能下降，系统的吞吐量会下降反而会下降。</p></blockquote></li></ul><h1 id="7-AbTest例子"><a href="#7-AbTest例子" class="headerlink" title="7.AbTest例子"></a>7.AbTest例子</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">[root@s1 ~]# ab -c 500 -n 10000 -p POST.json -T application/json  http://10.152.49.33:8080/scrm/searchCustomer</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking 10.152.49.33 (be patient)</span><br><span class="line">Completed 1000 requests</span><br><span class="line">Completed 2000 requests</span><br><span class="line">Completed 3000 requests</span><br><span class="line">Completed 4000 requests</span><br><span class="line">Completed 5000 requests</span><br><span class="line">Completed 6000 requests</span><br><span class="line">Completed 7000 requests</span><br><span class="line">Completed 8000 requests</span><br><span class="line">Completed 9000 requests</span><br><span class="line">Completed 10000 requests</span><br><span class="line">Finished 10000 requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:</span><br><span class="line">Server Hostname:        10.152.49.33</span><br><span class="line">Server Port:            8080</span><br><span class="line"></span><br><span class="line">Document Path:          /scrm/searchCustomer</span><br><span class="line">Document Length:        5257 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      500 // 并发数</span><br><span class="line">Time taken for tests:   151.283 seconds // 总耗时</span><br><span class="line">Complete requests:      10000 // 总请求数</span><br><span class="line">Failed requests:        0</span><br><span class="line">Write errors:           0</span><br><span class="line">Total transferred:      53620000 bytes</span><br><span class="line">Total body sent:        8030000</span><br><span class="line">HTML transferred:       52570000 bytes</span><br><span class="line">Requests per second:    66.10 [#/sec] (mean)  // QPS</span><br><span class="line">Time per request:       7564.153 [ms] (mean)  // 用户平均请求等待时间</span><br><span class="line">Time per request:       15.128 [ms] (mean, across all concurrent requests) // 服务器平均请求等待时间</span><br><span class="line">Transfer rate:          346.13 [Kbytes/sec] received</span><br><span class="line">                        51.84 kb/s sent</span><br><span class="line">                        397.96 kb/s total</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0   13 112.2      0    1003</span><br><span class="line">Processing:   168 7447 5399.8   5613   34826</span><br><span class="line">Waiting:      168 7447 5399.8   5613   34826</span><br><span class="line">Total:        183 7461 5398.2   5618   34826</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%   5618</span><br><span class="line">  66%   6345</span><br><span class="line">  75%   7057</span><br><span class="line">  80%   7383</span><br><span class="line">  90%  13845</span><br><span class="line">  95%  23104</span><br><span class="line">  98%  25971</span><br><span class="line">  99%  27224</span><br><span class="line"> 100%  34826 (longest request)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2021/09/10/HashMap/"/>
      <url>/2021/09/10/HashMap/</url>
      
        <content type="html"><![CDATA[<p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑<br>树 组成。<br>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的<br>具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决<br>于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，<br>会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><h1 id="hashMap-底层分析"><a href="#hashMap-底层分析" class="headerlink" title="hashMap 底层分析"></a>hashMap 底层分析</h1><blockquote><p>1.7版本 HashMap 底层是由数组和链表组成。数组里面存放的是Entry&lt;K,V&gt;的引用。初始容量为16，负载因子是0.75。扩容发生在当hashMap中元素个数大于arr.length * 负载因子 开始进行扩容。</p></blockquote><ul><li>put具体实现：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String.Object&gt; map = new HashMap();</span><br><span class="line">map.put(key,value);</span><br></pre></td></tr></table></figure>对key.hashCode() 进行 &amp; 操作。<br>为什么不是 % 呢？ 因为位运算符是运行最快的。<br>我们要的无非就是满足两点。<br>1、保证随机性散列在数组上。<br>2、不能越界<br>&amp;操作是如何保证的呢？<br>首先key.hashCode() 会得到一个数字转换为二进制h<br>h &amp; (length - 1) &#x2F;&#x2F;有为1则为1<br>因为length都要保证是2的幂次方所以 lengh - 1 的 后四位都为1<br>0000 abcd<br>0000 1111<br>0000 abcd  其实就是hashCode 的后四位 ，保证了随机性。<br>为了更乱hashMap还进行了一些位运算，讲前面的数字参与进来。<br>扩容保证2的幂次函数：<br>Integer.highestOneBit( (number - 1) &lt;&lt; 1 )<br>highestOneBit 方法 是获取到小于等于参数的最大2的幂。<br>实现自己去看。<br>想要拿到比他小的最大2的幂<br>只需要把第一个1后面的所有数字都变成0就可以了<br>对number进行翻倍,-1是为了刚好卡在2的幂方的数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO</title>
      <link href="/2021/09/10/NIO/"/>
      <url>/2021/09/10/NIO/</url>
      
        <content type="html"><![CDATA[<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><blockquote><p>NIO(no-blocking io 或者 new io)<br>NIO根本目的就是为了提高速度。。</p></blockquote><p>传统io是一个一个字节处理数据，NIO是以块（缓冲区）的形式处理数据。<br>最主要的是NIO可以实现非阻塞，而传统IO只能是阻塞。<br>IO的场景：文件IO和网络IO<br>java在NIO有三个核心部分组成</p><ul><li>Buffer 缓冲区</li><li>Channel 管道</li><li>Selector 选择器</li></ul><p>可以简单理解为 Buffer是存储数据的地方，Channel是运输数据的载体，而Selector用于检查多个Channel的状态变更情况<br>Demo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">public class NoBlockServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        // 1.获取通道</span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        // 2.切换成非阻塞模式</span><br><span class="line">        server.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">        // 3. 绑定连接</span><br><span class="line">        server.bind(new InetSocketAddress(6666));</span><br><span class="line"></span><br><span class="line">        // 4. 获取选择器</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        // 4.1将通道注册到选择器上，指定接收“监听通道”事件</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        // 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪</span><br><span class="line">        while (selector.select() &gt; 0) &#123;</span><br><span class="line">            // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            // 7. 获取已“就绪”的事件，(不同的事件做不同的事)</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line"></span><br><span class="line">                // 接收事件就绪</span><br><span class="line">                if (selectionKey.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    // 8. 获取客户端的链接</span><br><span class="line">                    SocketChannel client = server.accept();</span><br><span class="line"></span><br><span class="line">                    // 8.1 切换成非阻塞状态</span><br><span class="line">                    client.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">                    // 8.2 注册到选择器上--&gt;拿到客户端的连接为了读取通道的数据(监听读就绪事件)</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125; else if (selectionKey.isReadable()) &#123; // 读事件就绪</span><br><span class="line"></span><br><span class="line">                    // 9. 获取当前选择器读就绪状态的通道</span><br><span class="line">                    SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">                    // 9.1读取数据</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">                    // 9.2得到文件通道，将客户端传递过来的图片写到本地项目下(写模式、没有则创建)</span><br><span class="line">                    FileChannel outChannel = FileChannel.open(Paths.get(&quot;2.png&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">                    while (client.read(buffer) &gt; 0) &#123;</span><br><span class="line">                        // 在读之前都要切换成读模式</span><br><span class="line">                        buffer.flip();</span><br><span class="line"></span><br><span class="line">                        outChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">                        // 读完切换成写模式，能让管道继续读取文件的数据</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 10. 取消选择键(已经处理过的事件，就应该取消掉了)</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class NoBlockClient &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        // 1. 获取通道</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));</span><br><span class="line"></span><br><span class="line">        // 1.1切换成非阻塞模式</span><br><span class="line">        socketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">        // 1.2获取选择器</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        // 1.3将通道注册到选择器中，获取服务端返回的数据</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        // 2. 发送一张图片给服务端吧</span><br><span class="line">        FileChannel fileChannel = FileChannel.open(Paths.get(&quot;X:\Users\ozc\Desktop\面试造火箭\1.png&quot;), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">        // 3.要使用NIO，有了Channel，就必然要有Buffer，Buffer是与数据打交道的呢</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">        // 4.读取本地文件(图片)，发送到服务器</span><br><span class="line">        while (fileChannel.read(buffer) != -1) &#123;</span><br><span class="line"></span><br><span class="line">            // 在读之前都要切换成读模式</span><br><span class="line">            buffer.flip();</span><br><span class="line"></span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">            // 读完切换成写模式，能让管道继续读取文件的数据</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪</span><br><span class="line">        while (selector.select() &gt; 0) &#123;</span><br><span class="line">            // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            // 7. 获取已“就绪”的事件，(不同的事件做不同的事)</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line"></span><br><span class="line">                // 8. 读事件就绪</span><br><span class="line">                if (selectionKey.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    // 8.1得到对应的通道</span><br><span class="line">                    SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">                    ByteBuffer responseBuffer = ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">                    // 9. 知道服务端要返回响应的数据给客户端，客户端在这里接收</span><br><span class="line">                    int readBytes = channel.read(responseBuffer);</span><br><span class="line"></span><br><span class="line">                    if (readBytes &gt; 0) &#123;</span><br><span class="line">                        // 切换读模式</span><br><span class="line">                        responseBuffer.flip();</span><br><span class="line">                        System.out.println(new String(responseBuffer.array(), 0, readBytes));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 10. 取消选择键(已经处理过的事件，就应该取消掉了)</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8之optionAl用法</title>
      <link href="/2021/08/16/optional/"/>
      <url>/2021/08/16/optional/</url>
      
        <content type="html"><![CDATA[<h1 id="实战使用"><a href="#实战使用" class="headerlink" title="实战使用"></a>实战使用</h1><blockquote><p>以前写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public String getCity(User user)  throws Exception&#123;</span><br><span class="line">        if(user!=null)&#123;</span><br><span class="line">            if(user.getAddress()!=null)&#123;</span><br><span class="line">                Address address = user.getAddress();</span><br><span class="line">                if(address.getCity()!=null)&#123;</span><br><span class="line">                    return address.getCity();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new Excpetion(&quot;取值错误&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">&gt; JAVA8写法</span><br></pre></td></tr></table></figure><p>public String getCity(User user) throws Exception{<br>    return Optional.ofNullable(user)<br>                   .map(u-&gt; u.getAddress())<br>                   .map(a-&gt;a.getCity())<br>                   .orElseThrow(()-&gt;new Exception(“取指错误”));<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 例二</span><br><span class="line">&gt; 以前写法</span><br></pre></td></tr></table></figure><p>if(user!&#x3D;null){<br>    dosomething(user);<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; JAVA8写法</span><br></pre></td></tr></table></figure><p> Optional.ofNullable(user)<br>    .ifPresent(u-&gt;{<br>        dosomething(u);<br>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 例三</span><br><span class="line"></span><br><span class="line">&gt; 以前写法</span><br></pre></td></tr></table></figure><p>public User getUser(User user) throws Exception{<br>    if(user!&#x3D;null){<br>        String name &#x3D; user.getName();<br>        if(“zhangsan”.equals(name)){<br>            return user;<br>        }<br>    }else{<br>        user &#x3D; new User();<br>        user.setName(“zhangsan”);<br>        return user;<br>    }<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; java8写法</span><br></pre></td></tr></table></figure><p>public User getUser(User user) {<br>    return Optional.ofNullable(user)<br>                   .filter(u-&gt;”zhangsan”.equals(u.getName()))<br>                   .orElseGet(()-&gt; {<br>                        User user1 &#x3D; new User();<br>                        user1.setName(“zhangsan”);<br>                        return user1;<br>                   });<br>}</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>explain详解</title>
      <link href="/2021/07/16/explain%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/07/16/explain%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-Explain详解"><a href="#MySQL-Explain详解" class="headerlink" title="MySQL Explain详解"></a>MySQL Explain详解</h2><p>[TOC]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询叫张三的人</span><br><span class="line">explain select * from emo where name = &#x27;张三&#x27;</span><br></pre></td></tr></table></figure><p><img src="/'./img/img.png'" alt="image.png"></p><h3 id="expain出来的信息有10列，分别是id、select-type、table、type、possible-keys、key、key-len、ref、rows、Extra"><a href="#expain出来的信息有10列，分别是id、select-type、table、type、possible-keys、key、key-len、ref、rows、Extra" class="headerlink" title="expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra"></a>expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</h3><p>概要描述：</p><ul><li><p>id:  选择标识符</p></li><li><p>select_type: 表示查询的类型。</p></li><li><p>table: 输出结果集的表</p></li><li><p>partitions: 匹配的分区</p></li><li><p>type: 表示表的连接类型</p></li><li><p>possible_keys: 表示查询时，可能使用的索引</p></li><li><p>key: 表示实际使用的索引</p></li><li><p>key_len: 索引字段的长度</p></li><li><p>ref: 列与索引的比较</p></li><li><p>rows: 扫描出的行数(估算的行数)</p></li><li><p>filtered: 按表条件过滤的行百分比</p></li><li><p>Extra: 执行情况的描述和说明</p><h3 id="1、id"><a href="#1、id" class="headerlink" title="1、id"></a>1、<em>id</em></h3><blockquote><p>SELECT识别符。这是SELECT的查询序列号<br>我的理解是SQL执行的顺序的标识，SQL从大到小的执行。</p></blockquote><h3 id="2、select-type"><a href="#2、select-type" class="headerlink" title="2、select_type"></a>2、<em>select_type</em></h3><blockquote><p> 示查询中每个select子句的类型</p></blockquote></li><li><p>SIMPLE(简单SELECT，不使用UNION或子查询等)</p></li><li><p>PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p></li><li><p>UNION(UNION中的第二个或后面的SELECT语句)</p></li><li><p>DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p></li><li><p>UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p></li><li><p>SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p></li><li><p>DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p></li><li><p>DERIVED(派生表的SELECT, FROM子句的子查询)</p></li><li><p>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p><h3 id="3、table"><a href="#3、table" class="headerlink" title="3、table"></a>3、table</h3><blockquote><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p></blockquote><h3 id="4、type"><a href="#4、type" class="headerlink" title="4、type"></a>4、type</h3><blockquote><p>表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。<br>常用的类型有： ALL、index、range、ref、eq_ref、const、system、NULL（从左到右，性能从差到好）</p></blockquote></li><li><p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p></li><li><p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p></li><li><p>range:只检索给定范围的行，使用一个索引来选择行</p></li><li><p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p></li><li><p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p></li><li><p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p></li><li><p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p><h3 id="5、possible-keys"><a href="#5、possible-keys" class="headerlink" title="5、possible_keys"></a>5、possible_keys</h3><blockquote><p>指出MySQL**&#x3D;&#x3D;能使用哪个索引在表中找到记录&#x3D;&#x3D;**，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p></blockquote><h3 id="6、Key"><a href="#6、Key" class="headerlink" title="6、Key"></a>6、Key</h3><blockquote><p>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中<br>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p></blockquote><h3 id="7、key-len"><a href="#7、key-len" class="headerlink" title="7、key_len"></a>7、key_len</h3><blockquote><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（<strong>key_len</strong>显示的值为索引字段的<strong>最大可能长度</strong>，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）<br>不损失精确性的情况下，<strong>长度越短越好</strong></p></blockquote><h3 id="8、ref"><a href="#8、ref" class="headerlink" title="8、ref"></a>8、ref</h3><blockquote><p>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p></blockquote><h3 id="9、rows"><a href="#9、rows" class="headerlink" title="9、rows"></a>9、rows</h3><blockquote><p>估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p></blockquote><h3 id="10、Extra"><a href="#10、Extra" class="headerlink" title="10、Extra"></a>10、Extra</h3><blockquote><p>该列包含MySQL解决查询的详细信息,有以下几种情况</p></blockquote></li><li><p>Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p></li><li><p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p></li><li><p>Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 测试Extra的filesort</span><br><span class="line">explain select * from emp order by name;</span><br></pre></td></tr></table></figure></li><li><p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p></li><li><p>Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p></li><li><p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p></li><li><p>No tables used：Query语句中使用from dual 或不含任何from子句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- explain select now() from dual;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>部分统计信息是估算的，并非精确值</li><li>EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计。</li><li>通过收集统计信息不可能存在结果</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
          <category> sql调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> sql调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis问题排查</title>
      <link href="/2021/07/05/redis%E7%BA%BF%E4%B8%8A%E6%8E%92%E6%9F%A5/"/>
      <url>/2021/07/05/redis%E7%BA%BF%E4%B8%8A%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis问题排查"><a href="#Redis问题排查" class="headerlink" title="Redis问题排查"></a>Redis问题排查</h1><ul><li><p>在系统缓慢的情况下，查出是内网带宽暂满的原因导致。通过网络工具查出Redis在高分期使用内网带宽<br>达到300M&#x2F;S，占用总内网带宽的30%，于是对Redis问题进行排查。</p><h1 id="通过RDB工具分析RDB中大Key的情况"><a href="#通过RDB工具分析RDB中大Key的情况" class="headerlink" title="通过RDB工具分析RDB中大Key的情况"></a>通过RDB工具分析RDB中大Key的情况</h1></li><li><p>RDB是redis数据库的快照文件，存储在硬盘上，用于持久化缓存。带宽过高，肯定是大Key的频繁读取<br>导致的，所以要找出Redis中排在前几的大key进行分析，于是乎从网上找到了一款基于Go语言编写的一<br>款RDB分析工具–RDR（<a href="https://github.com/xueqiu/rdr%EF%BC%89%E3%80%82">https://github.com/xueqiu/rdr）。</a><br>通过RDR加载RDB后，分析结果如下：<br><img src="https://note.youdao.com/yws/res/177/619F82B355884E9EBE84E06C327AD989" alt="avatar"></p></li><li><p>可以看到Redis的内存大小、key数量及大小、每个类型的数量、占比等，发现排在前几名的大Key分别<br>是dataDicCache、configCache、sysPage、USER_PERMISSION。存储类型都是Hash，其中<br>dataDicCache、configCache、sysPage在hash表中的数据都1条，但是大小却特别大，其中dataDicCache达到了惊人的918kb。<br>通过Redis的MONITOR日志查看大Key的读取情况<br>语法<br>redis Monitor 命令基本语法如下：</p><blockquote><p>redis 127.0.0.1:6379&gt; MONITOR</p></blockquote></li><li><p>监控后得到的日志如下：<br><img src="https://note.youdao.com/yws/res/180/C4CDD337ED994CF5BA66CAF004805D76" alt="image"></p></li><li><p>通过统计30秒左右的MONITOR日志，发现dataDicCache缓存读取数量巨大。一次900kb，一秒就有上百次。优化掉频繁读取的大Key，减少I&#x2F;O量<br>找到获取缓存的地方，以静态变量来存储，在调用缓存时直接获取变量，不走Redis来获取，刷新缓存时同时刷新静态变量。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>不要将频繁读取的大表存储到一个key中，不管类型是hash还是string，可以将大表拆分成多个key来存储，一次获取只获取一条数据。可以减少大量的IO和反序列化所消耗的时间</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis底层数据结构</title>
      <link href="/2021/03/10/Redis%E5%85%AD%E7%A7%8D%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2021/03/10/Redis%E5%85%AD%E7%A7%8D%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="about:blank#_2">一、简单动态字符串</a></li><li><ul><li><a href="about:blank#1SDS_4">1、SDS的结构定义</a></li></ul></li><li><a href="about:blank#2SDSc_11">2、SDS和c字符串的区别</a></li><li><ul><li><a href="about:blank#1SDS_12">1）SDS获取字符串长度复杂度为常数</a></li></ul></li><li><a href="about:blank#2SDS_15">2）SDS杜绝了缓冲区溢出</a></li><li><a href="about:blank#3_18">3）减少内存重分配次数</a></li><li><a href="about:blank#4_26">4）二进制安全</a></li><li><a href="about:blank#5SDSc_28">5）SDS兼容部分c字符串函数</a></li><li><a href="about:blank#_31">二、双向链表</a></li><li><ul><li><a href="about:blank#1_32">1、双向链表结构：</a></li></ul></li><li><a href="about:blank#2_34">2、链表节点结构：</a></li><li><a href="about:blank#3Redis_36">3、Redis的链表实现的特性：</a></li><li><a href="about:blank#_42">三、字典</a></li><li><ul><li><a href="about:blank#1_46">1、字典的实现结构</a></li></ul></li><li><ul><li><a href="about:blank#1_49">1）哈希表节点</a></li></ul></li><li><a href="about:blank#2_55">2）哈希表</a></li><li><a href="about:blank#3_61">3）字典</a></li><li><a href="about:blank#2_70">2、哈希算法</a></li><li><ul><li><a href="about:blank#MurmurHash2_73">MurmurHash2算法</a></li></ul></li><li><a href="about:blank#3rehash_76">3、哈希表的重新散列（rehash）</a></li><li><a href="about:blank#_93">四、跳跃表</a></li><li><ul><li><a href="about:blank#1zskiplistNode_97">1、跳跃表节点的结构（zskiplistNode）</a></li></ul></li><li><a href="about:blank#2zskiplist_108">2、跳跃表的结构（zskiplist）</a></li><li><a href="about:blank#_117">五、整数集合</a></li><li><ul><li><a href="about:blank#1_119">1、整数集合的结构</a></li></ul></li><li><a href="about:blank#2_125">2、整数集合的升级</a></li><li><a href="about:blank#_135">六、压缩列表</a></li><li><ul><li><a href="about:blank#1_137">1、压缩列表的构成</a></li></ul></li><li><a href="about:blank#2_147">2、压缩列表节点的结构</a></li><li><a href="about:blank#3_153">3、连锁更新</a></li></ul><p>本文将详细介绍Redis的六种底层数据结构：简单动态字符串、双向链表、字典、跳跃表、整数集合和压缩列表。</p><h1 id="一、简单动态字符串"><a href="#一、简单动态字符串" class="headerlink" title="一、简单动态字符串"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>一、简单动态字符串</h1><p>Redis没有直接使用c语言传统的字符串表示，而是自己构建了一种名为简单动态字符串的可以被修改的抽象类型，并将SDS用作Redis的默认字符串表示。</p><h2 id="1、SDS的结构定义"><a href="#1、SDS的结构定义" class="headerlink" title="1、SDS的结构定义"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>1、SDS的结构定义</h2><p>SDS结构定义如下：<br><img src="https://img-blog.csdnimg.cn/20190416200836643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注：<br>free属性的值为0，表示这个SDS没有分配任何未使用空间。<br>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。<br>buf属性是一个char类型的数组，数组最后保存了空字符‘\0’。</p><h2 id="2、SDS和c字符串的区别"><a href="#2、SDS和c字符串的区别" class="headerlink" title="2、SDS和c字符串的区别"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>2、SDS和c字符串的区别</h2><h3 id="1）SDS获取字符串长度复杂度为常数"><a href="#1）SDS获取字符串长度复杂度为常数" class="headerlink" title="1）SDS获取字符串长度复杂度为常数"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>1）SDS获取字符串长度复杂度为常数</h3><p>SDS通过获取len属性就可以得到字符串的长度，时间复杂度为： O ( 1 ) O(1) O(1)<br>c字符串需要遍历字符串，时间复杂度为： O ( N ) O(N) O(N)</p><h3 id="2）SDS杜绝了缓冲区溢出"><a href="#2）SDS杜绝了缓冲区溢出" class="headerlink" title="2）SDS杜绝了缓冲区溢出"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>2）SDS杜绝了缓冲区溢出</h3><p>c字符串如果没有重新分配空间，直接修改字符串的话，可能会造成数据溢出。<br>当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的需求，如果不满足，则自动将SDS空间扩展至所需大小。</p><h3 id="3）减少内存重分配次数"><a href="#3）减少内存重分配次数" class="headerlink" title="3）减少内存重分配次数"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>3）减少内存重分配次数</h3><p>SDS通过空间预分配和惰性空间释放两种优化策略来减少内存重分配次数。</p><ul><li>空间预分配<br>Redis通过额外分配未使用的空间，优化了SDS的字符串增长操作，减少了连续执行字符串增长操作所需的内存分配次数。</li><li>惰性空间释放<br>惰性空间释放用于优化SDS的字符串缩短操作。当SDS缩短时，程序并不会立即回收缩短后多出来的空间，而是使用free属性将这些字节的数量记录起来，等待将来使用<br>注：如果需要真正地释放SDS的未使用空间，我们可以使用相应的API。</li></ul><h3 id="4）二进制安全"><a href="#4）二进制安全" class="headerlink" title="4）二进制安全"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>4）二进制安全</h3><p>SDS API会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何的限制、过滤或者假设，所以SDS的API都是二进制安全的。</p><h3 id="5）SDS兼容部分c字符串函数"><a href="#5）SDS兼容部分c字符串函数" class="headerlink" title="5）SDS兼容部分c字符串函数"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>5）SDS兼容部分c字符串函数</h3><p>SDS之所以在末尾保存一个空字符’\0’，是为了使用一些c字符串&lt;string.h&gt;函数库，避免不必要的代码重复。<br>例如 字符串对比函数：&lt;string.h&gt;&#x2F;strcasecmp函数</p><h1 id="二、双向链表"><a href="#二、双向链表" class="headerlink" title="二、双向链表"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>二、双向链表</h1><h2 id="1、双向链表结构："><a href="#1、双向链表结构：" class="headerlink" title="1、双向链表结构："></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>1、双向链表结构：</h2><p><img src="https://img-blog.csdnimg.cn/2019041620100646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2、链表节点结构："><a href="#2、链表节点结构：" class="headerlink" title="2、链表节点结构："></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>2、链表节点结构：</h2><p><img src="https://img-blog.csdnimg.cn/20190416201057683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3、Redis的链表实现的特性："><a href="#3、Redis的链表实现的特性：" class="headerlink" title="3、Redis的链表实现的特性："></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>3、Redis的链表实现的特性：</h2><ul><li>双端</li><li>无环</li><li>带表头指针和表尾指针</li><li>带链表长度计数器</li><li>多态（保存各种不同类型的值）</li></ul><h1 id="三、字典"><a href="#三、字典" class="headerlink" title="三、字典"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>三、字典</h1><p>字典，又被称为符号表、关联数组或映射，是一种用于保存键值对的抽象数据结构。<br>字典中的每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值，或者通过键来更新值，又或者根据键来删除整个键值对，等等。<br>字典用途：Redis数据库底层实现、哈希键底层实现。</p><h2 id="1、字典的实现结构"><a href="#1、字典的实现结构" class="headerlink" title="1、字典的实现结构"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>1、字典的实现结构</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。<br>接下来的三个小节将分别介绍Redis的哈希表节点、哈希表以及字典的实现。</p><h3 id="1）哈希表节点"><a href="#1）哈希表节点" class="headerlink" title="1）哈希表节点"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>1）哈希表节点</h3><p><img src="https://img-blog.csdnimg.cn/20190416204526782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>key属性保存着键值对中的键；</li><li>v属性保存着键值对中的值，其中值用union定义，支持三种数据类型。</li><li>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突的问题。</li></ul><h3 id="2）哈希表"><a href="#2）哈希表" class="headerlink" title="2）哈希表"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>2）哈希表</h3><p><img src="https://img-blog.csdnimg.cn/2019041620504380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>table属性是一个数组，数组中的每个元素都是一个指向哈希表节点的指针，每个节点都保存着一个键值对；</li><li>size属性记录了哈希表的大小，也就是table数组的大小；</li><li>sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的那个索引上面；</li><li>used属性记录了哈希表目前已有节点的数量。</li></ul><h3 id="3）字典"><a href="#3）字典" class="headerlink" title="3）字典"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>3）字典</h3><p><img src="https://img-blog.csdnimg.cn/20190416205910583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数；</li><li>privdata属性保存了需要传给那些类型特定函数的可选参数；</li><li>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，ht[1]只有在对ht[0]哈希表进行rehash操作时使用；</li><li>trehashidx属性是rehash索引，没有进行rehash操作时值都为-1.</li></ul><p>字典、哈希表和哈希表节点关系图：<br><img src="https://img-blog.csdnimg.cn/20190416211628239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2、哈希算法"><a href="#2、哈希算法" class="headerlink" title="2、哈希算法"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>2、哈希算法</h2><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上。<br>若果字典被用做数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。</p><h3 id="MurmurHash2算法"><a href="#MurmurHash2算法" class="headerlink" title="MurmurHash2算法"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>MurmurHash2算法</h3><p>MurmurHash2算法用来计算键的哈希值，特点是运算性能高，碰撞率低。<br>详细参考：<a href="https://blog.csdn.net/thinkmo/article/details/26833565">https://blog.csdn.net/thinkmo/article/details/26833565</a></p><h2 id="3、哈希表的重新散列（rehash）"><a href="#3、哈希表的重新散列（rehash）" class="headerlink" title="3、哈希表的重新散列（rehash）"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>3、哈希表的重新散列（rehash）</h2><p>随着操作的不断执行，哈希表保存的键值对会主键增多或者减少，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。<br>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，步骤如下：</p><p><strong>1）为字典的ht[1]哈希表分配空间，空间大小根据实际情况而定；</strong></p><p><strong>2）将ht[0]中所有键值对rehash到ht[1]中</strong><br>注意：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上</p><p><strong>3）释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新建一个空表，为下次rehash做准备</strong><br>rehash操作的结构变化如下：</p><p><img src="https://img-blog.csdnimg.cn/20190417091847145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注：<br>rehash操作是渐进式的。<br>渐进式的rehash将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上。<br>之所以这样做，是考虑到如果哈希表保存的键值对的数量是百万级甚至千万级时，一次性进行rehash可能会导致服务器停止服务，渐进式地rehash避免了对服务器性能造成影响。</p><h1 id="四、跳跃表"><a href="#四、跳跃表" class="headerlink" title="四、跳跃表"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>四、跳跃表</h1><p>跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。<br>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群结点中用作内部数据结构，除此之外，跳跃表没有其他用途。</p><h2 id="1、跳跃表节点的结构（zskiplistNode）"><a href="#1、跳跃表节点的结构（zskiplistNode）" class="headerlink" title="1、跳跃表节点的结构（zskiplistNode）"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>1、跳跃表节点的结构（zskiplistNode）</h2><p><img src="https://img-blog.csdnimg.cn/20190417212726757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>层</strong>：跳跃表节点的 level[] 数组可以包含多个元素，每个元素都包含一个指向其他节点的指针 和 跨度，下标从0开始为第一层；</li><li><strong>前进指针</strong>：每个层都有一个指向表尾方向的前进指针，用于从表头向表尾方向访问节点；</li><li><strong>跨度</strong>：层的跨度用于记录两个节点之间的距离，指向NULL的所有前进指针的跨度为0；跨度用来计算节点的排位：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</li><li><strong>后退指针</strong>：后退指针用于从表尾向表头方向访问节点，每次只能后退一个节点；</li><li><strong>分值和成员</strong>：<br>分值：一个double类型的浮点数，所有节点都按照分值从小到大排序，多个节点可以包含相同的分值；<br>成员：一个指针，指向一个字符串对象，该字符串对象保存着一个SDS值，成员对象必须是唯一的。</li></ul><h2 id="2、跳跃表的结构（zskiplist）"><a href="#2、跳跃表的结构（zskiplist）" class="headerlink" title="2、跳跃表的结构（zskiplist）"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>2、跳跃表的结构（zskiplist）</h2><p>仅靠过个跳跃表节点就可以组成一个跳跃表，但通过使用一个zskiplist结构来持有这些节点，就可以很方便地对整个跳跃表进行处理。<br>zskiplist结构如图：<img src="https://img-blog.csdnimg.cn/20190417215602606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>header和tail指针分别指向跳跃表的表头和表尾节点；</li><li>length属性记录节点的数量；</li><li>level属性记录层数最高的几点的层数量；</li></ul><p>下图分别展示了完整的跳跃表和单个节点的详细结构图：<br><img src="https://img-blog.csdnimg.cn/20190417222432637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="五、整数集合"><a href="#五、整数集合" class="headerlink" title="五、整数集合"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>五、整数集合</h1><p>整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为 int16_t 、int32_t 或者 int64_t 的整数值，并且保证集合中不出现重复值。</p><h2 id="1、整数集合的结构"><a href="#1、整数集合的结构" class="headerlink" title="1、整数集合的结构"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>1、整数集合的结构</h2><p><img src="https://img-blog.csdnimg.cn/20190417224045599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>encoding</strong>：contents数组中元素的类型，有 INTSET_ENC_INT16、INTSET_ENC_INT32 和 INTSET_ENC_INT64 三种，分别表示contents数组中元素类型为 int16_t（16位二进制）、int32_t 和 int64_t 类型。</li><li><strong>contents</strong>：整数集合的每个元素都是contents数组的一个数组项，各个项在数组中按值的大小从小到大有序地排列，数组中不包含重复项。</li><li><strong>length</strong>：记录了整数集合包含的元素数量。<br><img src="https://img-blog.csdnimg.cn/20190418131716416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="2、整数集合的升级"><a href="#2、整数集合的升级" class="headerlink" title="2、整数集合的升级"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>2、整数集合的升级</h2><p>如果我们想要添加一个新元素到整数集合里面，但是新元素的类型比整数集合原有的元素类型都要长时，我们就要对整数集合进行升级，然后才能将新元素添加到整数集合里面。<br>另外，还需注意，Redis的整数集合不支持降级。</p><p><strong>升级整数集合并添加新元素共分为三步进行：</strong><br>1）根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。<br>2）将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素继续维持底层数组的有序性质不变。<br>3）将新元素添加到底层数组里面。</p><p>升级步骤图解：<img src="https://img-blog.csdnimg.cn/20190418133651854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FiZWxfTGl1amlucXVhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="六、压缩列表"><a href="#六、压缩列表" class="headerlink" title="六、压缩列表"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>六、压缩列表</h1><p>压缩列表是列表键和哈希键的底层实现之一。当一个列表键值包含少量列表键，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><h2 id="1、压缩列表的构成"><a href="#1、压缩列表的构成" class="headerlink" title="1、压缩列表的构成"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>1、压缩列表的构成</h2><p>压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点 （entry），每个节点可以保存一个字节数组或者一个整数值。</p><p>压缩列表结构：<img src="https://img-blog.csdnimg.cn/20190419083726519.png" alt="在这里插入图片描述"></p><ul><li>zlbytes属性：表示压缩列表的总字节长度；</li><li>zltail属性：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节；</li><li>zllen属性：记录了压缩列表包含的节点数量；</li><li>entryX属性：压缩列表包含的各个节点；</li><li>zlend属性：用于标记压缩列表的末端。</li></ul><h2 id="2、压缩列表节点的结构"><a href="#2、压缩列表节点的结构" class="headerlink" title="2、压缩列表节点的结构"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>2、压缩列表节点的结构</h2><p>压缩列表节点的结构如图：<img src="https://img-blog.csdnimg.cn/20190419085114429.png" alt="在这里插入图片描述"></p><ul><li><strong>previous_entry_length属性</strong>：以字节为单位，记录压缩列表中前一个节点的长度。<br>程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址，以此实现遍历操作。</li><li><strong>encoding属性</strong>：记录了节点的content属性所保存数据的类型和长度；</li><li><strong>content属性</strong>：保存节点的值，可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</li></ul><h2 id="3、连锁更新"><a href="#3、连锁更新" class="headerlink" title="3、连锁更新"></a><a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599"></a>3、连锁更新</h2><p>假设压缩列表中所有节点的previous_entry_length属性都是用1字节来保存，那么节点的长度只要小于等于253字节previous_entry_length都可以记录，但是，如果添加一个长度大于253字节的节点，那么下一个节点的previous_entry_length就无法保存该长度的值，同样的，下下个节点也无法保存上个节点的长度，由此将导致连续多次空间扩展操作。</p><p>添加节点和删除节点都可能导致连锁更新，但是这种操作出现的几率很低。</p><p>本文转自 <a href="https://blog.csdn.net/Abel_Liujinquan/article/details/89339599">https://blog.csdn.net/Abel_Liujinquan&#x2F;article&#x2F;details&#x2F;89339599</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchorized浅理解</title>
      <link href="/2021/03/05/synchorized%E6%B5%85%E7%90%86%E8%A7%A3/"/>
      <url>/2021/03/05/synchorized%E6%B5%85%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="synchorized浅理解"><a href="#synchorized浅理解" class="headerlink" title="synchorized浅理解"></a>synchorized浅理解</h2><blockquote><p>首先这是一种互斥锁，也是一种悲观锁，一次只能允许一个线程进入被锁住的代码块（吐槽：这些锁啊锁的是真的多，累了）<br>对象：代码块 ｜ 对象</p></blockquote><ul><li>实例方法 ：锁的是对象实例</li><li>静态方法 ：锁的是当前类的class实例</li><li>代码块 ： 锁得是传入synchorized的对象实例</li></ul><blockquote><p>我们都知道一个对象分为三块：对象头，对象实际数据，对齐填充（补满8字节）。</p></blockquote><ul><li>对象头：里面有个markword。这里会记住锁的信息，又因为每个对象都会有一个与之对应的monitor对象，这里面存着当前持有锁的线程<br>以及等待锁的线程队列。monitor对象会存储当前id，设置markword的monitor的对象地址，并把阻塞的线程存储到minitor的等待线程队列中</li></ul><p>加锁的底层是依赖底层的操作系统的mutex，相关指令实现，有用户态和内核态之间的切换，性能损耗比较明显。</p><p><br>重磅消息：之前是重量级锁，而1.6之后引入了偏向锁和轻量级锁，不依赖系统了，性能得到提升。而markword一共记录了四种状态</p><ul><li>偏向锁：jvm认为只有某个线程才会执行同步代码（没有竞争的环境）。所以markword会记录线程ID，对比线程id是否相等，相等就能直接拿到锁，执行同步代码。<br>如果不相等就用CAS尝试修改当前线程ID，如果成功，则拿到锁，执行同步代码，如果CAS失败了，此时会撤销偏向锁，升级为轻量级锁。</li><li>轻量级锁：当前线程会在栈帧下创建Lock Record， 然后把mark word信息拷贝进去，且有个owner指针指向加锁的对象。<br>线程此时执行到同步代码块时，用CAS试图将Mark word指向到栈帧的lock Record，如果CAS修改成功，则获得轻量级锁。<br>如果失败则（自旋），升级为重量级锁。</li><li>重量级锁：依赖操作系统的monitor对象，耗性能。</li><li>无锁<h2 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h2><blockquote><p>偏向锁,只会用markword线程id进行比对，轻量级锁拷贝到Lock Record，+ CAS自旋获取，随后就是重量级锁了。</p></blockquote></li></ul><p>只有一个线程：偏向锁。</p><p>多个线程交替进入临界区：轻量级锁。</p><p>多线程同时进入临界区：重量级锁</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射和动态代理</title>
      <link href="/2021/02/05/%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2021/02/05/%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote><p>反射：在运行时返回给我们类信息。<br>基础用法：创建对象，获取属性名。<br>重点是:[运行时]获取类信息，编写代码都是.java 然后编译成.class, .class文件会被jvm装载运行，这里运行的就叫做运行时。<br>理解反射，既要抽象。<br>先介绍一下 工具，组件，框架。</p></blockquote><ul><li>工具：util类</li><li>组件：jar包</li><li>框架：组件发展壮大<blockquote><p>例如SpringMVC 你在方法上写上对象，传入的参数就会帮你封装到对象上<br>Mybatis可以让我们只写接口，不写实现类，就可以执行SQL<br>你在类上加上@Component注解，Spring就帮你创建对象<br>这些统统都有反射的身影：约定大于配置，配置大于硬编码。</p></blockquote><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote><p>动态代理其实就是代理模式的一种，代理模式是设计模式之一,代理模型有静态代理和动态代理。静态代理需要自己写代理类，实现对应的接口，比较麻烦。</p></blockquote></li></ul><p>在Java中，动态代理常见的又有两种实现方式：<br><strong>JDK</strong>动态代理和<strong>CGLIB</strong>代理.<br>JDK动态代理其实就是运用了反射的机制，而CGLIB代理则用的是利用ASM框架，通过修改其字节码生成子类来处理<br>DK动态代理会帮我们实现接口的方法，通过invokeHandler对所需要的方法进行增强。</p><ul><li>像上面所讲的Mybatis不用写实现类，只写接口就可以执行SQL，又或是SpringAOP 等等好用的技术，实际上用的就是动态代理</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC 容器源码分析</title>
      <link href="/2021/01/03/Spring-IOC%E6%BA%90%E7%A0%81/"/>
      <url>/2021/01/03/Spring-IOC%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><a href="https://javadoop.com/">回首页</a></p><h1 id="Spring-IOC-容器源码分析"><a href="#Spring-IOC-容器源码分析" class="headerlink" title="Spring IOC 容器源码分析"></a>Spring IOC 容器源码分析</h1><p><a href="https://javadoop.com/post/download?userName=hongjie&postName=spring-ioc"></a></p><p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。</p><p>本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。</p><p>阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。</p><p>希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先看下最基本的启动 Spring 容器的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationfile.xml&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p></blockquote><p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。</p><p>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code> 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：</p><p><img src="https://www.javadoop.com/blogimages/spring-context/1.png" alt="1"></p><blockquote><p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。</p><p>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p></blockquote><p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 <strong>FileSystemXmlApplicationContext</strong> 和 <strong>AnnotationConfigApplicationContext</strong> 这两个类。</p><p><strong>1、FileSystemXmlApplicationContext</strong> 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p><p><strong>2、AnnotationConfigApplicationContext</strong> 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p><p>不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p><p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p><p>首先，定义一个接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageService &#123;</span><br><span class="line">    String getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义接口实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MessageServiceImpl implements MessageService &#123;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return &quot;hello world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; default-autowire=&quot;byName&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，我们就可以跑起来了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 用我们的配置文件来启动一个 ApplicationContext</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;context 启动成功&quot;);</span><br><span class="line"></span><br><span class="line">        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span><br><span class="line">        MessageService messageService = context.getBean(MessageService.class);</span><br><span class="line">        // 这句将输出: hello world</span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p><h2 id="BeanFactory-简介"><a href="#BeanFactory-简介" class="headerlink" title="BeanFactory 简介"></a>BeanFactory 简介</h2><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p><p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：</p><p><img src="https://www.javadoop.com/blogimages/spring-context/2.png" alt="2"></p><p>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p><ol><li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li><li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li><li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li><li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li><li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。</li></ol><p>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</p><h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2><p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p><p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123;</span><br><span class="line">  private Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span><br><span class="line">  public ClassPathXmlApplicationContext(ApplicationContext parent) &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</span><br><span class="line">      throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">    super(parent);</span><br><span class="line">    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    if (refresh) &#123;</span><br><span class="line">      refresh(); // 核心方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p><p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class="line">      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class="line">      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class="line">      // 这块待会会展开说</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class="line">         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class="line"></span><br><span class="line">         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class="line">         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class="line">         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class="line">         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         // 从方法名就可以知道，典型的模板方法(钩子方法)，</span><br><span class="line">         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         // 重点，重点，重点</span><br><span class="line">         // 初始化所有的 singleton beans</span><br><span class="line">         //（lazy-init 的除外）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 最后，广播事件，ApplicationContext 初始化完成</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         // Reset &#x27;active&#x27; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         // 把异常往外抛</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         // Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">         // might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面，我们开始一步步来肢解这个 refresh() 方法。</p><h3 id="创建-Bean-容器前的准备工作"><a href="#创建-Bean-容器前的准备工作" class="headerlink" title="创建 Bean 容器前的准备工作"></a>创建 Bean 容器前的准备工作</h3><p>这个比较简单，直接看代码中的几个注释即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareRefresh() &#123;</span><br><span class="line">   // 记录启动时间，</span><br><span class="line">   // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span><br><span class="line">   this.startupDate = System.currentTimeMillis();</span><br><span class="line">   this.closed.set(false);</span><br><span class="line">   this.active.set(true);</span><br><span class="line"></span><br><span class="line">   if (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(&quot;Refreshing &quot; + this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Initialize any placeholder property sources in the context environment</span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   // 校验 xml 配置文件</span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建-Bean-容器，加载并注册-Bean"><a href="#创建-Bean-容器，加载并注册-Bean" class="headerlink" title="创建 Bean 容器，加载并注册 Bean"></a>创建 Bean 容器，加载并注册 Bean</h3><p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p><p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p><p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p><p>&#x2F;&#x2F; AbstractApplicationContext.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   // 返回刚刚创建的 BeanFactory</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   return beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; AbstractRefreshableApplicationContext.java 120</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span><br><span class="line">   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span><br><span class="line">   // ApplicationContext 是否有 BeanFactory</span><br><span class="line">   if (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">      // 下面这两个方法很重要，别跟丢了，具体细节之后说</span><br><span class="line">      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      // 加载 Bean 到 BeanFactory 中</span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">         this.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (IOException ex) &#123;</span><br><span class="line">      throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p></blockquote><p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：</p><p><img src="https://www.javadoop.com/blogimages/spring-context/3.png" alt="3"></p><p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p><blockquote><p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？</p><p>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。</p><p>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。</p></blockquote><p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p><p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p><p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p><blockquote><p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p></blockquote><h4 id="BeanDefinition-接口定义"><a href="#BeanDefinition-接口定义" class="headerlink" title="BeanDefinition 接口定义"></a>BeanDefinition 接口定义</h4><p>我们来看下 BeanDefinition 的接口定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   // 我们可以看到，默认只提供 sington 和 prototype 两种，</span><br><span class="line">   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span><br><span class="line">   // 不过，它们属于基于 web 的扩展。</span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   // 比较不重要，直接跳过吧</span><br><span class="line">   int ROLE_APPLICATION = 0;</span><br><span class="line">   int ROLE_SUPPORT = 1;</span><br><span class="line">   int ROLE_INFRASTRUCTURE = 2;</span><br><span class="line"></span><br><span class="line">   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span><br><span class="line">   // 一句话就是：继承父 Bean 的配置信息而已</span><br><span class="line">   void setParentName(String parentName);</span><br><span class="line"></span><br><span class="line">   // 获取父 Bean</span><br><span class="line">   String getParentName();</span><br><span class="line"></span><br><span class="line">   // 设置 Bean 的类名称，将来是要通过反射来生成实例的</span><br><span class="line">   void setBeanClassName(String beanClassName);</span><br><span class="line"></span><br><span class="line">   // 获取 Bean 的类名称</span><br><span class="line">   String getBeanClassName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   // 设置 bean 的 scope</span><br><span class="line">   void setScope(String scope);</span><br><span class="line"></span><br><span class="line">   String getScope();</span><br><span class="line"></span><br><span class="line">   // 设置是否懒加载</span><br><span class="line">   void setLazyInit(boolean lazyInit);</span><br><span class="line"></span><br><span class="line">   boolean isLazyInit();</span><br><span class="line"></span><br><span class="line">   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span><br><span class="line">   // 是 depends-on=&quot;&quot; 属性设置的值。</span><br><span class="line">   void setDependsOn(String... dependsOn);</span><br><span class="line"></span><br><span class="line">   // 返回该 Bean 的所有依赖</span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span><br><span class="line">   // 如果根据名称注入，即使这边设置了 false，也是可以的</span><br><span class="line">   void setAutowireCandidate(boolean autowireCandidate);</span><br><span class="line"></span><br><span class="line">   // 该 Bean 是否可以注入到其他 Bean 中</span><br><span class="line">   boolean isAutowireCandidate();</span><br><span class="line"></span><br><span class="line">   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span><br><span class="line">   void setPrimary(boolean primary);</span><br><span class="line"></span><br><span class="line">   // 是否是 primary 的</span><br><span class="line">   boolean isPrimary();</span><br><span class="line"></span><br><span class="line">   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span><br><span class="line">   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span><br><span class="line">   void setFactoryBeanName(String factoryBeanName);</span><br><span class="line">   // 获取工厂名称</span><br><span class="line">   String getFactoryBeanName();</span><br><span class="line">   // 指定工厂类中的 工厂方法名称</span><br><span class="line">   void setFactoryMethodName(String factoryMethodName);</span><br><span class="line">   // 获取工厂类中的 工厂方法名称</span><br><span class="line">   String getFactoryMethodName();</span><br><span class="line"></span><br><span class="line">   // 构造器参数</span><br><span class="line">   ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class="line"></span><br><span class="line">   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span><br><span class="line">   MutablePropertyValues getPropertyValues();</span><br><span class="line"></span><br><span class="line">   // 是否 singleton</span><br><span class="line">   boolean isSingleton();</span><br><span class="line"></span><br><span class="line">   // 是否 prototype</span><br><span class="line">   boolean isPrototype();</span><br><span class="line"></span><br><span class="line">   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span><br><span class="line">   // 常用于作为 父bean 用于继承，其实也很少用......</span><br><span class="line">   boolean isAbstract();</span><br><span class="line"></span><br><span class="line">   int getRole();</span><br><span class="line">   String getDescription();</span><br><span class="line">   String getResourceDescription();</span><br><span class="line">   BeanDefinition getOriginatingBeanDefinition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。</p><p>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p></blockquote><p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然只有两个方法，但路还很长啊。。。</p><h4 id="customizeBeanFactory"><a href="#customizeBeanFactory" class="headerlink" title="customizeBeanFactory"></a>customizeBeanFactory</h4><p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">   if (this.allowBeanDefinitionOverriding != null) &#123;</span><br><span class="line">      // 是否允许 Bean 定义覆盖</span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   if (this.allowCircularReferences != null) &#123;</span><br><span class="line">      // 是否允许 Bean 间的循环依赖</span><br><span class="line">      beanFactory.setAllowCircularReferences(this.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p><p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p><p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p><p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p><h4 id="加载-Bean-loadBeanDefinitions"><a href="#加载-Bean-loadBeanDefinitions" class="headerlink" title="加载 Bean: loadBeanDefinitions"></a>加载 Bean: loadBeanDefinitions</h4><p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p><p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p><p>&#x2F;&#x2F; AbstractXmlApplicationContext.java 80</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span><br><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">   // Configure the bean definition reader with this context&#x27;s</span><br><span class="line">   // resource loading environment.</span><br><span class="line">   beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span><br><span class="line">   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   // 重点来了，继续往下</span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p><p>&#x2F;&#x2F; AbstractXmlApplicationContext.java 120</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   if (configResources != null) &#123;</span><br><span class="line">      // 往下看</span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   if (configLocations != null) &#123;</span><br><span class="line">      // 2</span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(resources, &quot;Resource array must not be null&quot;);</span><br><span class="line">   int counter = 0;</span><br><span class="line">   // 注意这里是个 for 循环，也就是每个文件是一个 resource</span><br><span class="line">   for (Resource resource : resources) &#123;</span><br><span class="line">      // 继续往下看</span><br><span class="line">      counter += loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   // 最后返回 counter，表示总共加载了多少的 BeanDefinition</span><br><span class="line">   return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// XmlBeanDefinitionReader 303</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// XmlBeanDefinitionReader 314</span><br><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);</span><br><span class="line">   if (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());</span><br><span class="line">   &#125;</span><br><span class="line">   // 用一个 ThreadLocal 来存放配置文件资源</span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   if (currentResources == null) &#123;</span><br><span class="line">      currentResources = new HashSet&lt;EncodedResource&gt;(4);</span><br><span class="line">      this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   if (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      throw new BeanDefinitionStoreException(</span><br><span class="line">            &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">      InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">      try &#123;</span><br><span class="line">         InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">         if (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         // 核心部分是这里，往下面看</span><br><span class="line">         return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      finally &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (IOException ex) &#123;</span><br><span class="line">      throw new BeanDefinitionStoreException(</span><br><span class="line">            &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      if (currentResources.isEmpty()) &#123;</span><br><span class="line">         this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 还在这个文件中，第 388 行</span><br><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      // 这里就不看了，将 xml 文件转换为 Document 对象</span><br><span class="line">      Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">      // 继续</span><br><span class="line">      return registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (...</span><br><span class="line">&#125;</span><br><span class="line">// 还在这个文件中，第 505 行</span><br><span class="line">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">   int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">   // 这里</span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line">// DefaultBeanDefinitionDocumentReader 90</span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">   this.readerContext = readerContext;</span><br><span class="line">   logger.debug(&quot;Loading bean definitions&quot;);</span><br><span class="line">   Element root = doc.getDocumentElement();</span><br><span class="line">   // 从 xml 根节点开始解析文件</span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;         </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p><h5 id="doRegisterBeanDefinitions："><a href="#doRegisterBeanDefinitions：" class="headerlink" title="doRegisterBeanDefinitions："></a>doRegisterBeanDefinitions：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// DefaultBeanDefinitionDocumentReader 116</span><br><span class="line">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，</span><br><span class="line">   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，</span><br><span class="line">   // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了</span><br><span class="line">   BeanDefinitionParserDelegate parent = this.delegate;</span><br><span class="line">   this.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">   if (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      // 这块说的是根节点 &lt;beans ... profile=&quot;dev&quot; /&gt; 中的 profile 是否是当前环境需要的，</span><br><span class="line">      // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析</span><br><span class="line">      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区</span><br><span class="line">      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      if (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">         if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">            if (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +</span><br><span class="line">                     &quot;] not matching: &quot; + getReaderContext().getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   preProcessXml(root); // 钩子</span><br><span class="line">   // 往下看</span><br><span class="line">   parseBeanDefinitions(root, this.delegate);</span><br><span class="line">   postProcessXml(root); // 钩子</span><br><span class="line"></span><br><span class="line">   this.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p><p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p><p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span><br><span class="line">// 其他的属于 custom 的</span><br><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         if (node instanceof Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               // 解析 default namespace 下面的几个元素</span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">               // 解析其他 namespace 的元素</span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p><p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;beans /&gt;</code> 这几个。</p><blockquote><p>这里的四个标签之所以是 <strong>default</strong> 的，是因为它们是处于这个 namespace 下定义的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.springframework.org/schema/beans</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 <strong>xmlns</strong> 就是咯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">            http://www.springframework.org/schema/beans</span><br><span class="line">          http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span><br><span class="line">       default-autowire=&quot;byName&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code>&lt;mvc /&gt;</code>、<code>&lt;task /&gt;</code>、<code>&lt;context /&gt;</code>、<code>&lt;aop /&gt;</code>等。</p><p>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。</p><p>假如读者想分析 <code>&lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt;</code> 的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;</span><br><span class="line">           http://www.springframework.org/schema/beans </span><br><span class="line">           http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">           http://www.springframework.org/schema/context</span><br><span class="line">           http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">           http://www.springframework.org/schema/mvc   </span><br><span class="line">           http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span><br><span class="line">       &quot;</span><br><span class="line">      default-autowire=&quot;byName&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同理，以后你要是碰到 <code>&lt;dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。</p></blockquote><p>回过神来，看看处理 default 标签的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      // 处理 &lt;import /&gt; 标签</span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      // 处理 &lt;alias /&gt; 标签定义</span><br><span class="line">      // &lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;</span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧</span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <code>&lt;bean /&gt;</code> 标签出来说。</p><h5 id="processBeanDefinition-解析-bean-标签"><a href="#processBeanDefinition-解析-bean-标签" class="headerlink" title="processBeanDefinition 解析 bean 标签"></a>processBeanDefinition 解析 bean 标签</h5><p>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p><p>&#x2F;&#x2F; DefaultBeanDefinitionDocumentReader 298</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看</span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"></span><br><span class="line">   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span><br><span class="line"></span><br><span class="line">   if (bdHolder != null) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      try &#123;</span><br><span class="line">         // Register the final decorated instance.</span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(&quot;Failed to register bean definition with name &#x27;&quot; +</span><br><span class="line">               bdHolder.getBeanName() + &quot;&#x27;&quot;, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      // Send registration event.</span><br><span class="line">      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p><table><thead><tr><th>Property</th><th></th></tr></thead><tbody><tr><td>class</td><td>类的全限定名</td></tr><tr><td>name</td><td>可指定 id、name(用逗号、分号、空格分隔)</td></tr><tr><td>scope</td><td>作用域</td></tr><tr><td>constructor arguments</td><td>指定构造参数</td></tr><tr><td>properties</td><td>设置属性的值</td></tr><tr><td>autowiring mode</td><td>no(默认值)、byName、byType、 constructor</td></tr><tr><td>lazy-initialization mode</td><td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td></tr><tr><td>initialization method</td><td>bean 属性设置完成后，会调用这个方法</td></tr><tr><td>destruction method</td><td>bean 销毁后的回调方法</td></tr></tbody></table><p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p><p>简单地说就是像下面这样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; name=&quot;name1, name2, name3&quot; class=&quot;com.javadoop.ExampleBean&quot;</span><br><span class="line">      scope=&quot;singleton&quot; lazy-init=&quot;true&quot; init-method=&quot;init&quot; destroy-method=&quot;cleanup&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 可以用下面三种形式指定构造参数 --&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- property 的几种情况 --&gt;</span><br><span class="line">    &lt;property name=&quot;beanOne&quot;&gt;</span><br><span class="line">        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;</code>、<code>&lt;replaced-method /&gt;</code>、<code>&lt;meta /&gt;</code>、<code>&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p><p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p><p>&#x2F;&#x2F; BeanDefinitionParserDelegate 428</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">    return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class="line">   String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span><br><span class="line">   // 当然，如果你不定义 name 属性的话，就是空的了</span><br><span class="line">   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了</span><br><span class="line">   if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String beanName = id;</span><br><span class="line">   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span><br><span class="line">   if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(0);</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot; + beanName +</span><br><span class="line">               &quot;&#x27; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (containingBean == null) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span><br><span class="line">   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。</span><br><span class="line">   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line">   // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span><br><span class="line">   if (beanDefinition != null) &#123;</span><br><span class="line">      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span><br><span class="line">      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要</span><br><span class="line">      if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            if (containingBean != null) &#123;// 按照我们的思路，这里 containingBean 是 null 的</span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：</span><br><span class="line">               //   1. beanName 为：com.javadoop.example.MessageServiceImpl#0</span><br><span class="line">               //   2. beanClassName 为：com.javadoop.example.MessageServiceImpl</span><br><span class="line"></span><br><span class="line">               beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"></span><br><span class="line">               String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">               if (beanClassName != null &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  // 把 beanClassName 设置为 Bean 的别名</span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot; +</span><br><span class="line">                     &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            return null;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      // 返回 BeanDefinitionHolder</span><br><span class="line">      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">      Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line"></span><br><span class="line">   this.parseState.push(new BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">   String className = null;</span><br><span class="line">   if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      String parent = null;</span><br><span class="line">      if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">         parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">      &#125;</span><br><span class="line">      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span><br><span class="line">      AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span><br><span class="line">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span><br><span class="line">       * 解析出来以后的信息都放到 bd 的属性中</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      // 解析 &lt;meta /&gt;</span><br><span class="line">      parseMetaElements(ele, bd);</span><br><span class="line">      // 解析 &lt;lookup-method /&gt;</span><br><span class="line">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">      // 解析 &lt;replaced-method /&gt;</span><br><span class="line">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    // 解析 &lt;constructor-arg /&gt;</span><br><span class="line">      parseConstructorArgElements(ele, bd);</span><br><span class="line">      // 解析 &lt;property /&gt;</span><br><span class="line">      parsePropertyElements(ele, bd);</span><br><span class="line">      // 解析 &lt;qualifier /&gt;</span><br><span class="line">      parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">      bd.setResource(this.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">      return bd;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (ClassNotFoundException ex) &#123;</span><br><span class="line">      error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (NoClassDefFoundError err) &#123;</span><br><span class="line">      error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">      this.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p><p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   if (bdHolder != null) &#123;</span><br><span class="line">      // 如果有自定义属性的话，进行相应的解析，先忽略</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      try &#123;</span><br><span class="line">         // 我们把这步叫做 注册Bean 吧</span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(&quot;Failed to register bean definition with name &#x27;&quot; +</span><br><span class="line">               bdHolder.getBeanName() + &quot;&#x27;&quot;, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      // 注册完成后，发送事件，本文不展开说这个</span><br><span class="line">      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDefinitionHolder implements BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">  private final BeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line">  private final String beanName;</span><br><span class="line"></span><br><span class="line">  private final String[] aliases;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p><p>下面，我们开始说说注册 Bean 吧。</p><h5 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h5><p>&#x2F;&#x2F; BeanDefinitionReaderUtils 143</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanDefinition(</span><br><span class="line">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   // 注册这个 Bean</span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   if (aliases != null) &#123;</span><br><span class="line">      for (String alias : aliases) &#123;</span><br><span class="line">         // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span><br><span class="line">         // 获取的时候，会先将 alias 转换为 beanName，然后再查找</span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p><p>&#x2F;&#x2F; DefaultListableBeanFactory 793</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"></span><br><span class="line">   if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         throw new BeanDefinitionStoreException(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span><br><span class="line">   oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">   // 处理重复名称的 Bean 定义的情况</span><br><span class="line">   if (oldBeanDefinition != null) &#123;</span><br><span class="line">      if (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         // 如果不允许覆盖的话，抛异常</span><br><span class="line">         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...</span><br><span class="line">      &#125;</span><br><span class="line">      else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         // log...用框架定义的 Bean 覆盖用户自定义的 Bean </span><br><span class="line">      &#125;</span><br><span class="line">      else if (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         // log...用新的 Bean 覆盖旧的 Bean</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span><br><span class="line">      &#125;</span><br><span class="line">      // 覆盖</span><br><span class="line">      this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      // 判断是否已经有其他的 Bean 开始初始化了.</span><br><span class="line">      // 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span><br><span class="line">      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span><br><span class="line">      if (hasBeanCreationStarted()) &#123;</span><br><span class="line">         // Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">         synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">            this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">            updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            this.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            if (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               this.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         // 最正常的应该是进到这个分支。</span><br><span class="line"></span><br><span class="line">         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span><br><span class="line">         this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span><br><span class="line">         this.beanDefinitionNames.add(beanName);</span><br><span class="line">         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span><br><span class="line">         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span><br><span class="line">         // 手动指的是通过调用以下方法注册的 bean ：</span><br><span class="line">         //     registerSingleton(String beanName, Object singletonObject)</span><br><span class="line">         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，</span><br><span class="line">         // 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span><br><span class="line">         this.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      // 这个不重要，在预初始化的时候会用到，不必管它。</span><br><span class="line">      this.frozenBeanDefinitionNames = null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (oldBeanDefinition != null || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p><p>-——– 分割线 ———</p><p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p><h3 id="Bean-容器实例化完成后"><a href="#Bean-容器实例化完成后" class="headerlink" title="Bean 容器实例化完成后"></a>Bean 容器实例化完成后</h3><p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p><p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class="line">      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class="line">      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class="line">      // 这块待会会展开说</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class="line">         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class="line"></span><br><span class="line">         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class="line">         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class="line">         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class="line">         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span><br><span class="line">         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         // 重点，重点，重点</span><br><span class="line">         // 初始化所有的 singleton beans</span><br><span class="line">         //（lazy-init 的除外）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 最后，广播事件，ApplicationContext 初始化完成，不展开</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         // Reset &#x27;active&#x27; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         // 把异常往外抛</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         // Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">         // might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h3><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p><p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Configure the factory&#x27;s standard context characteristics,</span><br><span class="line"> * such as the context&#x27;s ClassLoader and post-processors.</span><br><span class="line"> * @param beanFactory the BeanFactory to configure</span><br><span class="line"> */</span><br><span class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span><br><span class="line">   // 这里设置为加载当前 ApplicationContext 类的类加载器</span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line">   // 设置 BeanExpressionResolver</span><br><span class="line">   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">   // </span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   // 添加一个 BeanPostProcessor，这个 processor 比较简单：</span><br><span class="line">   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span><br><span class="line">   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span><br><span class="line">   // 注意：它不仅仅回调 ApplicationContextAware，</span><br><span class="line">   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line"></span><br><span class="line">   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span><br><span class="line">   // Spring 会通过其他方式来处理这些依赖。</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span><br><span class="line">    * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行。</span><br><span class="line">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span><br><span class="line">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span><br><span class="line">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span><br><span class="line">    */</span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line"></span><br><span class="line">   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span><br><span class="line">   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line"></span><br><span class="line">   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span><br><span class="line">   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span><br><span class="line">   //    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj</span><br><span class="line">   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      // Set a temporary ClassLoader for type matching.</span><br><span class="line">      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean，</span><br><span class="line">    * 我们也可以选择覆盖</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   // 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   // 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   // 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p><h3 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h3><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p><p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p><p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p><p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p><p>&#x2F;&#x2F; AbstractApplicationContext.java 834</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 初始化剩余的 singleton beans</span><br><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line"></span><br><span class="line">   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span><br><span class="line">   // 什么，看代码这里没有初始化 Bean 啊！</span><br><span class="line">   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span><br><span class="line">   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Register a default embedded value resolver if no bean post-processor</span><br><span class="line">   // (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">   // at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">   if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(new StringValueResolver() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public String resolveStringValue(String strVal) &#123;</span><br><span class="line">            return getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 先初始化 LoadTimeWeaverAware 类型的 Bean</span><br><span class="line">   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">   for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Stop using the temporary ClassLoader for type matching.</span><br><span class="line">   beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span><br><span class="line">   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   // 开始初始化</span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p><h4 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons"></a>preInstantiateSingletons</h4><p>&#x2F;&#x2F; DefaultListableBeanFactory 728</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">   if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">      this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">   &#125;</span><br><span class="line">   // this.beanDefinitionNames 保存了所有的 beanNames</span><br><span class="line">   List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span><br><span class="line">   for (String beanName : beanNames) &#123;</span><br><span class="line"></span><br><span class="line">      // 合并父 Bean 中的配置，注意 &lt;bean id=&quot;&quot; class=&quot;&quot; parent=&quot;&quot; /&gt; 中的 parent，用的不多吧，</span><br><span class="line">      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 &quot;Bean 继承&quot;，不了解的请到附录中看一下</span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">      // 非抽象、非懒加载的 singletons。如果配置了 &#x27;abstract = true&#x27;，那是不需要初始化的</span><br><span class="line">      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span><br><span class="line">         if (isFactoryBean(beanName)) &#123;</span><br><span class="line">            // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span><br><span class="line">            final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span><br><span class="line">            boolean isEagerInit;</span><br><span class="line">            if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">               isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public Boolean run() &#123;</span><br><span class="line">                     return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">               isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            &#125;</span><br><span class="line">            if (isEagerInit) &#123;</span><br><span class="line"></span><br><span class="line">               getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span><br><span class="line">   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span><br><span class="line">   for (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         if (System.getSecurityManager() != null) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public Object run() &#123;</span><br><span class="line">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                  return null;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p><h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><p>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p><p>&#x2F;&#x2F; AbstractBeanFactory 196</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">   return doGetBean(name, null, null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span><br><span class="line">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">protected &lt;T&gt; T doGetBean(</span><br><span class="line">      final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">      throws BeansException &#123;</span><br><span class="line">   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span><br><span class="line">   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span><br><span class="line">   final String beanName = transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">   // 注意跟着这个，这个是返回值</span><br><span class="line">   Object bean; </span><br><span class="line"></span><br><span class="line">   // 检查下是不是已经创建过了</span><br><span class="line">   Object sharedInstance = getSingleton(beanName);</span><br><span class="line"></span><br><span class="line">   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span><br><span class="line">   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span><br><span class="line">   if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">         if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(&quot;...&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            logger.debug(&quot;Returning cached instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span><br><span class="line">      // 如果是 FactoryBean 的话，返回它创建的那个实例对象</span><br><span class="line">      // (FactoryBean 知识，读者若不清楚请移步附录)</span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   else &#123;</span><br><span class="line">      if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span><br><span class="line">         // 往往是因为陷入了循环引用</span><br><span class="line">         throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 检查一下这个 BeanDefinition 在容器中是否存在</span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span><br><span class="line">         String nameToLookup = originalBeanName(name);</span><br><span class="line">         if (args != null) &#123;</span><br><span class="line">            // 返回父容器的查询结果</span><br><span class="line">            return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            // No args -&gt; delegate to standard getBean method.</span><br><span class="line">            return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!typeCheckOnly) &#123;</span><br><span class="line">         // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * 稍稍总结一下：</span><br><span class="line">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span><br><span class="line">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span><br><span class="line">       */</span><br><span class="line">      try &#123;</span><br><span class="line">         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         // 先初始化依赖的所有 Bean，这个很好理解。</span><br><span class="line">         // 注意，这里的依赖指的是 depends-on 中定义的依赖</span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         if (dependsOn != null) &#123;</span><br><span class="line">            for (String dep : dependsOn) &#123;</span><br><span class="line">               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span><br><span class="line">               if (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        &quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dep + &quot;&#x27;&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               // 注册一下依赖关系</span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               // 先初始化被依赖项</span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 如果是 singleton scope 的，创建 singleton 的实例</span><br><span class="line">         if (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public Object getObject() throws BeansException &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                     // 执行创建 Bean，详情后面再说</span><br><span class="line">                     return createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  catch (BeansException ex) &#123;</span><br><span class="line">                     destroySingleton(beanName);</span><br><span class="line">                     throw ex;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 如果是 prototype scope 的，创建 prototype 的实例</span><br><span class="line">         else if (mbd.isPrototype()) &#123;</span><br><span class="line">            // It&#x27;s a prototype -&gt; create a new instance.</span><br><span class="line">            Object prototypeInstance = null;</span><br><span class="line">            try &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               // 执行创建 Bean</span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span><br><span class="line">         else &#123;</span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">            if (scope == null) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;No Scope registered for scope name &#x27;&quot; + scopeName + &quot;&#x27;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">               Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public Object getObject() throws BeansException &#123;</span><br><span class="line">                     beforePrototypeCreation(beanName);</span><br><span class="line">                     try &#123;</span><br><span class="line">                        // 执行创建 Bean</span><br><span class="line">                        return createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     finally &#123;</span><br><span class="line">                        afterPrototypeCreation(beanName);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IllegalStateException ex) &#123;</span><br><span class="line">               throw new BeanCreationException(beanName,</span><br><span class="line">                     &quot;Scope &#x27;&quot; + scopeName + &quot;&#x27; is not active for the current thread; consider &quot; +</span><br><span class="line">                     &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span><br><span class="line">   if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (TypeMismatchException ex) &#123;</span><br><span class="line">         if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Failed to convert bean &#x27;&quot; + name + &quot;&#x27; to required type &#x27;&quot; +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + &quot;&#x27;&quot;, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return (T) bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p><p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p><p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MessageServiceImpl implements MessageService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return userService.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p><p>好了，读者要知道这么回事就可以了，继续向前。</p><p>&#x2F;&#x2F; AbstractAutowireCapableBeanFactory 447</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Central method of this class: creates a bean instance,</span><br><span class="line"> * populates the bean instance, applies post-processors, etc.</span><br><span class="line"> * @see #doCreateBean</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;</span><br><span class="line">   if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(&quot;Creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">   // 确保 BeanDefinition 中的 Class 被加载</span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class="line">      mbdToUse = new RootBeanDefinition(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; </span><br><span class="line">   // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span><br><span class="line">   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span><br><span class="line">   try &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span><br><span class="line">      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过</span><br><span class="line">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      if (bean != null) &#123;</span><br><span class="line">         return bean; </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   // 重头戏，创建 bean</span><br><span class="line">   Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">   if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建-Bean"><a href="#创建-Bean" class="headerlink" title="创建 Bean"></a>创建 Bean</h4><p>我们继续往里看 doCreateBean 这个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Actually create the specified bean. Pre-creation processing has already happened</span><br><span class="line"> * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks.</span><br><span class="line"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span><br><span class="line"> * factory method, and autowiring a constructor.</span><br><span class="line"> * @param beanName the name of the bean</span><br><span class="line"> * @param mbd the merged bean definition for the bean</span><br><span class="line"> * @param args explicit arguments to use for constructor or factory method invocation</span><br><span class="line"> * @return a new instance of the bean</span><br><span class="line"> * @throws BeanCreationException if the bean could not be created</span><br><span class="line"> * @see #instantiateBean</span><br><span class="line"> * @see #instantiateUsingFactoryMethod</span><br><span class="line"> * @see #autowireConstructor</span><br><span class="line"> */</span><br><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</span><br><span class="line">      throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   // Instantiate the bean.</span><br><span class="line">   BeanWrapper instanceWrapper = null;</span><br><span class="line">   if (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   if (instanceWrapper == null) &#123;</span><br><span class="line">      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 &quot;bean 实例&quot;</span><br><span class="line">   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class="line">   // 类型</span><br><span class="line">   Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</span><br><span class="line">   mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span><br><span class="line">   synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">      if (!mbd.postProcessed) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  &quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = true;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">   // even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span><br><span class="line">   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   if (earlySingletonExposure) &#123;</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">               &quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public Object getObject() throws BeansException &#123;</span><br><span class="line">            return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Initialize the bean instance.</span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   try &#123;</span><br><span class="line">      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      if (exposedObject != null) &#123;</span><br><span class="line">         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span><br><span class="line">         // 这里就是处理 bean 初始化完成后的各种回调</span><br><span class="line">         exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         throw (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         throw new BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (earlySingletonExposure) &#123;</span><br><span class="line">      // </span><br><span class="line">      Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">      if (earlySingletonReference != null) &#123;</span><br><span class="line">         if (exposedObject == bean) &#123;</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">            for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                     &quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +</span><br><span class="line">                     &quot;wrapped. This means that said other beans do not use the final version of the &quot; +</span><br><span class="line">                     &quot;bean. This is often the result of over-eager type matching - consider using &quot; +</span><br><span class="line">                     &quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Register bean as disposable.</span><br><span class="line">   try &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      throw new BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p><p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。</p><p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p><h5 id="创建-Bean-实例"><a href="#创建-Bean-实例" class="headerlink" title="创建 Bean 实例"></a>创建 Bean 实例</h5><p>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123;</span><br><span class="line">   // 确保已经加载了此 class</span><br><span class="line">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">   // 校验一下这个类的访问权限</span><br><span class="line">   if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">            &quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (mbd.getFactoryMethodName() != null)  &#123;</span><br><span class="line">      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean</span><br><span class="line">      return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 如果不是第一次创建，比如第二次创建 prototype bean。</span><br><span class="line">   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span><br><span class="line">   boolean resolved = false;</span><br><span class="line">   boolean autowireNecessary = false;</span><br><span class="line">   if (args == null) &#123;</span><br><span class="line">      synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">         if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">            resolved = true;</span><br><span class="line">            autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   if (resolved) &#123;</span><br><span class="line">      if (autowireNecessary) &#123;</span><br><span class="line">         // 构造函数依赖注入</span><br><span class="line">         return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         // 无参构造函数</span><br><span class="line">         return instantiateBean(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 判断是否采用有参构造函数</span><br><span class="line">   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">   if (ctors != null ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">      // 构造函数依赖注入</span><br><span class="line">      return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 调用无参构造函数</span><br><span class="line">   return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      Object beanInstance;</span><br><span class="line">      final BeanFactory parent = this;</span><br><span class="line">      if (System.getSecurityManager() != null) &#123;</span><br><span class="line">         beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object run() &#123;</span><br><span class="line"></span><br><span class="line">               return getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         // 实例化</span><br><span class="line">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">      &#125;</span><br><span class="line">      // 包装一下，返回</span><br><span class="line">      BeanWrapper bw = new BeanWrapperImpl(beanInstance);</span><br><span class="line">      initBeanWrapper(bw);</span><br><span class="line">      return bw;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      throw new BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到，关键的地方在于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里会进行实际的实例化过程，我们进去看看:</p><p>&#x2F;&#x2F; SimpleInstantiationStrategy 59</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123;</span><br><span class="line"></span><br><span class="line">   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span><br><span class="line">   // 方法覆写 请参见附录&quot;方法注入&quot;中对 lookup-method 和 replaced-method 的介绍</span><br><span class="line">   if (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">      Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">      synchronized (bd.constructorArgumentLock) &#123;</span><br><span class="line">         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">         if (constructorToUse == null) &#123;</span><br><span class="line">            final Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">            if (clazz.isInterface()) &#123;</span><br><span class="line">               throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">               if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">                     @Override</span><br><span class="line">                     public Constructor&lt;?&gt; run() throws Exception &#123;</span><br><span class="line">                        return clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">               else &#123;</span><br><span class="line">                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">               &#125;</span><br><span class="line">               bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">               throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 利用构造方法进行实例化</span><br><span class="line">      return BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span><br><span class="line">      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持</span><br><span class="line">      return instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。</p><h5 id="bean-属性注入"><a href="#bean-属性注入" class="headerlink" title="bean 属性注入"></a>bean 属性注入</h5><p>看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。</p><p>&#x2F;&#x2F; AbstractAutowireCapableBeanFactory 1203</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line">   // bean 实例的所有属性都在这里了</span><br><span class="line">   PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">   if (bw == null) &#123;</span><br><span class="line">      if (!pvs.isEmpty()) &#123;</span><br><span class="line">         throw new BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         // Skip property population phase for null instance.</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span><br><span class="line">   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span><br><span class="line">   // 我也没找到有实际的使用，所以我们暂且忽略这块吧</span><br><span class="line">   boolean continueWithPropertyPopulation = true;</span><br><span class="line">   if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span><br><span class="line">            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = false;</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span><br><span class="line">      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 通过类型装配。复杂一些</span><br><span class="line">      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   if (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      if (hasInstAwareBpps) &#123;</span><br><span class="line">         for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span><br><span class="line">               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span><br><span class="line">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               if (pvs == null) &#123;</span><br><span class="line">                  return;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (needsDepCheck) &#123;</span><br><span class="line">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 设置 bean 实例的属性值</span><br><span class="line">   applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h5><p>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">   if (System.getSecurityManager() != null) &#123;</span><br><span class="line">      AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public Object run() &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            return null;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Object wrappedBean = bean;</span><br><span class="line">   if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">      // BeanPostProcessor 的 postProcessBeforeInitialization 回调</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      // 处理 bean 中定义的 init-method，</span><br><span class="line">      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      throw new BeanCreationException(</span><br><span class="line">            (mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">            beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">      // BeanPostProcessor 的 postProcessAfterInitialization 回调</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   return wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="id-和-name"><a href="#id-和-name" class="headerlink" title="id 和 name"></a>id 和 name</h3><p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p><p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.getBean(&quot;beanName or alias&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;messageService&quot; name=&quot;m1, m2, m3&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;m1, m2, m3&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>beanName 为：com.javadoop.example.MessageServiceImpl#0，</p><p>别名 1 个，为： com.javadoop.example.MessageServiceImpl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 messageService，没有别名。</p><h3 id="配置是否允许-Bean-覆盖、是否允许循环依赖"><a href="#配置是否允许-Bean-覆盖、是否允许循环依赖" class="headerlink" title="配置是否允许 Bean 覆盖、是否允许循环依赖"></a>配置是否允许 Bean 覆盖、是否允许循环依赖</h3><p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p><p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p><p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p><p>添加这两个属性的作者 Juergen Hoeller 在这个 <a href="https://jira.spring.io/browse/SPR-4374">jira</a> 的讨论中说明了怎么配置这两个属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class NoBeanOverridingContextLoader extends ContextLoader &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) &#123;</span><br><span class="line">    super.customizeContext(servletContext, applicationContext);</span><br><span class="line">    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;</span><br><span class="line">    arac.setAllowBeanDefinitionOverriding(false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected ContextLoader createContextLoader() &#123;</span><br><span class="line">    return new NoBeanOverridingContextLoader();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;com.javadoop.MyContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">&lt;/listener&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果以上方式不能满足你的需求，请参考这个链接：<a href="http://blog.csdn.net/zgmzyr/article/details/39380477">解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题</a></p><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans profile=&quot;development&quot;</span><br><span class="line">    xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;...&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;</span><br><span class="line">        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;</span><br><span class="line">        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;</span><br><span class="line">    &lt;/jdbc:embedded-database&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans profile=&quot;production&quot;</span><br><span class="line">    xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;...&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>应该不必做过多解释了吧，看每个文件第一行的 profile&#x3D;””。</p><p>当然，我们也可以在一个配置文件中使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;</span><br><span class="line">    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;...&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beans profile=&quot;development&quot;&gt;</span><br><span class="line">        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;</span><br><span class="line">            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;</span><br><span class="line">            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;</span><br><span class="line">        &lt;/jdbc:embedded-database&gt;</span><br><span class="line">    &lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beans profile=&quot;production&quot;&gt;</span><br><span class="line">        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;</span><br><span class="line">    &lt;/beans&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>理解起来也很简单吧。</p><p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p><p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p><p>最简单的方式莫过于在程序启动的时候指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=&quot;profile1,profile2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>profile 可以激活多个</p></blockquote><p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);</span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class="line">ctx.refresh(); // 重启</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Dspring.profiles.active=prod -jar JavaDoop.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。</p><h3 id="工厂模式生成-Bean"><a href="#工厂模式生成-Bean" class="headerlink" title="工厂模式生成 Bean"></a>工厂模式生成 Bean</h3><p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p><p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p><p>静态工厂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    class=&quot;examples.ClientService&quot;</span><br><span class="line">    factory-method=&quot;createInstance&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ClientService &#123;</span><br><span class="line">    private static ClientService clientService = new ClientService();</span><br><span class="line">    private ClientService() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 静态方法</span><br><span class="line">    public static ClientService createInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例工厂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createClientServiceInstance&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;accountService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createAccountServiceInstance&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    private static AccountService accountService = new AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService createClientServiceInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AccountService createAccountServiceInstance() &#123;</span><br><span class="line">        return accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line">    Class&lt;T&gt; getObjectType();</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123; </span><br><span class="line">    private Car car ;</span><br><span class="line">    private void setCar(Car car)&#123; this.car = car;  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;&#123;</span><br><span class="line">    private String make; </span><br><span class="line">    private int year ;</span><br><span class="line"></span><br><span class="line">    public void setMake(String m)&#123; this.make =m ; &#125;</span><br><span class="line"></span><br><span class="line">    public void setYear(int y)&#123; this.year = y; &#125;</span><br><span class="line"></span><br><span class="line">    public Car getObject()&#123; </span><br><span class="line">      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span><br><span class="line">      CarBuilder cb = CarBuilder.car();</span><br><span class="line"></span><br><span class="line">      if(year!=0) cb.setYear(this.year);</span><br><span class="line">      if(StringUtils.hasText(this.make)) cb.setMake( this.make ); </span><br><span class="line">      return cb.factory(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;Car&gt; getObjectType() &#123; return Car.class ; &#125; </span><br><span class="line"></span><br><span class="line">    public boolean isSingleton() &#123; return false; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们看看装配的时候是怎么配置的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class = &quot;com.javadoop.MyCarFactoryBean&quot; id = &quot;car&quot;&gt;</span><br><span class="line">  &lt;property name = &quot;make&quot; value =&quot;Honda&quot;/&gt;</span><br><span class="line">  &lt;property name = &quot;year&quot; value =&quot;1984&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean class = &quot;com.javadoop.Person&quot; id = &quot;josh&quot;&gt;</span><br><span class="line">  &lt;property name = &quot;car&quot; ref = &quot;car&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p><p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java config 的方式来配置，这里有什么不一样呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration </span><br><span class="line">public class CarConfiguration &#123; </span><br><span class="line"></span><br><span class="line">    @Bean </span><br><span class="line">    public MyCarFactoryBean carFactoryBean()&#123; </span><br><span class="line">      MyCarFactoryBean cfb = new MyCarFactoryBean();</span><br><span class="line">      cfb.setMake(&quot;Honda&quot;);</span><br><span class="line">      cfb.setYear(1984);</span><br><span class="line">      return cfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Person aPerson()&#123; </span><br><span class="line">    Person person = new Person();</span><br><span class="line">      // 注意这里的不同</span><br><span class="line">    person.setCar(carFactoryBean().getObject());</span><br><span class="line">    return person; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p><h3 id="初始化-Bean-的回调"><a href="#初始化-Bean-的回调" class="headerlink" title="初始化 Bean 的回调"></a>初始化 Bean 的回调</h3><p>有以下四种方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherExampleBean implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        // do some initialization work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean(initMethod = &quot;init&quot;)</span><br><span class="line">public Foo foo() &#123;</span><br><span class="line">    return new Foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@PostConstruct</span><br><span class="line">public void init() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="销毁-Bean-的回调"><a href="#销毁-Bean-的回调" class="headerlink" title="销毁 Bean 的回调"></a>销毁 Bean 的回调</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherExampleBean implements DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        // do some destruction work (like releasing pooled connections)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean(destroyMethod = &quot;cleanup&quot;)</span><br><span class="line">public Bar bar() &#123;</span><br><span class="line">    return new Bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@PreDestroy</span><br><span class="line">public void cleanup() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p>既然文中说到了这个，顺便提一下好了。</p><p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p><p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;conversionService&quot;</span><br><span class="line">  class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;converters&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">      &lt;bean class=&quot;com.javadoop.learning.utils.StringToEnumConverterFactory&quot;/&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p><p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p><p>来看一个很简单的例子，这样比什么都管用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Date convert(String source) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return DateUtils.parseDate(source, &quot;yyyy-MM-dd&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd HH:mm&quot;, &quot;HH:mm:ss&quot;, &quot;HH:mm&quot;);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p><h3 id="Bean-继承"><a href="#Bean-继承" class="headerlink" title="Bean 继承"></a>Bean 继承</h3><p>在初始化 Bean 的地方，我们说过了这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里涉及到的就是 <code>&lt;bean parent=&quot;&quot; /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p><p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p><p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p><p>看如下一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;inheritedTestBean&quot; abstract=&quot;true&quot; class=&quot;org.springframework.beans.TestBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;inheritsWithDifferentClass&quot; class=&quot;org.springframework.beans.DerivedTestBean&quot;</span><br><span class="line">        parent=&quot;inheritedTestBean&quot; init-method=&quot;initialize&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>parent bean 设置了 <code>abstract=&quot;true&quot;</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p><p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p><p>当然，我不是说 parent bean 中的 abstract &#x3D; true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p><p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract &#x3D; true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;inheritedTestBeanWithoutClass&quot; abstract=&quot;true&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p><p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p><p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p><p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p><h4 id="lookup-method"><a href="#lookup-method" class="headerlink" title="lookup-method"></a>lookup-method</h4><p>我们来看一下 Spring Reference 中提供的一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package fiona.apple;</span><br><span class="line"></span><br><span class="line">// no more Spring imports!</span><br><span class="line"></span><br><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"></span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        // grab a new instance of the appropriate Command interface</span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        // set the state on the (hopefully brand new) Command instance</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // okay... but where is the implementation of this method?</span><br><span class="line">    protected abstract Command createCommand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span><br><span class="line">&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;!-- inject dependencies here as required --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span><br><span class="line">&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt;</span><br><span class="line">    &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring 采用 <strong>CGLIB 生成字节码</strong>的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p><p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"></span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        MyCommand command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Lookup(&quot;myCommand&quot;)</span><br><span class="line">    protected abstract Command createCommand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt;</code></p></blockquote><p>甚至，我们可以像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"></span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        MyCommand command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Lookup</span><br><span class="line">    protected abstract MyCommand createCommand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p></blockquote><h4 id="replaced-method"><a href="#replaced-method" class="headerlink" title="replaced-method"></a>replaced-method</h4><p>记住它的功能，就是替换掉 bean 中的一些方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyValueCalculator &#123;</span><br><span class="line"></span><br><span class="line">    public String computeValue(String input) &#123;</span><br><span class="line">        // some real code...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // some other methods...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法覆写，注意要实现 MethodReplacer 接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer &#123;</span><br><span class="line"></span><br><span class="line">    public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123;</span><br><span class="line">        // get the input value, work with it, and return a computed result</span><br><span class="line">        String input = (String) args[0];</span><br><span class="line">        ...</span><br><span class="line">        return ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置也很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt;</span><br><span class="line">    &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span><br><span class="line">    &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt;</span><br><span class="line">        &lt;arg-type&gt;String&lt;/arg-type&gt;</span><br><span class="line">    &lt;/replaced-method&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p></blockquote><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p><p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p><p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p><p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p><p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p><p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p><p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按理说，总结应该写在附录前面，我就不讲究了。</p><p>在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。</p><p>本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。</p><p>（全文完）</p><p>本文转自 <a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G1垃圾回收器</title>
      <link href="/2020/12/10/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2020/12/10/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="G1-垃圾收集器介绍"><a href="#G1-垃圾收集器介绍" class="headerlink" title="G1 垃圾收集器介绍"></a>G1 垃圾收集器介绍</h1><p><a href="https://javadoop.com/post/download?userName=hongjie&postName=g1"></a></p><p>之前根据 Sun 的内存管理白皮书介绍了在 HotSpot JVM 分代算法中的几个垃圾收集器，本文将介绍 G1 垃圾收集器。</p><p>G1 的主要关注点在于达到<strong>可控的停顿时间</strong>，在这个基础上尽可能提高吞吐量，这一点非常重要。</p><p>G1 被设计用来长期取代 CMS 收集器，和 CMS 相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。</p><p>如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了。</p><p><strong>阅读建议</strong>：本文力求用简单的话介绍清楚 G1 收集器，但是并不会重复介绍每一个细节，所以希望读者了解其他几个收集器的工作过程，尤其是 CMS 收集器。</p><h2 id="G1-总览"><a href="#G1-总览" class="headerlink" title="G1 总览"></a>G1 总览</h2><p>首先是内存划分上，之前介绍的分代收集器将整个堆分为年轻代、老年代和永久代，每个代的空间是确定的。</p><p>而 G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。</p><p><img src="https://www.javadoop.com/blogimages/g1/3.png" alt="1"></p><p>执行垃圾收集时，和 CMS 一样，G1 收集线程在标记阶段和应用程序线程<strong>并发</strong>执行，标记结束后，G1 也就知道哪些区块基本上是垃圾，存活对象极少，G1 会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间，<strong>这也是为什么 G1 被取名为 Garbage-First 的原因</strong>。</p><blockquote><p>这里只不过是先介绍些概念，没看懂没关系，往下看</p></blockquote><p>在 G1 中，目标停顿时间非常非常重要，用 -XX:MaxGCPauseMillis&#x3D;200 指定期望的停顿时间。</p><p>G1 使用了<strong>停顿预测模型</strong>来满足用户指定的停顿时间目标，并基于目标来选择进行垃圾回收的区块数量。G1 采用增量回收的方式，每次回收一些区块，而不是整堆回收。</p><p>我们要知道 G1 不是一个实时收集器，它会尽力满足我们的停顿时间要求，但也不是绝对的，它基于之前垃圾收集的数据统计，估计出在用户指定的停顿时间内能收集多少个区块。</p><p><strong>注意：</strong>G1 有和应用程序一起运行的并发阶段，也有 stop-the-world 的并行阶段。但是，<strong>Full GC 的时候还是单线程运行的</strong>，所以我们应该尽量避免发生 Full GC，后面我们也会介绍什么时候会触发 Full GC。</p><p><strong>G1 内存占用</strong></p><p>G1 比 ParallelOld 和 CMS 会需要更多的内存消耗，那是因为有部分内存消耗于簿记（accounting）上，如以下两个数据结构：</p><ul><li><strong>Remembered Sets</strong>：每个区块都有一个 RSet，用于记录进入该区块的对象引用（如区块 A 中的对象引用了区块 B，区块 B 的 Rset 需要记录这个信息），它用于实现收集过程的并行化以及使得区块能进行独立收集。总体上 Remembered Sets 消耗的内存小于 5%。</li><li><strong>Collection Sets</strong>：将要被回收的区块集合。GC 时，在这些区块中的对象会被复制到其他区块中，总体上 Collection Sets 消耗的内存小于 1%。</li></ul><h2 id="G1-工作流程"><a href="#G1-工作流程" class="headerlink" title="G1 工作流程"></a>G1 工作流程</h2><p>前面啰里啰嗦说了挺多的，唯一要记住的就是，G1 的设计目标就是尽力满足我们的目标停顿时间上的要求。</p><p>本节介绍 G1 的收集过程，G1 收集器主要包括了以下 4 种操作：</p><ul><li>1、年轻代收集</li><li>2、并发收集，和应用线程同时执行</li><li>3、混合式垃圾收集</li><li>*、必要时的 Full GC</li></ul><p>接下来，我们进行一一介绍。</p><h3 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a>年轻代收集</h3><p>首先，我们来看下 G1 的堆结构：</p><p><img src="https://www.javadoop.com/blogimages/g1/1.png" alt="3"></p><p>年轻代中的垃圾收集流程（Young GC）：</p><p><img src="https://www.javadoop.com/blogimages/g1/2.png" alt="4"></p><p>我们可以看到，年轻代收集概念上和之前介绍的其他分代收集器大差不差的，但是它的年轻代会动态调整。</p><h3 id="Old-GC-x2F-并发标记周期"><a href="#Old-GC-x2F-并发标记周期" class="headerlink" title="Old GC &#x2F; 并发标记周期"></a>Old GC &#x2F; 并发标记周期</h3><p>接下来是 Old GC 的流程（含 Young GC 阶段），其实把 Old GC 理解为<strong>并发周期</strong>是比较合理的，不要单纯地认为是清理老年代的区块，因为这一步和年轻代收集也是相关的。下面我们介绍主要流程：</p><ol><li><p>初始标记：stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用。</p><blockquote><p>因为 Young GC 是需要 stop-the-world 的，所以并发周期直接重用这个阶段，虽然会增加 CPU 开销，但是停顿时间只是增加了一小部分。</p></blockquote></li><li><p>扫描根引用区：因为先进行了一次 YGC，所以当前年轻代只有 Survivor 区有存活对象，它被称为根引用区。扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束。</p><blockquote><p>这个阶段不能发生年轻代收集，如果中途 Eden 区真的满了，也要等待这个阶段结束才能进行 Young GC。</p></blockquote></li><li><p>并发标记：寻找整个堆的存活对象，该阶段可以被 Young GC 中断。</p><blockquote><p>这个阶段是并发执行的，中间可以发生多次 Young GC，Young GC 会中断标记过程</p></blockquote></li><li><p>重新标记：stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法。</p><blockquote><p>Oracle 的资料显示，这个阶段会回收完全空闲的区块</p></blockquote></li><li><p>清理：清理阶段真正回收的内存很少。</p></li></ol><p>到这里，G1 的一个并发周期就算结束了，其实就是主要完成了垃圾定位的工作，定位出了哪些分区是垃圾最多的。因为整堆一般比较大，所以这个周期应该会比较长，中间可能会被多次 stop-the-world 的 Young GC 打断。</p><h3 id="混合垃圾回收周期"><a href="#混合垃圾回收周期" class="headerlink" title="混合垃圾回收周期"></a>混合垃圾回收周期</h3><p>并发周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。</p><p>混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>到这里我们已经说了年轻代收集、并发周期、混合回收周期了，大家要熟悉这几个阶段的工作。</p><p>下面我们来介绍特殊情况，那就是会导致 <strong>Full GC</strong> 的情况，也是我们需要极力避免的：</p><ol><li><p>concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记。</p><blockquote><p>这个时候说明</p><ul><li>堆需要增加了，</li><li>或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束</li><li>或者就是更早地进行并发周期，默认是整堆内存的 45% 被占用就开始进行并发周期。</li></ul></blockquote></li><li><p>晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败。</p><blockquote><p>说明混合垃圾回收需要更迅速完成垃圾收集，也就是说在混合回收阶段，每次年轻代的收集应该处理更多的老年代已标记区块。</p></blockquote></li><li><p>疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的。</p><blockquote><p>最简单的就是增加堆大小</p></blockquote></li><li><p>大对象分配失败，我们应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象。</p></li></ol><h3 id="简单小结"><a href="#简单小结" class="headerlink" title="简单小结"></a>简单小结</h3><p>看完上面的 Young GC 和 Old GC 等，很多读者可能还是很懵的，这里说几句不严谨的白话文帮助读者进行理解：</p><p>首先，最好不要把上面的 Old GC 当做是一次 GC 来看，而应该当做<strong>并发标记周期</strong>来理解，虽然它确实会释放出一些内存。</p><p>并发标记结束后，G1 也就知道了哪些区块是最适合被回收的，那些完全空闲的区块会在这这个阶段被回收。如果这个阶段释放了足够的内存出来，其实也就可以认为结束了一次 GC。</p><p>我们假设并发标记结束了，那么下次 GC 的时候，还是会先回收年轻代，如果从年轻代中得到了足够的内存，那么结束；过了几次后，年轻代垃圾收集不能满足需要了，那么就需要利用之前并发标记的结果，选择一些活跃度最低的老年代区块进行回收。直到最后，老年代会进入下一个并发周期。</p><p>那么什么时候会启动并发标记周期呢？这个是通过参数控制的，下面马上要介绍这个参数了，此参数默认值是 45，也就是说当堆空间使用了 45% 后，G1 就会进入并发标记周期。</p><h2 id="G1-参数配置和最佳实践"><a href="#G1-参数配置和最佳实践" class="headerlink" title="G1 参数配置和最佳实践"></a>G1 参数配置和最佳实践</h2><p>G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间。</p><p>有以下几点我们可以进行调整的方向：</p><ul><li>增加堆大小，或调整老年代和年轻代的比例，这个很好理解</li><li>增加并发周期的线程数量，其实就是为了加快并发周期快点结束</li><li>让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%）</li><li>在混合垃圾回收周期中回收更多的老年代区块</li></ul><p>G1 的很重要的目标是达到可控的停顿时间，所以很多的行为都以这个目标为出发点开展的。</p><p>我们通过设置 -XX:MaxGCPauseMillis&#x3D;N 来指定停顿时间（单位 ms，默认 200ms），如果没有达到这个目标，G1 会通过各种方式来补救：调整年轻代和老年代的比例，调整堆大小，调整晋升的年龄阈值，调整混合垃圾回收周期中处理的老年代的区块数量等等。</p><p>当然了，调整每个参数满足了一个条件的同时往往也会引入另一个问题，比如为了降低停顿时间，我们可以减小年轻代的大小，可是这样的话就会增加年轻代垃圾收集的频率。如果我们减少混合垃圾回收周期处理的老年代区块数量，虽然可以更容易满足停顿时间要求，可是这样就会增加 Full GC 的风险等等。</p><p>下面介绍最常用也是最基础的一些参数的设置，涉及到更高级的调优参数设置，请读者自行参阅其他资料。</p><p><strong>参数介绍</strong>：</p><ul><li><p><strong>-XX:+UseG1GC</strong></p><p>使用 G1 收集器</p></li><li><p><strong>-XX:MaxGCPauseMillis&#x3D;200</strong></p><p>指定目标停顿时间，默认值 200 毫秒。</p><blockquote><p>在设置 -XX:MaxGCPauseMillis 值的时候，不要指定为平均时间，而应该指定为满足 90% 的停顿在这个时间之内。记住，停顿时间目标是我们的目标，不是每次都一定能满足的。</p></blockquote></li><li><p><strong>-XX:InitiatingHeapOccupancyPercent&#x3D;45</strong></p><p>整堆使用达到这个比例后，触发并发 GC 周期，默认 45%。</p><blockquote><p>如果要降低晋升失败的话，通常可以调整这个数值，使得并发周期提前进行</p></blockquote></li><li><p><strong>-XX:NewRatio&#x3D;n</strong></p><p>老年代&#x2F;年轻代，默认值 2，即 1&#x2F;3 的年轻代，2&#x2F;3 的老年代</p><blockquote><p>不要设置年轻代为固定大小，否则：</p><ul><li>G1 不再需要满足我们的停顿时间目标</li><li>不能再按需扩容或缩容年轻代大小</li></ul></blockquote></li><li><p><strong>-XX:SurvivorRatio&#x3D;n</strong></p><p>Eden&#x2F;Survivor，默认值 8，这个和其他分代收集器是一样的</p></li><li><p><strong>-XX:MaxTenuringThreshold &#x3D;n</strong></p><p>从年轻代晋升到老年代的年龄阈值，也是和其他分代收集器一样的</p></li><li><p><strong>-XX:ParallelGCThreads&#x3D;n</strong></p><p>并行收集时候的垃圾收集线程数</p></li><li><p><strong>-XX:ConcGCThreads&#x3D;n</strong></p><p>并发标记阶段的垃圾收集线程数</p><blockquote><p>增加这个值可以让并发标记更快完成，如果没有指定这个值，JVM 会通过以下公式计算得到：</p><p>ConcGCThreads&#x3D;(ParallelGCThreads + 2) &#x2F; 4^3</p></blockquote></li><li><p><strong>-XX:G1ReservePercent&#x3D;n</strong></p><p>堆内存的预留空间百分比，默认 10，用于降低晋升失败的风险，即默认地会将 10% 的堆内存预留下来。</p></li><li><p><strong>-XX:G1HeapRegionSize&#x3D;n</strong></p><p>每一个 region 的大小，默认值为根据堆大小计算出来，取值 1MB~32MB，这个我们通常指定整堆大小就好了。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我自己仔细检查了几遍，主要内容都囊括了，我也不知道读者看完本文会不会是一脸懵逼。</p><p>如果有什么问题，可以在留言板上给我留言，<strong>我是 GC 的门外汉</strong>，如果有些问题我觉得自己能解答，我会尽力帮助大家。</p><p>最后，在这里推荐一些资料给感兴趣的读者：</p><p>Oracle 官方出品，本文的很多内容是翻译并解读这篇文章的：</p><p><a href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">Getting Started with the G1 Garbage Collector</a></p><p>帮助大家理解 G1 的日志：</p><p><a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs">Understanding G1 GC Logs</a></p><p>这里介绍 GC 的内容非常好：</p><p><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1">https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1</a></p><p>《Java 性能权威指南》：非常好的一本书，建议读者有时间可以看看这本书中关于 GC 的介绍。</p><p>（全文完）</p><p>本文转自 <a href="https://javadoop.com/post/g1">https://javadoop.com/post/g1</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 垃圾回收 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMS垃圾回收器</title>
      <link href="/2020/10/10/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/10/10/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h2><blockquote><p>CMS叫做并发标记清除。<br>用CMS对比 Seria和Parallel 和 ParNew ：最大的的不同点就是并发：在GC线程工作的时候，用户线程不会完全停止，用户线程在部分场景下与GC线程一起并发执行。<br>CMS设计目标：避免老年代长时间卡顿。</p></blockquote><p>CMS分为5个步骤：初始标记，并发标记，并发预清理，重新标记，以及并发清除。<br>不难看出cms，使用了【标记清除】垃圾回收算法</p><ul><li>初始标记 ：会标记GCroots直接关联的对象和年轻代指向老年代的对象，过程比较快，初始标记这个过程是会发生stw。</li></ul><p>为什么要扫描年轻代，因为回收老年代，年轻代可能会指向老年代。</p><ul><li>并发标记：这个过程是不会停止用户线程的（stw），这一阶段主要进行可达性分析，因为要追溯所以比较耗时间。</li><li>并发预清理：希望能减少下一个阶段【重新标记】的时间，因为上一个阶段【并发标记】线程是没有被挂起的，导致对象之间和对象本身的root发生了改变，有几种情况<ul><li>新生代变成了老年代</li><li>有些对象直接分到了老年代</li><li>老年代和新生代之间对象引用发生了变化<br>针对老年代的对象可以借助card table存储，将老年代发生的卡页标记为dirty，所以并发预处理会再扫描一遍标记为dirty的卡页<br>对于新生代的的对象我们还得遍历新生代来看看在并发标记有没有对象引用到老年代，有可能在这里会触发minor gc</li></ul></li><li>重新标记：会stw，停顿时间取决于上面的并发预处理<br>可以发现这是一个追赶的过程，一边标记存货对象，一边用户线程在执行产生垃圾</li><li>并发清除：不会stw，一边用户在执行，一边GC线程在回收不可达的对象</li></ul><p>整个过程还是有可能在不断产生垃圾，只能留到下次处理。产生的垃圾叫做浮动垃圾。完了之后会重置cms算法相关的内部数据，为下一次gc做准备</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实就是把垃圾回收过程细分了，然后在某个阶段不停止用户线程，一边回收垃圾，一边处理请求，来减少每次垃圾回收时stw的时间。<br>当然中间也有很多优化，dirty card 标记，可能途中触发minor gc 等等，这些都提供了相应的cms参数。<br>两个缺点：<br>1、空间需要预留。<br>2、内存碎片问题。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 垃圾回收 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized和reentrantlock区别</title>
      <link href="/2020/10/06/synchronized%E5%92%8Creentrantlock%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/10/06/synchronized%E5%92%8Creentrantlock%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候</p><pre><code> 线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定， 如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断 如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情ReentrantLock获取锁定与三种方式：  a)  lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁b) tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；c)**tryLock**(long timeout,[TimeUnit](http://houlinyan.iteye.com/java/util/concurrent/TimeUnit.html &quot;java.util.concurrent 中的枚举&quot;) unit)，   如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；d) lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断</code></pre><p>2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中</p><p>3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</p><p>5.0的多线程任务包对于同步的性能方面有了很大的改进，在原有synchronized关键字的基础上，又增加了ReentrantLock，以及各种Atomic类。了解其性能的优劣程度，有助与我们在特定的情形下做出正确的选择。</p><p>总体的结论先摆出来：</p><p>synchronized：<br>在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好，不管用没用过5.0多线程包的程序员都能理解。</p><p>ReentrantLock:<br>ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。</p><p>Atomic:<br>和上面的类似，不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。</p><p>所以，我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化。ReentrantLock和Atomic如果用的不好，不仅不能提高性能，还可能带来灾难。</p><h3 id="补充两者唤醒线程方式-线程切换"><a href="#补充两者唤醒线程方式-线程切换" class="headerlink" title="补充两者唤醒线程方式+线程切换"></a>补充两者唤醒线程方式+线程切换</h3><p>只要线程可以在30到50次自旋里拿到锁,那么Synchronized就不会升级为重量级锁,而等待的线程也就不用被挂起,我们也就少了挂起和唤醒这个上下文切换的过程开销.</p><p>但如果是ReentrantLock呢?不会自旋,而是直接被挂起,这样一来,我们就很容易会多出线程上下文开销的代价.当然,你也可以使用tryLock(),但是这样又出现了一个问题,你怎么知道tryLock的时间呢?在时间范围里还好,假如超过了呢?</p><p>所以,在锁被细化到如此程度上,使用Synchronized是最好的选择了.这里再补充一句,Synchronized和ReentrantLock他们的开销差距是在释放锁时唤醒线程的数量,Synchronized是唤醒锁池里所有的线程+刚好来访问的线程,而ReentrantLock则是当前线程后进来的第一个线程+刚好来访问的线程.</p><p>如果是线程并发量不大的情况下,那么Synchronized因为自旋锁,偏向锁,轻量级锁的原因,不用将等待线程挂起,偏向锁甚至不用自旋,所以在这种情况下要比ReentrantLock高效。</p><h3 id="补充两者为什么默认都是非公平锁"><a href="#补充两者为什么默认都是非公平锁" class="headerlink" title="补充两者为什么默认都是非公平锁"></a>补充两者为什么默认都是非公平锁</h3><p>ReentrantLock公平和非公平锁的队列都基于锁内部维护的一个双向链表，表结点Node的值就是每一个请求当前锁的线程。</p><p>公平锁则在于每次都是依次从队首取值，严格按照线程启动的顺序来执行的，不允许插队。</p><p>非公平锁在等待锁的过程中， 如果有任意新的线程妄图获取锁，都是有很大的几率直接获取到锁的，允许插队。</p><p>默认情况下ReentrantLock是通过非公平锁来进行同步的，包括synchronized关键字都是如此，因为这样性能会更好。因为从线程进入了RUNNABLE状态，可以执行开始，到实际线程执行是要比较久的时间的。而且，在一个锁释放之后，其他的线程会需要重新来获取锁。其中经历了持有锁的线程释放锁，其他线程从挂起恢复到RUNNABLE状态，其他线程请求锁，获得锁，线程执行，这一系列步骤。如果这个时候，存在一个线程直接请求锁，可能就避开挂起到恢复RUNNABLE状态的这段消耗，所以性能更优化。</p><p>本文转自 <a href="https://www.cnblogs.com/fanguangdexiaoyuer/p/5313653.html">https://www.cnblogs.com/fanguangdexiaoyuer/p/5313653.html</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈ArrayList</title>
      <link href="/2020/06/10/ArrayList%E5%BA%95%E5%B1%82/"/>
      <url>/2020/06/10/ArrayList%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈ArrayList"><a href="#浅谈ArrayList" class="headerlink" title="浅谈ArrayList"></a>浅谈ArrayList</h1><p><strong>ArrayList类</strong>又称动态数组，同时实现了Collection和List接口，其内部数据结构由数组实现，因此可对容器内元素实现快速随机访问。但因为ArrayList中插入或删除一个元素需要移动其他元素，所以不适合在插入和删除操作频繁的场景下使用。</p><p>ArrayList的容量可以随着元素的增加而自动增加，因此不用担心ArrayList容量不足的问题。</p><p>ArrayList是非线程安全的。</p><p>接下来，我们将解析ArrayList的构造方法，在看构造方法之前，我们先来明确一下ArrayList源码中的一些概念。这些变量和对象大家可能有疑惑，先记住就好了，后面会看到它们的用途。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 默认的容量大小（常量）</span><br><span class="line">private static final int DEFAULT\_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">// 定义的空数组（final修饰，大小固定为0）</span><br><span class="line">private static final Object\[\] EMPTY\_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 定义的默认空容量的数组（final修饰，大小固定为0）</span><br><span class="line">private static final Object\[\] DEFAULTCAPACITY\_EMPTY\_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 定义的不可被序列化的数组，实际存储元素的数组</span><br><span class="line">transient Object\[\] elementData; </span><br><span class="line"></span><br><span class="line">// 数组中元素的个数</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure><p>ArrayList有三种构造方法:</p><p>1.无参的构造方法</p><p>2.根据传入的数值大小，创建指定长度的数组</p><p>3.通过传入Collection元素列表进行生成</p><h2 id="1-无参的构造方法"><a href="#1-无参的构造方法" class="headerlink" title="1.无参的构造方法"></a>1.无参的构造方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 无参的构造方法</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY\_EMPTY\_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，当我们直接创建ArrayList时，elementData被赋予了默认空容量的数组。注意，因为默认空容量数组是被final修饰的，此时ArrayList数组是空的、固定长度的，也就是说其容量此时是0，元素个数size为默认值0。</p><h2 id="2-根据传入的数值大小，创建指定长度的数组"><a href="#2-根据传入的数值大小，创建指定长度的数组" class="headerlink" title="2.根据传入的数值大小，创建指定长度的数组"></a>2.根据传入的数值大小，创建指定长度的数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 传容量的构造方法</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object\[initialCapacity\];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY\_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当initialCapacity &gt; 0时，会在堆上new一个大小为initialCapacity的数组，然后将其引用赋给elementData，此时ArrayList的容量为initialCapacity，元素个数size为默认值0。</p><p>当initialCapacity &#x3D; 0时，elementData被赋予了默认空数组，因为其被final修饰了，所以此时ArrayList的容量为0，元素个数size为默认值0。</p><p>当initialCapacity &lt; 0时，会抛出异常。</p><h2 id="3-通过传入Collection元素列表进行生成"><a href="#3-通过传入Collection元素列表进行生成" class="headerlink" title="3.通过传入Collection元素列表进行生成"></a>3.通过传入Collection元素列表进行生成</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 传入Collection元素列表的构造方法</span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    // 将列表转化为对应的数组</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    if ((size = elementData.length) != 0) &#123;</span><br><span class="line">        // 此处见下面详细解析</span><br><span class="line">        if (elementData.getClass() != Object\[\].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object\[\].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 赋予空数组</span><br><span class="line">        this.elementData = EMPTY\_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入Collection元素列表后，构造方法首先会将其转化为数组，将其索引赋给elementData。</p><p>如果此数组的长度为0，会重新赋予elementData为空数组，此时ArrayList的容量是0，元素个数size为0。</p><p>如果此数组的长度大于0，会更新size的大小为其长度，也就是元素的个数，然后执行里面的程序。大家对里面的代码可能不理解，让我们等会看下面解析。执行完后此时ArrayList的容量为传入序列的长度，也就是size的大小，同时元素个数也为size，也就是说，此时ArrayList是满的。</p><p>让我们来看看下面的代码，然后再去理解上面 if 语句的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String\[\] args) &#123;</span><br><span class="line">        // 1.创建Student对象数组</span><br><span class="line">        Student\[\] students = new Student\[\] &#123;</span><br><span class="line">                new Student(&quot;小明&quot;, 18),</span><br><span class="line">                new Student(&quot;小李&quot;, 19),</span><br><span class="line">                new Student(&quot;小张&quot;, 21)</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        // 2.将其赋值给Object对象数组</span><br><span class="line">        Object\[\] objects = students;</span><br><span class="line">        </span><br><span class="line">        // 3.执行if语句前，打印数组的class</span><br><span class="line">        System.out.println(&quot;执行前：&quot; + objects.getClass());</span><br><span class="line">        </span><br><span class="line">        // 4.执行上面的代码</span><br><span class="line">        if (objects.getClass() != Object\[\].class) &#123;</span><br><span class="line">            objects \= Arrays.copyOf(objects, objects.length, Object\[\].class);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 5.执行if语句后，打印数组的class</span><br><span class="line">        System.out.println(&quot;执行后：&quot; + objects.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果如下：</p><p><img src="https://img2020.cnblogs.com/blog/2123988/202009/2123988-20200922191354245-68689372.png"></p><p>可以看到，对象数组也是有.class的，其中含有所存储元素的类型，而上面的那段代码的作用就是将原对象数组的数组类型转化为Object对象数组的数组类型，以便更好的存储。</p><h1 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h1><p>当我们探讨扩容时，肯定要从ArrayList的add方法走起，让我们来看看吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最基本的add方法，当然，也是可以说明问题的。可以看到，此add方法的参数就是一个被加元素，moCount是记录ArrayList被修改次数的，可以不用管。然后是另一个add方法，所传的值是被加元素、当前数组和当前数组的元素个数，让我们来看看这个add方法吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void add(E e, Object\[\] elementData, int s) &#123;</span><br><span class="line">    // 判断元素个数是否等于当前容量</span><br><span class="line">    if (s == elementData.length)</span><br><span class="line">        elementData \= grow();</span><br><span class="line">    elementData\[s\] \= e;</span><br><span class="line">    size \= s + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，它判断了元素个数是否等于当前数组的容量，也就是判断当前数组是不是满的，如果当前空间是满的，就需要扩容了，grow函数就是扩容函数了，扩容后再将被加元素加到数组中。</p><p>下面我们来看看grow函数是什么样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Object\[\] grow() &#123;</span><br><span class="line">    return grow(size + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它里面又调用了一个带参的grow函数，参数是当前元素个数+1，也就是当前容量+1。返回的是这个函数的返回值，让我们进一步研究这个带参的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private Object\[\] grow(int minCapacity) &#123;</span><br><span class="line">    // 获取老容量，也就是当前容量</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    // 如果当前容量大于0 或者 数组不是DEFAULTCAPACITY\_EMPTY\_ELEMENTDATA</span><br><span class="line">    if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY\_EMPTY\_ELEMENTDATA) &#123;</span><br><span class="line">        int newCapacity = ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                minCapacity \- oldCapacity, /\* minimum growth \*/</span><br><span class="line">                oldCapacity \&gt;&gt; 1           /\* preferred growth \*/);</span><br><span class="line">        return elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    // 如果 数组是DEFAULTCAPACITY\_EMPTY\_ELEMENTDATA（容量等于0的话，只剩这一种情况了）</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return elementData = new Object\[Math.max(DEFAULT\_CAPACITY, minCapacity)\];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，它是记录了一下老容量的大小，然后再进行下面的操作。</p><p>如果当前容量大于0，或者当前数组不是DEFAULTCAPACITY_EMPTY_ELEMENTDATA，前面说明过，DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个被final修饰的空数组，在三个构造方法中，只有无参构造方法中elementData被赋予了DEFAULTCAPACITY_EMPTY_ELEMENTDATA。也就是说，这个if语句中不会处理用默认无参构造方法创建的数组的初始扩容情况，那么其余的扩容情况都是由此if语句来处理的。</p><p>我们来看一下if里面的操作，先创建一个新的数组，然后将旧数组拷贝到新数组并赋给elementData返回。ArraysSupport.newLength函数的作用是创建一个大小为oldCapacity + max（minimum growth， preferred growth）的数组。</p><p>minCapacity是传入的参数，我们上面看过，它的值是当前容量（老容量）+1，那么minCapacity - oldCapacity的值就恒为1，minimum growth的值也就恒为1。</p><p>oldCapacity &gt;&gt; 1的功能是将oldCapacity 进行位运算，右移一位，也就是减半，preferred growth的值即为oldCapacity大小的一半。</p><p>扩容分析：</p><p>当oldCapacity为0时，右移后还是0，也就是说此时扩容的大小为0+max（1,0）&#x3D;1，容量从0扩展到1。那么什么时候是这种情况呢？</p><p>（1）传容量的构造方法传入的是0时，elementData被赋予的是EMPTY_ELEMENTDATA，此时数组容量为0，添加元素时，符合if的条件，会进入此扩容情况，容量从0扩展到1。</p><p>（2）传Collection元素列表的构造方法被传入空列表时，elementData被赋予的是EMPTY_ELEMENTDATA，数组容量为0，此时添加元素时，符合if的条件，会进入此扩容情况，容量从0扩展到1。</p><p>当oldCapacity大于0时，新创建的数组大小是老容量+老容量的一半，也就是老容量的1.5倍，每次扩容到原来的1.5倍。</p><p>else就剩一种情况了，也就是用默认无参构造方法创建的数组的初始扩容情况。此时的容量为0，添加一个元素时会创建一个新的数组，其大小为max(DEFAULT_CAPACITY, minCapacity)。</p><p>我们从上面的源码变量信息中可得知DEFAULT_CAPACITY是一个常量，其值为10，而minCapacity的值为（0+1），所以添加一个元素时，max(DEFAULT_CAPACITY, minCapacity)的值必为10。也就是说，当我们用默认无参构造方法创建的数组在添加元素前，ArrayList的容量为0，添加一个元素后，ArrayList的容量就变为10了。</p><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p><strong>ArrayList的特点：</strong></p><p><strong>1.ArrayList的底层数据结构是数组，所以查找遍历快，增删慢。</strong></p><p><strong>2.ArrayList可随着元素的增长而自动扩容，正常扩容的话，每次扩容到原来的1.5倍。</strong></p><p><strong>3.ArrayList的线程是不安全的。</strong></p><p><strong>ArrayList的扩容：</strong></p><p><strong>扩容可分为两种情况：</strong></p><p><strong>第一种情况，当ArrayList的容量为0时，此时添加元素的话，需要扩容，三种构造方法创建的ArrayList在扩容时略有不同：</strong></p><p>1.无参构造，创建ArrayList后容量为0，添加第一个元素后，容量变为10，此后若需要扩容，则正常扩容。</p><p>2.传容量构造，当参数为0时，创建ArrayList后容量为0，添加第一个元素后，容量为1，此时ArrayList是满的，下次添加元素时需正常扩容。</p><p>3.传列表构造，当列表为空时，创建ArrayList后容量为0，添加第一个元素后，容量为1，此时ArrayList是满的，下次添加元素时需正常扩容。</p><p><strong>第二种情况，当ArrayList的容量大于0，并且ArrayList是满的时，此时添加元素的话，进行正常扩容，每次扩容到原来的1.5倍。</strong></p><p>本文转自 <a href="https://www.cnblogs.com/ruoli-0/p/13714389.html">https://www.cnblogs.com/ruoli-0/p/13714389.html</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘扩容</title>
      <link href="/2020/05/30/%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
      <url>/2020/05/30/%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="案例-如何磁盘扩容"><a href="#案例-如何磁盘扩容" class="headerlink" title="[案例]如何磁盘扩容"></a>[案例]如何磁盘扩容</h1><blockquote><p>背景：日常工作中经常会遇到磁盘空间不足的情况，在服务器磁盘不足的情况中通常使用最快以及最灵活的lvm扩容方式进行</p></blockquote><blockquote><p>问题：如何通过lvm扩容磁盘，一般形式通过fdisk初始化挂载硬盘，然后通过pvc及vge相关命令进行相关磁盘格式处理，最后完成挂载</p></blockquote><ul><li><p>处理方法 通过fdisk命令初始化挂载的硬盘（fdisk &#x2F;dev&#x2F;vda）并且输入n进入新增磁盘步骤。Partition type部分输入p新增磁盘，随后进入选择分区号，可以直接回车默认分区号（此时需记录对应分区号，后面找磁盘方便），紧接着进入扇区编辑步骤，可根据需要扩容大小分配起始扇区及last扇区，完成后此两数值差为此磁盘大小。完成以上步骤后输入w保存所有操作，如操作过程有误可按ctrl c退出命令不保存相关操作。至此为之已完成磁盘初始化，此时需重启电脑重新挂载该磁盘生效相关配置。重启完毕后可以通过lsblk或者df -h找到分区后磁盘名字如vda3,此时可通过pvcreate 对应磁盘名字（&#x2F;dev&#x2F;vda3）进行pv创建。创建完毕后需查看需扩容磁盘所属group，查询完毕后通过命令vgextend创建vg（vgextend centos（此为查询得到的group） &#x2F;dev&#x2F;vda3）。挂载完毕后可通过命令lvdisplay查看所有lvm状态。查看之后通过命令lvextend将新磁盘挂载入需扩容磁盘同一目录（lvextend &#x2F;dev&#x2F;centos&#x2F;home（此为需扩容磁盘目录） &#x2F;dev&#x2F;vda3（此为新建磁盘） -L +900G（此为需要扩容的对应磁盘大小））。完成后通过命令xfs_growfs刷新磁盘（xfs_growfs &#x2F;dev&#x2F;mapper&#x2F;centos-home（此为需扩容磁盘目录））。至此完成磁盘扩容所有步骤，可再次通过命令lsblk或df -h查看磁盘大小。</p></li><li><p>问题思考:<br>由于lvm方式扩容简单且灵活，但一旦磁盘出现故障很难进行恢复或拆分等操作，因此该模式也存在一定风险，所以对于重要服务器一般创建磁盘时就需分配足够磁盘空间，同时定时做好备份。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS简单了解</title>
      <link href="/2020/05/10/CAS/"/>
      <url>/2020/05/10/CAS/</url>
      
        <content type="html"><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><blockquote><p>CAS：compare and swap<br>是一个原子性操作，对应cpu指令 cmpxchg<br>CAS 有三个操作数：</p></blockquote><ul><li>当前值A</li><li>内存值V</li><li>要修改的新值B <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">update A -&gt; B</span><br><span class="line">if(A == V) &#123; //判断当前值和内存值是否相等</span><br><span class="line">   V == B</span><br><span class="line">&#125;else&#123;</span><br><span class="line">   //重试，或者放弃更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicDemo &#123; </span><br><span class="line">public static int NUMBER = 0; </span><br><span class="line">public static void increase() &#123; </span><br><span class="line">    NUMBER++; </span><br><span class="line">&#125; </span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123; </span><br><span class="line">AtomicDemo test = new AtomicDemo(); </span><br><span class="line">for (int i = 0; i &lt; 10; i++) </span><br><span class="line">&#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) test.increase(); &#125;).start(); &#125; </span><br><span class="line">Thread.sleep(200); </span><br><span class="line">System.out.println(test.NUMBER); </span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>这里很明显得出的结果不会是我们那想要的。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static AtomicInteger NUMBER = new AtomicInteger(0); </span><br><span class="line">public static void increase() &#123; </span><br><span class="line">    NUMBER.getAndIncrement(); </span><br><span class="line">&#125; </span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123; </span><br><span class="line">AtomicDemo test = new AtomicDemo(); </span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) test.increase(); &#125;).start(); &#125; </span><br><span class="line">Thread.sleep(200); </span><br><span class="line">System.out.println(test.NUMBER); &#125;</span><br></pre></td></tr></table></figure>运行main方法，程序输出的就是我们想要的值，也就是10000<br>为什么要使用CAS？</li><li>ok，就不得不说synchorized，它是java锁、jvm锁。这里还有一个知识点就是对象信息（下次再说吧）。<br>synchorized锁每次只会让一个线程去操作共享资源，而CAS相当于没有加锁，多个线程都可以直接去操作共享资源。<br>在实际修改再判断是否修改成功。</li></ul><p>synchorized效率要 &gt; CAS<br>##CAS缺点？</p><blockquote><p>ABA问题。</p></blockquote><ul><li>ABA：假设线程A读到当前值是10，可能线程B修改成100，然后C又修改成10。</li></ul><p>当线程A拿到执行权时，因为当前值和内存值是一样的，所以是可以修改的。<br>其实我觉得没有什么太大问题，但是也是可以解决的，有一个<strong>AtomicStampedReference</strong>类提供给我们使用<br>说白了就是加个version，对比一下是否一致。</p><h2 id="但是推荐使用-LongAdder对象"><a href="#但是推荐使用-LongAdder对象" class="headerlink" title="但是推荐使用 LongAdder对象"></a>但是推荐使用 LongAdder对象</h2><blockquote><p>AutoMic做累加的时候实际上是多个线程操作同一个资源，其他线程不断自旋，效率和性能就不说了吧。<br>而LongAdder的思想就是要把操作的目标资源分散到数组cell中。<br>每个线程对自己的cell进行原子操作，大大降低了失败的次数，有点像volidate哈，下课～！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡详解</title>
      <link href="/2019/09/16/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/09/16/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="负载均衡介绍"><a href="#负载均衡介绍" class="headerlink" title="负载均衡介绍"></a>负载均衡介绍</h2><blockquote><p>负载均衡，英文名称为Load Balance，指由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，<br>都可以单独对外提供服务而无须其他服务器的辅助。<br>通过某种负载分担技术，将外部发送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。<br>负载均衡能够平均分配客户请求到服务器阵列，借此提供快速获取重要数据，解决大量并发访问服务问题，<br>这种集群技术可以用最少的投资获得接近于大型主机的性能。</p></blockquote><h2 id="负载均衡方式"><a href="#负载均衡方式" class="headerlink" title="负载均衡方式"></a>负载均衡方式</h2><blockquote><p>负载均衡分为软件负载均衡和硬件负载均衡</p></blockquote><h2 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h2><blockquote><p>常见的负载均衡软件有Nginx、LVS、HAProxy。</p></blockquote><h2 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h2><blockquote><p>常见的负载均衡硬件有Array、F5。</p></blockquote><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><blockquote><p>定义一个服务器列表，每个负载均衡的算法会从中挑出一个服务器作为算法的结果。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ServerIps &#123;</span><br><span class="line">﻿</span><br><span class="line">    private static final List&lt;String&gt; LIST = Arrays.asList(</span><br><span class="line">﻿</span><br><span class="line">            &quot;192.168.0.1&quot;,</span><br><span class="line">﻿</span><br><span class="line">            &quot;192.168.0.2&quot;,</span><br><span class="line">﻿</span><br><span class="line">            &quot;192.168.0.3&quot;,</span><br><span class="line">﻿</span><br><span class="line">            &quot;192.168.0.4&quot;,</span><br><span class="line">﻿</span><br><span class="line">            &quot;192.168.0.5&quot;,</span><br><span class="line">﻿</span><br><span class="line">            &quot;192.168.0.6&quot;,</span><br><span class="line">﻿</span><br><span class="line">            &quot;192.168.0.7&quot;,</span><br><span class="line">﻿</span><br><span class="line">            &quot;192.168.0.8&quot;,</span><br><span class="line">﻿</span><br><span class="line">            &quot;192.168.0.9&quot;,</span><br><span class="line">﻿</span><br><span class="line">            &quot;192.168.0.10&quot;</span><br><span class="line">﻿</span><br><span class="line">    );</span><br><span class="line">﻿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>随机算法-RandomLoadBalance<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Random &#123;</span><br><span class="line">﻿</span><br><span class="line">    public static String getServer() &#123;</span><br><span class="line">﻿</span><br><span class="line">        // 生成一个随机数作为list的下标值</span><br><span class="line">﻿</span><br><span class="line">        java.util.Random random = new java.util.Random();</span><br><span class="line">﻿</span><br><span class="line">        int randomPos = random.nextInt(ServerIps.LIST.size());</span><br><span class="line">﻿</span><br><span class="line">        return ServerIps.LIST.get(randomPos);</span><br><span class="line">﻿</span><br><span class="line">    &#125;</span><br><span class="line">﻿</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">﻿</span><br><span class="line">        // 连续调用10次</span><br><span class="line">﻿</span><br><span class="line">        for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">﻿</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">﻿</span><br><span class="line">        &#125;</span><br><span class="line">﻿</span><br><span class="line">    &#125;</span><br><span class="line">﻿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">﻿</span><br><span class="line">192.168.0.3</span><br><span class="line">﻿</span><br><span class="line">192.168.0.4</span><br><span class="line">﻿</span><br><span class="line">192.168.0.7</span><br><span class="line">﻿</span><br><span class="line">192.168.0.1</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.7</span><br><span class="line">﻿</span><br><span class="line">192.168.0.3</span><br><span class="line">﻿</span><br><span class="line">192.168.0.9</span><br><span class="line">﻿</span><br><span class="line">192.168.0.1</span><br><span class="line">﻿</span><br><span class="line">192.168.0.1</span><br></pre></td></tr></table></figure><blockquote><p>当调用次数比较少时，<br>Random 产生的随机数可能会比较集中，<br>此时多数请求会落到同一台服务器上，只有在经过多次请求后，<br>才能使调用请求进行“均匀”分配。调用量少这一点并没有什么关系<br>，负载均衡机制不正是为了应对请求量多的情况吗，所以随机算法也是用得比较多的一种算法。</p></blockquote><p>但是，上面的随机算法适用于每天机器的性能差不多的时候，实际上，生产中可能某些机器的性能更高一点，它可以处理更多的请求，所以，我们可以对每台服务器设置一个权重。<br>在ServerIps类中增加服务器权重对应关系MAP，权重之和为50：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static final Map&lt;String, Integer&gt; WEIGHT_LIST = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">﻿</span><br><span class="line">    static &#123;</span><br><span class="line">﻿</span><br><span class="line">        // 权重之和为50</span><br><span class="line">﻿</span><br><span class="line">        WEIGHT_LIST.put(&quot;192.168.0.1&quot;, 1);</span><br><span class="line">﻿</span><br><span class="line">        WEIGHT_LIST.put(&quot;192.168.0.2&quot;, 8);</span><br><span class="line">﻿</span><br><span class="line">        WEIGHT_LIST.put(&quot;192.168.0.3&quot;, 3);</span><br><span class="line">﻿</span><br><span class="line">        WEIGHT_LIST.put(&quot;192.168.0.4&quot;, 6);</span><br><span class="line">﻿</span><br><span class="line">        WEIGHT_LIST.put(&quot;192.168.0.5&quot;, 5);</span><br><span class="line">﻿</span><br><span class="line">        WEIGHT_LIST.put(&quot;192.168.0.6&quot;, 5);</span><br><span class="line">﻿</span><br><span class="line">        WEIGHT_LIST.put(&quot;192.168.0.7&quot;, 4);</span><br><span class="line">﻿</span><br><span class="line">        WEIGHT_LIST.put(&quot;192.168.0.8&quot;, 7);</span><br><span class="line">﻿</span><br><span class="line">        WEIGHT_LIST.put(&quot;192.168.0.9&quot;, 2);</span><br><span class="line">﻿</span><br><span class="line">        WEIGHT_LIST.put(&quot;192.168.0.10&quot;, 9);</span><br><span class="line">﻿</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么现在的随机算法应该要改成权重随机算法，当调用量比较多的时候，服务器使用的分布应该近似对应权重的分布。</p></li><li>权重随机算法</li></ul><p>简单的实现思路是，把每个服务器按它所对应的服务器进行复制，具体看代码更加容易理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class WeightRandom &#123;</span><br><span class="line">﻿</span><br><span class="line">    public static String getServer() &#123;</span><br><span class="line">﻿</span><br><span class="line">        // 生成一个随机数作为list的下标值</span><br><span class="line">﻿</span><br><span class="line">        List&lt;String&gt; ips = new ArrayList&lt;String&gt;();</span><br><span class="line">﻿</span><br><span class="line">        for (String ip : ServerIps.WEIGHT_LIST.keySet()) &#123;</span><br><span class="line">﻿</span><br><span class="line">            Integer weight = ServerIps.WEIGHT_LIST.get(ip);</span><br><span class="line">﻿</span><br><span class="line">            // 按权重进行复制</span><br><span class="line">﻿</span><br><span class="line">            for (int i=0; i&lt;weight; i++) &#123;</span><br><span class="line">﻿</span><br><span class="line">                ips.add(ip);</span><br><span class="line">﻿</span><br><span class="line">            &#125;</span><br><span class="line">﻿</span><br><span class="line">        &#125;</span><br><span class="line">﻿</span><br><span class="line">        java.util.Random random = new java.util.Random();</span><br><span class="line">﻿</span><br><span class="line">        int randomPos = random.nextInt(ips.size());</span><br><span class="line">﻿</span><br><span class="line">        return ips.get(randomPos);</span><br><span class="line">﻿</span><br><span class="line">    &#125;</span><br><span class="line">﻿</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">﻿</span><br><span class="line">        // 连续调用10次</span><br><span class="line">﻿</span><br><span class="line">        for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">﻿</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">﻿</span><br><span class="line">        &#125;</span><br><span class="line">﻿</span><br><span class="line">    &#125;</span><br><span class="line">﻿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">﻿</span><br><span class="line">192.168.0.8</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.7</span><br><span class="line">﻿</span><br><span class="line">192.168.0.10</span><br><span class="line">﻿</span><br><span class="line">192.168.0.8</span><br><span class="line">﻿</span><br><span class="line">192.168.0.8</span><br><span class="line">﻿</span><br><span class="line">192.168.0.4</span><br><span class="line">﻿</span><br><span class="line">192.168.0.7</span><br><span class="line">﻿</span><br><span class="line">192.168.0.6</span><br><span class="line">﻿</span><br><span class="line">192.168.0.8</span><br></pre></td></tr></table></figure><ul><li>轮询算法-RoundRobinLoadBalance<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class RoundRobin &#123;</span><br><span class="line">﻿</span><br><span class="line">    // 当前循环的位置</span><br><span class="line">﻿</span><br><span class="line">    private static Integer pos = 0;</span><br><span class="line">﻿</span><br><span class="line">    public static String getServer() &#123;</span><br><span class="line">﻿</span><br><span class="line">        String ip = null;</span><br><span class="line">﻿</span><br><span class="line">        // pos同步</span><br><span class="line">﻿</span><br><span class="line">        synchronized (pos) &#123;</span><br><span class="line">﻿</span><br><span class="line">            if (pos &gt;= ServerIps.LIST.size()) &#123;</span><br><span class="line">﻿</span><br><span class="line">                pos = 0;</span><br><span class="line">﻿</span><br><span class="line">            &#125;</span><br><span class="line">﻿</span><br><span class="line">            ip = ServerIps.LIST.get(pos);</span><br><span class="line">﻿</span><br><span class="line">            pos++;</span><br><span class="line">﻿</span><br><span class="line">        &#125;</span><br><span class="line">﻿</span><br><span class="line">        return ip;</span><br><span class="line">﻿</span><br><span class="line">    &#125;</span><br><span class="line">﻿</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">﻿</span><br><span class="line">        // 连续调用10次</span><br><span class="line">﻿</span><br><span class="line">        for (int i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">﻿</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">﻿</span><br><span class="line">        &#125;</span><br><span class="line">﻿</span><br><span class="line">    &#125;</span><br><span class="line">﻿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">﻿</span><br><span class="line">运行结果：</span><br><span class="line">﻿</span><br><span class="line">192.168.0.1</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.3</span><br><span class="line">﻿</span><br><span class="line">192.168.0.4</span><br><span class="line">﻿</span><br><span class="line">192.168.0.5</span><br><span class="line">﻿</span><br><span class="line">192.168.0.6</span><br><span class="line">﻿</span><br><span class="line">192.168.0.7</span><br><span class="line">﻿</span><br><span class="line">192.168.0.8</span><br><span class="line">﻿</span><br><span class="line">192.168.0.9</span><br><span class="line">﻿</span><br><span class="line">192.168.0.10</span><br><span class="line">﻿</span><br><span class="line">192.168.0.1</span><br></pre></td></tr></table></figure><blockquote><p>这种算法很简单，也很公平，每台服务轮流来进行服务，但是有的机器性能好，所以能者多劳，和随机算法一下，加上权重这个维度之后，其中一种实现方法就是复制法，这里就不演示了，这种复制算法的缺点和随机算法的是一样的，比较消耗内存，那么自然就有其他实现方法。我下面来介绍一种算法：<br>这种算法需要加入一个概念：调用编号，比如第1次调用为1， 第2次调用为2， 第100次调用为100，调用编号是递增的，所以我们可以根据这个调用编号推算出服务器。<br>假设我们有三台服务器 servers &#x3D; [A, B, C]，对应的权重为 weights &#x3D; [ 2, 5, 1], 总权重为8，我们可以理解为有8台“服务器”，这是8台“不具有并发功能”，其中有2台为A，5台为B，1台为C，一次调用过来的时候，需要按顺序访问，比如有10次调用，那么服务器调用顺序为AABBBBBCAA，<br>调用编号会越来越大，而服务器是固定的，所以需要把调用编号“缩小”，这里对调用编号进行取余，除数为总权重和，比如：</p></blockquote></li><li>1号调用，1%8&#x3D;1；</li><li>2号调用，2%8&#x3D;2；</li><li>3号调用，3%8&#x3D;3；</li><li>8号调用，8%8&#x3D;0；</li><li>9号调用，9%8&#x3D;1；</li><li>100号调用，100%8&#x3D;4；<br>我们发现调用编号可以被缩小为0-7之间的8个数字，问题是怎么根据这个8个数字找到对应的服务器呢？和我们随机算法类似，这里也可以把权重想象为一个坐标轴“0—–2—–7—–8”</li><li>1号调用，1%8&#x3D;1，offset &#x3D; 1, offset &lt;&#x3D; 2 is true，取A；</li><li>2号调用，2%8&#x3D;2；offset &#x3D; 2，offset &lt;&#x3D; 2 is true, 取A;</li><li>3号调用，3%8&#x3D;3；offset &#x3D; 3, offset &lt;&#x3D; 2 is false, offset &#x3D; offset - 2, offset &#x3D; 1, offset &lt;&#x3D; 5，取B</li><li>8号调用，8%8&#x3D;0；offset &#x3D; 0, 特殊情况，offset &#x3D; 8，offset &lt;&#x3D; 2 is false, offset &#x3D; offset - 2, offset &#x3D; 6, offset  &lt;&#x3D; 5 is false, offset &#x3D; offset - 5, offset &#x3D; 1, offset &lt;&#x3D; 1 is true, 取C;</li><li>9号调用，9%8&#x3D;1；&#x2F;&#x2F; …</li><li>100号调用，100%8&#x3D;4； &#x2F;&#x2F;…<br>实现：<br>模拟调用编号获取工具：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Sequence &#123;</span><br><span class="line">﻿</span><br><span class="line">    public static Integer num = 0;</span><br><span class="line">﻿</span><br><span class="line">    public static Integer getAndIncrement() &#123;</span><br><span class="line">﻿</span><br><span class="line">        return ++num;</span><br><span class="line">﻿</span><br><span class="line">    &#125;</span><br><span class="line">﻿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class WeightRoundRobin &#123;</span><br><span class="line">﻿</span><br><span class="line">    private static Integer pos = 0;</span><br><span class="line">﻿</span><br><span class="line">    public static String getServer() &#123;</span><br><span class="line">﻿</span><br><span class="line">        int totalWeight = 0;</span><br><span class="line">﻿</span><br><span class="line">        boolean sameWeight = true; // 如果所有权重都相等，那么随机一个ip就好了</span><br><span class="line">﻿</span><br><span class="line">        Object[] weights = ServerIps.WEIGHT_LIST.values().toArray();</span><br><span class="line">﻿</span><br><span class="line">        for (int i = 0; i &lt; weights.length; i++) &#123;</span><br><span class="line">﻿</span><br><span class="line">            Integer weight = (Integer) weights[i];</span><br><span class="line">﻿</span><br><span class="line">            totalWeight += weight;</span><br><span class="line">﻿</span><br><span class="line">            if (sameWeight &amp;&amp; i &gt; 0 &amp;&amp; !weight.equals(weights[i - 1])) &#123;</span><br><span class="line">﻿</span><br><span class="line">                sameWeight = false;</span><br><span class="line">﻿</span><br><span class="line">            &#125;</span><br><span class="line">﻿</span><br><span class="line">        &#125;</span><br><span class="line">﻿</span><br><span class="line">        Integer sequenceNum = Sequence.getAndIncrement();</span><br><span class="line">﻿</span><br><span class="line">        Integer offset = sequenceNum % totalWeight;</span><br><span class="line">﻿</span><br><span class="line">        offset = offset == 0 ?  totalWeight : offset;</span><br><span class="line">﻿</span><br><span class="line">        if (!sameWeight) &#123;</span><br><span class="line">﻿</span><br><span class="line">            for (String ip : ServerIps.WEIGHT_LIST.keySet()) &#123;</span><br><span class="line">﻿</span><br><span class="line">                Integer weight = ServerIps.WEIGHT_LIST.get(ip);</span><br><span class="line">﻿</span><br><span class="line">                if (offset &lt;= weight) &#123;</span><br><span class="line">﻿</span><br><span class="line">                    return ip;</span><br><span class="line">﻿</span><br><span class="line">                &#125;</span><br><span class="line">﻿</span><br><span class="line">                offset = offset - weight;</span><br><span class="line">﻿</span><br><span class="line">            &#125;</span><br><span class="line">﻿</span><br><span class="line">        &#125;</span><br><span class="line">﻿</span><br><span class="line">        String ip = null;</span><br><span class="line">﻿</span><br><span class="line">        synchronized (pos) &#123;</span><br><span class="line">﻿</span><br><span class="line">            if (pos &gt;= ServerIps.LIST.size()) &#123;</span><br><span class="line">﻿</span><br><span class="line">                pos = 0;</span><br><span class="line">﻿</span><br><span class="line">            &#125;</span><br><span class="line">﻿</span><br><span class="line">            ip = ServerIps.LIST.get(pos);</span><br><span class="line">﻿</span><br><span class="line">            pos++;</span><br><span class="line">﻿</span><br><span class="line">        &#125;</span><br><span class="line">﻿</span><br><span class="line">        return ip;</span><br><span class="line">﻿</span><br><span class="line">    &#125;</span><br><span class="line">﻿</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">﻿</span><br><span class="line">        // 连续调用11次</span><br><span class="line">﻿</span><br><span class="line">        for (int i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">﻿</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">﻿</span><br><span class="line">        &#125;</span><br><span class="line">﻿</span><br><span class="line">    &#125;</span><br><span class="line">﻿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">﻿</span><br><span class="line">192.168.0.1</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.2</span><br><span class="line">﻿</span><br><span class="line">192.168.0.3</span><br><span class="line">﻿</span><br><span class="line">192.168.0.3</span><br></pre></td></tr></table></figure><blockquote><p>但是这种算法有一个缺点：一台服务器的权重特别大的时候，他需要连续的的处理请求，但是实际上我们想达到的效果是，对于100次请求，只要有100*8&#x2F;50&#x3D;16次就够了，这16次不一定要连续的访问，比如假设我们有三台服务器 servers &#x3D; [A, B, C]，对应的权重为 weights &#x3D; [5, 1, 1] , 总权重为7，那么上述这个算法的结果是：AAAAABC，那么如果能够是这么一个结果呢：AABACAA，把B和C平均插入到5个A中间，这样是比较均衡的了</p></blockquote></li></ul><p>我们这里可以改成平滑加权轮询。<br>平滑加权轮询<br>思路：每个服务器对应两个权重，分别为 weight 和 currentWeight。其中 weight 是固定的，currentWeight 会动态调整，初始值为0。当有新的请求进来时，遍历服务器列表，让它的 currentWeight 加上自身权重。遍历完成后，找到最大的 currentWeight，并将其减去权重总和，然后返回相应的服务器即可。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>find命令</title>
      <link href="/2019/04/16/find%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/04/16/find%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">将当前目录及其子目录下所有文件后缀为 .c 的文件列出来:</span><br><span class="line"># find . -name &quot;*.c&quot;</span><br><span class="line">将当前目录及其子目录中的所有文件列出：</span><br><span class="line"></span><br><span class="line"># find . -type f</span><br><span class="line">将当前目录及其子目录下所有最近 20 天内更新过的文件列出:</span><br><span class="line"></span><br><span class="line"># find . -ctime -20</span><br><span class="line">查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：</span><br><span class="line"></span><br><span class="line"># find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;</span><br><span class="line">查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</span><br><span class="line"></span><br><span class="line"># find . -type f -perm 644 -exec ls -l &#123;&#125; \;</span><br><span class="line">查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：</span><br><span class="line"></span><br><span class="line"># find / -type f -size 0 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
