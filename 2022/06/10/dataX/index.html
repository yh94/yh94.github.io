<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>dataX剖析 | Yu Hang-Blog</title><meta name="keywords" content="java,大数据"><meta name="author" content="Hang Yu"><meta name="copyright" content="Hang Yu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="整个流程大致如下先看下官方的介绍，了解下功能和结构。再进行源码的剖析DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能 DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader&#x2F;Wr">
<meta property="og:type" content="article">
<meta property="og:title" content="dataX剖析">
<meta property="og:url" content="http://example.com/2022/06/10/dataX/index.html">
<meta property="og:site_name" content="Yu Hang-Blog">
<meta property="og:description" content="整个流程大致如下先看下官方的介绍，了解下功能和结构。再进行源码的剖析DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能 DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader&#x2F;Wr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/lKKp6BFFAriR7u6J.jpg">
<meta property="article:published_time" content="2022-06-09T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-14T06:49:48.503Z">
<meta property="article:author" content="Hang Yu">
<meta property="article:tag" content="java">
<meta property="article:tag" content="大数据">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/lKKp6BFFAriR7u6J.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/06/10/dataX/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'dataX剖析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-14 14:49:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/touxiang.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/lKKp6BFFAriR7u6J.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Yu Hang-Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">dataX剖析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-09T16:00:00.000Z" title="发表于 2022-06-10 00:00:00">2022-06-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-14T06:49:48.503Z" title="更新于 2022-06-14 14:49:48">2022-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/">数据同步</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="dataX剖析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>整个流程大致如下<br><img src="https://img-blog.csdnimg.cn/20200825180616261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ljaGFuZzU3Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>先看下官方的介绍，了解下功能和结构。再进行源码的剖析</strong><br>DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jbG91ZC5naXRodWJ1c2VyY29udGVudC5jb20vYXNzZXRzLzEwNjcxNzUvMTc4Nzk4NDEvOTNiN2ZjMWMtNjkyNy0xMWU2LThjZGEtN2NmODQyMGZjNjVmLnBuZw?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<p>DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader&#x2F;Writer插件，纳入到整个同步框架中。</p>
<p>Reader：Reader为数据采集模块，负责采集数据源的数据，将数据发送给Framework。</p>
<p>Writer： Writer为数据写入模块，负责不断向Framework取数据，并将数据写入到目的端。</p>
<p>Framework：Framework用于连接reader和writer，作为两者的数据传输通道，并处理缓冲，流控，并发，数据转换等核心技术问题。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jbG91ZC5naXRodWJ1c2VyY29udGVudC5jb20vYXNzZXRzLzEwNjcxNzUvMTc4Nzk4ODQvZWM3ZTM2ZjQtNjkyNy0xMWU2LThmNWYtZmZjNDNkNmE0NjhiLnBuZw?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br>DataX3.0核心架构<br>DataX 3.0 开源版本支持单机多线程模式完成同步作业运行，按一个DataX作业生命周期的时序图，从整体架构设计非常简要说明DataX各个模块相互关系<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jbG91ZC5naXRodWJ1c2VyY29udGVudC5jb20vYXNzZXRzLzEwNjcxNzUvMTc4NTA4NDkvYWE2Yzk1YTgtNjg5MS0xMWU2LTk0YjctMzlmMGFiNWFmM2I0LnBuZw?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br>核心模块<br>DataX完成单个数据同步的作业，我们称之为Job，DataX接受到一个Job之后，将启动一个进程来完成整个作业同步过程。DataX Job模块是单个作业的中枢管理节点，承担了数据清理、子任务切分(将单一作业计算转化为多个子Task)、TaskGroup管理等功能。</p>
<p>DataXJob启动后，会根据不同的源端切分策略，将Job切分成多个小的Task(子任务)，以便于并发执行。Task便是DataX作业的最小单元，每一个Task都会负责一部分数据的同步工作。</p>
<p>切分多个Task之后，DataX Job会调用Scheduler模块，根据配置的并发数据量，将拆分成的Task重新组合，组装成TaskGroup(任务组)。每一个TaskGroup负责以一定的并发运行完毕分配好的所有Task，默认单个任务组的并发数量为5。</p>
<p>每一个Task都由TaskGroup负责启动，Task启动后，会固定启动Reader—&gt;Channel—&gt;Writer的线程来完成任务同步工作。</p>
<p>DataX作业运行起来之后， Job监控并等待多个TaskGroup模块任务完成，等待所有TaskGroup任务完成后Job成功退出。否则，异常退出，进程退出值非0</p>
<p>DataX任务切分<br>例如用户提交了一个DataX作业，并且配置了10个并发，目的是将一个100张分表的mysql数据同步到目标库。 任务切分过程：</p>
<p>DataXJob根据分库分表切分成了100个Task。</p>
<p>根据10个并发，每个TaskGroup默认执行5个task(TaskGroup执行task数量可以设置)DataX计算共需要分配2个TaskGroup。</p>
<p>2个TaskGroup平分切分好的100个Task，每一个TaskGroup负责以5个并发共计运行50个Task</p>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ychang577/article/details/108226450"></a>源码剖析</h2><p>任务执行的入口类为Engine</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 入参参数</span><br><span class="line">     * -mode standalone</span><br><span class="line">     * -jobid -1</span><br><span class="line">     * -job E:\\workspace\\datax\\job\\job1.json</span><br><span class="line">     */</span><br><span class="line">    String[] param = &#123;&quot;-mode&quot;, &quot;standalone&quot;, &quot;-jobid&quot;, &quot;-1&quot;, &quot;-job&quot;, &quot;E:\\workspace\\datax\\job\\job1.json&quot;&#125;;</span><br><span class="line">    System.setProperty(&quot;datax.home&quot;, &quot;E:\\workspace\\DataX-master\\core\\src\\main&quot;);</span><br><span class="line">    args = param;</span><br><span class="line">    int exitCode = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        Engine.entry(args);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Job的核心配置</strong>主要包括三个配置</p>
<blockquote>
<p>core.json DataX核心配置</p>
</blockquote>
<blockquote>
<p>job.json 本次任务配置</p>
</blockquote>
<blockquote>
<p>plugin.json 本次任务使用到read , write 插件配置</p>
</blockquote>
<p>Engine#entry</p>
<p>1、解析命令行参数 -mode -jobid -job 获取jobid, 和job配置文件路径，执行模式(standalone, local, Distrubuted)</p>
<p>2、解析本次任务配置，创建新的Engine,执行start()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void entry(final String[] args) throws Throwable &#123;</span><br><span class="line">    Options options = new Options();</span><br><span class="line">    options.addOption(&quot;job&quot;, true, &quot;Job config.&quot;);</span><br><span class="line">    options.addOption(&quot;jobid&quot;, true, &quot;Job unique id.&quot;);</span><br><span class="line">    options.addOption(&quot;mode&quot;, true, &quot;Job runtime mode.&quot;);</span><br><span class="line">    BasicParser parser = new BasicParser();</span><br><span class="line">    CommandLine cl = parser.parse(options, args);   //解析命令参数</span><br><span class="line">    String jobPath = cl.getOptionValue(&quot;job&quot;);</span><br><span class="line">    // 如果用户没有明确指定jobid, 则 datax.py 会指定 jobid 默认值为-1</span><br><span class="line">    String jobIdString = cl.getOptionValue(&quot;jobid&quot;);</span><br><span class="line">    RUNTIME_MODE = cl.getOptionValue(&quot;mode&quot;);</span><br><span class="line">    /**</span><br><span class="line">        * 解析本次job配置</span><br><span class="line">         * Configuration 包括3部分</span><br><span class="line">         * 1、job.json   任务配置</span><br><span class="line">         * 2. core.json  DataX配置</span><br><span class="line">         * 3. plugin.json 插件配置,例如插件类路径...</span><br><span class="line">         */</span><br><span class="line">    Configuration configuration = ConfigParser.parse(jobPath);</span><br><span class="line">    long jobId;</span><br><span class="line">    if (!&quot;-1&quot;.equalsIgnoreCase(jobIdString)) &#123;</span><br><span class="line">        jobId = Long.parseLong(jobIdString);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // only for dsc &amp; ds &amp; datax 3 update</span><br><span class="line">        String dscJobUrlPatternString = &quot;/instance/(\\d&#123;1,&#125;)/config.xml&quot;;</span><br><span class="line">        String dsJobUrlPatternString = &quot;/inner/job/(\\d&#123;1,&#125;)/config&quot;;</span><br><span class="line">        String dsTaskGroupUrlPatternString = &quot;/inner/job/(\\d&#123;1,&#125;)/taskGroup/&quot;;</span><br><span class="line">        List&lt;String&gt; patternStringList = Arrays.asList(dscJobUrlPatternString,</span><br><span class="line">                dsJobUrlPatternString, dsTaskGroupUrlPatternString);</span><br><span class="line">        jobId = parseJobIdFromUrl(patternStringList, jobPath);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isStandAloneMode = &quot;standalone&quot;.equalsIgnoreCase(RUNTIME_MODE);</span><br><span class="line">    if (!isStandAloneMode &amp;&amp; jobId == -1) &#123;</span><br><span class="line">        // 如果不是 standalone 模式，那么 jobId 一定不能为-1</span><br><span class="line">        throw DataXException.asDataXException(FrameworkErrorCode.CONFIG_ERROR, &quot;非 standalone 模式必须在 URL 中提供有效的 jobId.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    configuration.set(CoreConstant.DATAX_CORE_CONTAINER_JOB_ID, jobId);</span><br><span class="line">    //打印vmInfo</span><br><span class="line">    VMInfo vmInfo = VMInfo.getVmInfo();</span><br><span class="line">    if (vmInfo != null) &#123;</span><br><span class="line">        LOG.info(vmInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(&quot;\n&quot; + Engine.filterJobConfiguration(configuration) + &quot;\n&quot;);</span><br><span class="line">    LOG.debug(configuration.toJSON());</span><br><span class="line">    ConfigurationValidate.doValidate(configuration);</span><br><span class="line">    Engine engine = new Engine();</span><br><span class="line">    //通过配置创建一个JobContainer对象.执行start方法</span><br><span class="line">    engine.start(configuration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Engine#start</p>
<p>1、首先绑定下列转换信息，比如时间格式，时区，编码等,在core.json中的common.column配置项</p>
<p>2、设置插件配置</p>
<p>3、创建JobContainer ,并且启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public void start(Configuration allConf) &#123;</span><br><span class="line">    // 绑定column转换信息 时间格式，时区，编码等,在core.json中的common.column配置项</span><br><span class="line">    ColumnCast.bind(allConf);   </span><br><span class="line">    //初始化PluginLoader，可以获取各种插件配置</span><br><span class="line">    LoadUtil.bind(allConf);</span><br><span class="line">    //core.container.model 容器模式，默认是job</span><br><span class="line">    boolean isJob = !(&quot;taskGroup&quot;.equalsIgnoreCase(allConf</span><br><span class="line">            .getString(CoreConstant.DATAX_CORE_CONTAINER_MODEL)));</span><br><span class="line">    //JobContainer会在schedule后再行进行设置和调整值</span><br><span class="line">    int channelNumber =0;</span><br><span class="line">    AbstractContainer container;</span><br><span class="line">    long instanceId;</span><br><span class="line">    int taskGroupId = -1;</span><br><span class="line">    if (isJob) &#123;</span><br><span class="line">        allConf.set(CoreConstant.DATAX_CORE_CONTAINER_JOB_MODE, RUNTIME_MODE);</span><br><span class="line">        container = new JobContainer(allConf);</span><br><span class="line">        instanceId = allConf.getLong(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_JOB_ID, 0);</span><br><span class="line">​</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        container = new TaskGroupContainer(allConf);</span><br><span class="line">        instanceId = allConf.getLong(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_JOB_ID);</span><br><span class="line">        taskGroupId = allConf.getInt(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_ID);</span><br><span class="line">        channelNumber = allConf.getInt(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_CHANNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    //缺省打开perfTrace</span><br><span class="line">    boolean traceEnable = allConf.getBool(CoreConstant.DATAX_CORE_CONTAINER_TRACE_ENABLE, true);</span><br><span class="line">    boolean perfReportEnable = allConf.getBool(CoreConstant.DATAX_CORE_REPORT_DATAX_PERFLOG, true);</span><br><span class="line">    //standlone模式的datax shell任务不进行汇报</span><br><span class="line">    if(instanceId == -1)&#123;</span><br><span class="line">        perfReportEnable = false;</span><br><span class="line">    &#125;</span><br><span class="line">    int priority = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        priority = Integer.parseInt(System.getenv(&quot;SKYNET_PRIORITY&quot;));</span><br><span class="line">    &#125;catch (NumberFormatException e)&#123;</span><br><span class="line">        LOG.warn(&quot;prioriy set to 0, because NumberFormatException, the value is: &quot;+System.getProperty(&quot;PROIORY&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    Configuration jobInfoConfig = allConf.getConfiguration(CoreConstant.DATAX_JOB_JOBINFO);</span><br><span class="line">    //初始化PerfTrace</span><br><span class="line">    PerfTrace perfTrace = PerfTrace.getInstance(isJob, instanceId, taskGroupId, priority, traceEnable);</span><br><span class="line">    perfTrace.setJobInfo(jobInfoConfig,perfReportEnable,channelNumber);</span><br><span class="line">    /**</span><br><span class="line">     * JobContainer.start方法是整个框架核心,</span><br><span class="line">     * 依次执行job的#preHandler,#init,#prepare,#split,#schedule,#post,#postHandler方法</span><br><span class="line">     * 最重要的是#init,#split,#schedule</span><br><span class="line">     */</span><br><span class="line">    container.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JobContainer#start</p>
<p>任务容器启动器</p>
<p>preHandler 前置操作，加载job插件等 . (未使用到)</p>
<p>init 初始化read , write 插件。 这个过程会对数据源，表，列进行校验</p>
<p>initJobWriter</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void init() &#123;</span><br><span class="line">    //..省略部分代码</span><br><span class="line">    //必须先Reader ，后Writer</span><br><span class="line">    this.jobReader = this.initJobReader(jobPluginCollector);</span><br><span class="line">    this.jobWriter = this.initJobWriter(jobPluginCollector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>initJobReader、initJobWriter 初始化插件中，使用了URLCloassLoader对插件类进行加载。解决了类冲突的问题。因此用户可以使用自己的类&#x2F;jar包自定义插件。</p>
<p>jobReader.init()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private Reader.Job initJobReader(</span><br><span class="line">        JobPluginCollector jobPluginCollector) &#123;</span><br><span class="line">    //获取读插件名称</span><br><span class="line">    this.readerPluginName = this.configuration.getString(</span><br><span class="line">            CoreConstant.DATAX_JOB_CONTENT_READER_NAME);    //job.content[0].reader.name</span><br><span class="line">    //根据读插件类名称,加载插件的lib包加载到jvm中</span><br><span class="line">    classLoaderSwapper.setCurrentThreadClassLoader(LoadUtil.getJarLoader(</span><br><span class="line">            PluginType.READER, this.readerPluginName)); //重置插件jar classLoader</span><br><span class="line">    //创建一个读对象</span><br><span class="line">    Reader.Job jobReader = (Reader.Job) LoadUtil.loadJobPlugin(</span><br><span class="line">            PluginType.READER, this.readerPluginName);</span><br><span class="line">    // 设置reader的jobConfig</span><br><span class="line">    jobReader.setPluginJobConf(this.configuration.getConfiguration(</span><br><span class="line">            CoreConstant.DATAX_JOB_CONTENT_READER_PARAMETER));</span><br><span class="line">    // 设置reader的readerConfig</span><br><span class="line">    jobReader.setPeerPluginJobConf(this.configuration.getConfiguration(</span><br><span class="line">            CoreConstant.DATAX_JOB_CONTENT_WRITER_PARAMETER));</span><br><span class="line">    jobReader.setJobPluginCollector(jobPluginCollector);</span><br><span class="line">    jobReader.init();   //读插件初始化(可以见具体读插件实现类,例如MysqlReader)</span><br><span class="line">    //重置回归原classLoader</span><br><span class="line">    classLoaderSwapper.restoreCurrentThreadClassLoader();</span><br><span class="line">    return jobReader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​<br>以MysqlReader为例jobReader#init</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static class Job extends Reader.Job &#123;</span><br><span class="line">    ///...省略其他代码</span><br><span class="line">    @Override</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        this.originalConfig = super.getPluginJobConf(); //Job配置</span><br><span class="line">        Integer userConfigedFetchSize = this.originalConfig.getInt(Constant.FETCH_SIZE);</span><br><span class="line">        if (userConfigedFetchSize != null) &#123;</span><br><span class="line">            LOG.warn(&quot;对 mysqlreader 不需要配置 fetchSize, mysqlreader 将会忽略这项配置. 如果您不想再看到此警告,请去除fetchSize 配置.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.originalConfig.set(Constant.FETCH_SIZE, Integer.MIN_VALUE);</span><br><span class="line">        this.commonRdbmsReaderJob = new CommonRdbmsReader.Job(DATABASE_TYPE);</span><br><span class="line">        this.commonRdbmsReaderJob.init(this.originalConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    ///...省略其他代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以MysqlWriter为例</p>
<p>jobWriter.init();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private Writer.Job initJobWriter(</span><br><span class="line">        JobPluginCollector jobPluginCollector) &#123;</span><br><span class="line">    this.writerPluginName = this.configuration.getString(</span><br><span class="line">            CoreConstant.DATAX_JOB_CONTENT_WRITER_NAME);</span><br><span class="line">    classLoaderSwapper.setCurrentThreadClassLoader(LoadUtil.getJarLoader(</span><br><span class="line">            PluginType.WRITER, this.writerPluginName));</span><br><span class="line">    Writer.Job jobWriter = (Writer.Job) LoadUtil.loadJobPlugin(</span><br><span class="line">            PluginType.WRITER, this.writerPluginName);</span><br><span class="line">    //...省略部分代码</span><br><span class="line">    jobWriter.init();</span><br><span class="line">    classLoaderSwapper.restoreCurrentThreadClassLoader();</span><br><span class="line">    return jobWriter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jobWriter#init</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static class Job extends Writer.Job &#123;</span><br><span class="line">    //...省略部分代码</span><br><span class="line">    @Override</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        this.originalConfig = super.getPluginJobConf();</span><br><span class="line">        this.commonRdbmsWriterJob = new CommonRdbmsWriter.Job(DATABASE_TYPE);</span><br><span class="line">        this.commonRdbmsWriterJob.init(this.originalConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>prepare read, write插件做一些前置操作</p>
<p>实现为具体插件类的prepare方法</p>
<p>split 任务拆分</p>
<p>schedule 首先完成的工作是把上一步reader和writer split的结果整合到具体taskGroupContainer中,同时不同的执行模式调用不同的调度策略，将所有任务调度起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 执行reader和writer最细粒度的切分，需要注意的是，writer的切分结果要参照reader的切分结果，</span><br><span class="line"> * 达到切分后数目相等，才能满足1：1的通道模型，所以这里可以将reader和writer的配置整合到一起，</span><br><span class="line"> * 然后，为避免顺序给读写端带来长尾影响，将整合的结果shuffler掉</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">private int split() &#123;</span><br><span class="line">    //设置channel数量</span><br><span class="line">    this.adjustChannelNumber();</span><br><span class="line">    if (this.needChannelNumber &lt;= 0) &#123;</span><br><span class="line">        this.needChannelNumber = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Configuration&gt; readerTaskConfigs = this</span><br><span class="line">            .doReaderSplit(this.needChannelNumber);</span><br><span class="line">    int taskNumber = readerTaskConfigs.size();</span><br><span class="line">    List&lt;Configuration&gt; writerTaskConfigs = this</span><br><span class="line">            .doWriterSplit(taskNumber);</span><br><span class="line">    //job.content[0].transformer</span><br><span class="line">    List&lt;Configuration&gt; transformerList = this.configuration.getListConfiguration(CoreConstant.DATAX_JOB_CONTENT_TRANSFORMER);</span><br><span class="line">    //合并读任务配置、写任务配置、transformer配置</span><br><span class="line">    //输入是reader和writer的parameter list，输出是content下面元素的list</span><br><span class="line">    List&lt;Configuration&gt; contentConfig = mergeReaderAndWriterTaskConfigs(</span><br><span class="line">            readerTaskConfigs, writerTaskConfigs, transformerList);</span><br><span class="line">    //job.content 合并后的总配置</span><br><span class="line">    this.configuration.set(CoreConstant.DATAX_JOB_CONTENT, contentConfig);</span><br><span class="line">    return contentConfig.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置管道数量 adjustChannelNumber()</p>
<p>1、配置 job.setting.speed.byte (jobByte)， 则必须设置 core.transport.channel.speed.byte (coreByte) ，channelNumber &#x3D; coreByte &#x2F; jobByte &gt; 0 ? coreByte &#x2F; jobByte : 1</p>
<p>2、配置job.setting.speed.record (jobRecord) , 则必须配置core.transport.channel.speed.record（coreRecord）</p>
<p>channelNumber &#x3D; coreRecord&#x2F; jobRecord&gt; 0 ? coreRecord&#x2F; jobRecord: 1</p>
<p>如果上面2个任意配置了一个或2个，取较小值为channelNumber ，如果没有配置。则必须要配置job.setting.speed.channel 作为管道数量</p>
<p>下面切分读任务和写任务，最后把读写任务配置合并<br>#doReaderSplit 读切分任务是read插件实现的<br>我这里使用的是mysqlreader 插件，最后还是引用的框架的split实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Configuration&gt; split(int adviceNumber) &#123;</span><br><span class="line">    return this.commonRdbmsReaderJob.split(this.originalConfig, adviceNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#doWriterSplit写切分任务<br>写切分任务数量是根据读切分后的数量而来，写任务必须与读任务数一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;Configuration&gt; doWriterSplit(int readerTaskNumber) &#123;</span><br><span class="line">    classLoaderSwapper.setCurrentThreadClassLoader(LoadUtil.getJarLoader(</span><br><span class="line">            PluginType.WRITER, this.writerPluginName));</span><br><span class="line">​</span><br><span class="line">    List&lt;Configuration&gt; writerSlicesConfigs = this.jobWriter</span><br><span class="line">            .split(readerTaskNumber);</span><br><span class="line">    if (writerSlicesConfigs == null || writerSlicesConfigs.size() &lt;= 0) &#123;</span><br><span class="line">        throw DataXException.asDataXException(</span><br><span class="line">                FrameworkErrorCode.PLUGIN_SPLIT_ERROR,</span><br><span class="line">                &quot;writer切分的task不能小于等于0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    classLoaderSwapper.restoreCurrentThreadClassLoader();</span><br><span class="line">    return writerSlicesConfigs;</span><br><span class="line">&#125;</span><br><span class="line">public List&lt;Configuration&gt; split(int mandatoryNumber) &#123;</span><br><span class="line">    return this.commonRdbmsWriterJob.split(this.originalConfig, mandatoryNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>切分读任务：</p>
<p>1、table模式 ：当没有配置splitPk时，任务数量与table数量一样.比如table配置了2个(user_info, user_info_1) 则生成2任务个配置</p>
<p>2、table模式 ：配置splitPk时，配合channel一起使用。任务数 &#x3D; (向上取整)(channel&#x2F;table数量) ,当任务数 &gt; 1 .会重新切分任务</p>
<p>最终任务数 &#x3D; 任务数 * 5 + 1 。 （这里程序实际根据job配置的splitPk请求了数据库，并且把查询出的pk范围分别加入到每个任务的pk条件中去）。 例如user_info表pk为user_id. 最终的sql会加上 and user_id &gt; 下限 and user_id &lt; 上限.</p>
<p>3、querySql模式 ：有几条querySql ， 生成相同数量的任务配置</p>
<p>切分写任务</p>
<p>1、写单表的时，生成tabel表数量的任务 或者 querySql数量相等的任务</p>
<p>2、多表时，生成和表数量相同的任务</p>
<p>schedule执行任务<br>1、首先拿到任务组执行任务数量配置，再结合切分后任务数量对任务进行分组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int channelsPerTaskGroup = this.configuration.getInt(</span><br><span class="line">        CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_CHANNEL, 5);</span><br><span class="line">int taskNumber = this.configuration.getList(</span><br><span class="line">        CoreConstant.DATAX_JOB_CONTENT).size();</span><br><span class="line">this.needChannelNumber = Math.min(this.needChannelNumber, taskNumber);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;通过获取配置信息得到每个taskGroup需要运行哪些tasks任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Configuration&gt; taskGroupConfigs = JobAssignUtil.assignFairly(this.configuration,</span><br><span class="line">      this.needChannelNumber, channelsPerTaskGroup);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、创建任务执行器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AbstractScheduler scheduler = initStandaloneScheduler(this.configuration);</span><br><span class="line">private AbstractScheduler initStandaloneScheduler(Configuration configuration) &#123;</span><br><span class="line">        AbstractContainerCommunicator containerCommunicator = new StandAloneJobContainerCommunicator(configuration);</span><br><span class="line">        super.setContainerCommunicator(containerCommunicator);</span><br><span class="line">​</span><br><span class="line">        return new StandAloneScheduler(containerCommunicator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、执行任务</p>
<p>scheduler.schedule(taskGroupConfigs); &#x2F;&#x2F;schedule方法先获取收集信息的属性，比如说间隔多长时间汇报,休眠时间等<br>&#x2F;&#x2F;然后开启任务<br>startAllTaskGroup(configurations); &#x2F;&#x2F;重点，这里开启执行任务<br>&#x2F;&#x2F;后面代码是收集打印任务的汇报信息<br>4、创建线程池，提交任务</p>
<p>创建了一个与任务数量大小一致的固定线程池，满足完成当前任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void startAllTaskGroup(List&lt;Configuration&gt; configurations) &#123;</span><br><span class="line">    //创建一个任务数量大小的固定线程池</span><br><span class="line">    this.taskGroupContainerExecutorService = Executors</span><br><span class="line">            .newFixedThreadPool(configurations.size());</span><br><span class="line">    for (Configuration taskGroupConfiguration : configurations) &#123;</span><br><span class="line">        TaskGroupContainerRunner taskGroupContainerRunner = newTaskGroupContainerRunner(taskGroupConfiguration);</span><br><span class="line">        this.taskGroupContainerExecutorService.execute(taskGroupContainerRunner);</span><br><span class="line">    &#125;</span><br><span class="line">    this.taskGroupContainerExecutorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5、容器组启动</p>
<p>TaskGroupContainer类为执行任务的承载容器，重点关注</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TaskGroupContainerRunner implements Runnable &#123;</span><br><span class="line">   private TaskGroupContainer taskGroupContainer;</span><br><span class="line">   private State state;</span><br><span class="line">   public TaskGroupContainerRunner(TaskGroupContainer taskGroup) &#123;</span><br><span class="line">        this.taskGroupContainer = taskGroup;</span><br><span class="line">        this.state = State.SUCCEEDED;</span><br><span class="line">    &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">            Thread.currentThread().setName(</span><br><span class="line">                    String.format(&quot;taskGroup-%d&quot;, this.taskGroupContainer.getTaskGroupId()));</span><br><span class="line">            this.taskGroupContainer.start();    //开始执行任务</span><br><span class="line">         this.state = State.SUCCEEDED;</span><br><span class="line">      &#125; catch (Throwable e) &#123;</span><br><span class="line">         this.state = State.FAILED;</span><br><span class="line">         throw DataXException.asDataXException(</span><br><span class="line">               FrameworkErrorCode.RUNTIME_ERROR, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​<br>TaskGroupContainer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">public class TaskGroupContainer extends AbstractContainer &#123;</span><br><span class="line">    private static final Logger LOG = LoggerFactory</span><br><span class="line">            .getLogger(TaskGroupContainer.class);</span><br><span class="line">    //当前taskGroup所属jobId</span><br><span class="line">    private long jobId;</span><br><span class="line">    //当前taskGroupId</span><br><span class="line">    private int taskGroupId;</span><br><span class="line">    //使用的channel类</span><br><span class="line">    private String channelClazz;</span><br><span class="line">    //task收集器使用的类</span><br><span class="line">    private String taskCollectorClass;</span><br><span class="line">​</span><br><span class="line">    private TaskMonitor taskMonitor = TaskMonitor.getInstance();</span><br><span class="line">​</span><br><span class="line">    public TaskGroupContainer(Configuration configuration) &#123;</span><br><span class="line">        super(configuration);</span><br><span class="line">        initCommunicator(configuration);    //初始化通信器</span><br><span class="line">        this.jobId = this.configuration.getLong(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_JOB_ID);</span><br><span class="line">        //core.container.taskGroup.id 任务组id</span><br><span class="line">        this.taskGroupId = this.configuration.getInt(</span><br><span class="line">                CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_ID);</span><br><span class="line">        //管道实现类 core.transport.channel.class</span><br><span class="line">        this.channelClazz = this.configuration.getString(</span><br><span class="line">                CoreConstant.DATAX_CORE_TRANSPORT_CHANNEL_CLASS);</span><br><span class="line">        //任务收集器 core.statistics.collector.plugin.taskClass</span><br><span class="line">        this.taskCollectorClass = this.configuration.getString(</span><br><span class="line">                CoreConstant.DATAX_CORE_STATISTICS_COLLECTOR_PLUGIN_TASKCLASS);</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 状态check时间间隔，较短，可以把任务及时分发到对应channel中</span><br><span class="line">             * core.container.taskGroup.sleepInterval</span><br><span class="line">             */</span><br><span class="line">            int sleepIntervalInMillSec = this.configuration.getInt(</span><br><span class="line">                    CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_SLEEPINTERVAL, 100);</span><br><span class="line">            /**</span><br><span class="line">             * 状态汇报时间间隔，稍长，避免大量汇报</span><br><span class="line">             * core.container.taskGroup.reportInterval</span><br><span class="line">             */</span><br><span class="line">            long reportIntervalInMillSec = this.configuration.getLong(</span><br><span class="line">                    CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_REPORTINTERVAL,</span><br><span class="line">                    10000);</span><br><span class="line">            /**</span><br><span class="line">             * 2分钟汇报一次性能统计</span><br><span class="line">             */</span><br><span class="line">            //core.container.taskGroup.channel</span><br><span class="line">            // 获取channel数目</span><br><span class="line">            int channelNumber = this.configuration.getInt(</span><br><span class="line">                    CoreConstant.DATAX_CORE_CONTAINER_TASKGROUP_CHANNEL);</span><br><span class="line">            //最大重试次数 core.container.task.failOver.maxRetryTimes 默认1次</span><br><span class="line">            int taskMaxRetryTimes = this.configuration.getInt(</span><br><span class="line">                    CoreConstant.DATAX_CORE_CONTAINER_TASK_FAILOVER_MAXRETRYTIMES, 1);</span><br><span class="line">            //任务组重试间隔时间 core.container.task.failOver.retryIntervalInMsec</span><br><span class="line">            long taskRetryIntervalInMsec = this.configuration.getLong(</span><br><span class="line">                    CoreConstant.DATAX_CORE_CONTAINER_TASK_FAILOVER_RETRYINTERVALINMSEC, 10000);</span><br><span class="line">            //core.container.task.failOver.maxWaitInMsec</span><br><span class="line">            long taskMaxWaitInMsec = this.configuration.getLong(CoreConstant.DATAX_CORE_CONTAINER_TASK_FAILOVER_MAXWAITINMSEC, 60000);</span><br><span class="line">            //获取当前任务组所有任务配置</span><br><span class="line">            List&lt;Configuration&gt; taskConfigs = this.configuration</span><br><span class="line">                    .getListConfiguration(CoreConstant.DATAX_JOB_CONTENT);</span><br><span class="line">            int taskCountInThisTaskGroup = taskConfigs.size();</span><br><span class="line">            LOG.info(String.format(</span><br><span class="line">                    &quot;taskGroupId=[%d] start [%d] channels for [%d] tasks.&quot;,</span><br><span class="line">                    this.taskGroupId, channelNumber, taskCountInThisTaskGroup));</span><br><span class="line">            //任务组注册通信器</span><br><span class="line">            this.containerCommunicator.registerCommunication(taskConfigs);</span><br><span class="line">            //taskId与task配置</span><br><span class="line">            Map&lt;Integer, Configuration&gt; taskConfigMap = buildTaskConfigMap(taskConfigs);</span><br><span class="line">            List&lt;Configuration&gt; taskQueue = buildRemainTasks(taskConfigs); //待运行task列表</span><br><span class="line">            Map&lt;Integer, TaskExecutor&gt; taskFailedExecutorMap = new HashMap&lt;Integer, TaskExecutor&gt;();            //taskId与上次失败实例</span><br><span class="line">            List&lt;TaskExecutor&gt; runTasks = new ArrayList&lt;TaskExecutor&gt;(channelNumber); //正在运行task</span><br><span class="line">            Map&lt;Integer, Long&gt; taskStartTimeMap = new HashMap&lt;Integer, Long&gt;(); //任务开始时间</span><br><span class="line">            long lastReportTimeStamp = 0;</span><br><span class="line">            Communication lastTaskGroupContainerCommunication = new Communication();</span><br><span class="line">           //这里开始进入循环作业</span><br><span class="line">            while (true) &#123;</span><br><span class="line">               //1.判断task状态</span><br><span class="line">               boolean failedOrKilled = false;</span><br><span class="line">               Map&lt;Integer, Communication&gt; communicationMap = containerCommunicator.getCommunicationMap();  //任务id对应通信器,用来收集任务作业情况</span><br><span class="line">               for(Map.Entry&lt;Integer, Communication&gt; entry : communicationMap.entrySet())&#123;</span><br><span class="line">                  Integer taskId = entry.getKey();</span><br><span class="line">                  Communication taskCommunication = entry.getValue();</span><br><span class="line">                    if(!taskCommunication.isFinished())&#123;</span><br><span class="line">                        continue;   //当前任务未结束,继续执行</span><br><span class="line">                    &#125;</span><br><span class="line">                    //已经结束的任务,从正在运行的任务集合中移除</span><br><span class="line">                    TaskExecutor taskExecutor = removeTask(runTasks, taskId);</span><br><span class="line">                    //上面从runTasks里移除了，因此对应在monitor里移除</span><br><span class="line">                    taskMonitor.removeTask(taskId);</span><br><span class="line">                    //失败，看task是否支持failover，重试次数未超过最大限制</span><br><span class="line">                  if(taskCommunication.getState() == State.FAILED)&#123;</span><br><span class="line">                        taskFailedExecutorMap.put(taskId, taskExecutor);</span><br><span class="line">                     if(taskExecutor.supportFailOver() &amp;&amp; taskExecutor.getAttemptCount() &lt; taskMaxRetryTimes)&#123;</span><br><span class="line">                            taskExecutor.shutdown(); //关闭老的executor</span><br><span class="line">                            containerCommunicator.resetCommunication(taskId); //将task的状态重置</span><br><span class="line">                        Configuration taskConfig = taskConfigMap.get(taskId);</span><br><span class="line">                        taskQueue.add(taskConfig); //重新加入任务列表</span><br><span class="line">                     &#125;else&#123;</span><br><span class="line">                        failedOrKilled = true;</span><br><span class="line">                         break;</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;else if(taskCommunication.getState() == State.KILLED)&#123;</span><br><span class="line">                     failedOrKilled = true;</span><br><span class="line">                     break;</span><br><span class="line">                  &#125;else if(taskCommunication.getState() == State.SUCCEEDED)&#123;</span><br><span class="line">                        Long taskStartTime = taskStartTimeMap.get(taskId);</span><br><span class="line">                        if(taskStartTime != null)&#123;</span><br><span class="line">                            Long usedTime = System.currentTimeMillis() - taskStartTime;</span><br><span class="line">                            LOG.info(&quot;taskGroup[&#123;&#125;] taskId[&#123;&#125;] is successed, used[&#123;&#125;]ms&quot;,</span><br><span class="line">                                    this.taskGroupId, taskId, usedTime);</span><br><span class="line">                            //usedTime*1000*1000 转换成PerfRecord记录的ns，这里主要是简单登记，进行最长任务的打印。因此增加特定静态方法</span><br><span class="line">                            PerfRecord.addPerfRecord(taskGroupId, taskId, PerfRecord.PHASE.TASK_TOTAL,taskStartTime, usedTime * 1000L * 1000L);</span><br><span class="line">                            taskStartTimeMap.remove(taskId);</span><br><span class="line">                            taskConfigMap.remove(taskId);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">                // 2.发现该taskGroup下taskExecutor的总状态失败则汇报错误</span><br><span class="line">                if (failedOrKilled) &#123;</span><br><span class="line">                    lastTaskGroupContainerCommunication = reportTaskGroupCommunication(</span><br><span class="line">                            lastTaskGroupContainerCommunication, taskCountInThisTaskGroup);</span><br><span class="line">​</span><br><span class="line">                    throw DataXException.asDataXException(</span><br><span class="line">                            FrameworkErrorCode.PLUGIN_RUNTIME_ERROR, lastTaskGroupContainerCommunication.getThrowable());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //3.有任务未执行，且正在运行的任务数小于最大通道限制</span><br><span class="line">                Iterator&lt;Configuration&gt; iterator = taskQueue.iterator();</span><br><span class="line">                while(iterator.hasNext() &amp;&amp; runTasks.size() &lt; channelNumber)&#123;</span><br><span class="line">                    Configuration taskConfig = iterator.next();</span><br><span class="line">                    Integer taskId = taskConfig.getInt(CoreConstant.TASK_ID);</span><br><span class="line">                    int attemptCount = 1;</span><br><span class="line">                    TaskExecutor lastExecutor = taskFailedExecutorMap.get(taskId);</span><br><span class="line">                    if(lastExecutor!=null)&#123;</span><br><span class="line">                        attemptCount = lastExecutor.getAttemptCount() + 1;</span><br><span class="line">                        long now = System.currentTimeMillis();</span><br><span class="line">                        long failedTime = lastExecutor.getTimeStamp();</span><br><span class="line">                        if(now - failedTime &lt; taskRetryIntervalInMsec)&#123;  //未到等待时间，继续留在队列</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if(!lastExecutor.isShutdown())&#123; //上次失败的task仍未结束</span><br><span class="line">                            if(now - failedTime &gt; taskMaxWaitInMsec)&#123;</span><br><span class="line">                                markCommunicationFailed(taskId);</span><br><span class="line">                                reportTaskGroupCommunication(lastTaskGroupContainerCommunication, taskCountInThisTaskGroup);</span><br><span class="line">                                throw DataXException.asDataXException(CommonErrorCode.WAIT_TIME_EXCEED, &quot;task failover等待超时&quot;);</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                lastExecutor.shutdown(); //再次尝试关闭</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            LOG.info(&quot;taskGroup[&#123;&#125;] taskId[&#123;&#125;] attemptCount[&#123;&#125;] has already shutdown&quot;,</span><br><span class="line">                                    this.taskGroupId, taskId, lastExecutor.getAttemptCount());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Configuration taskConfigForRun = taskMaxRetryTimes &gt; 1 ? taskConfig.clone() : taskConfig;</span><br><span class="line">                   TaskExecutor taskExecutor = new TaskExecutor(taskConfigForRun, attemptCount);</span><br><span class="line">                    taskStartTimeMap.put(taskId, System.currentTimeMillis());</span><br><span class="line">                   taskExecutor.doStart();</span><br><span class="line">​</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    runTasks.add(taskExecutor); //继续添加到运行的任务集合</span><br><span class="line">                    //上面，增加task到runTasks列表，因此在monitor里注册。</span><br><span class="line">                    taskMonitor.registerTask(taskId, this.containerCommunicator.getCommunication(taskId));</span><br><span class="line">                  //刚刚已经添加了task，这里把任务id从失败map移除</span><br><span class="line">                    taskFailedExecutorMap.remove(taskId);</span><br><span class="line">                    LOG.info(&quot;taskGroup[&#123;&#125;] taskId[&#123;&#125;] attemptCount[&#123;&#125;] is started&quot;,</span><br><span class="line">                            this.taskGroupId, taskId, attemptCount);</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">                //4.任务列表为空，executor已结束, 搜集状态为success---&gt;成功</span><br><span class="line">                if (taskQueue.isEmpty() &amp;&amp; isAllTaskDone(runTasks) &amp;&amp; containerCommunicator.collectState() == State.SUCCEEDED) &#123;</span><br><span class="line">                   // 成功的情况下，也需要汇报一次。否则在任务结束非常快的情况下，采集的信息将会不准确</span><br><span class="line">                    lastTaskGroupContainerCommunication = reportTaskGroupCommunication(</span><br><span class="line">                            lastTaskGroupContainerCommunication, taskCountInThisTaskGroup);</span><br><span class="line">                    LOG.info(&quot;taskGroup[&#123;&#125;] completed it&#x27;s tasks.&quot;, this.taskGroupId);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 5.如果当前时间已经超出汇报时间的interval，那么我们需要马上汇报</span><br><span class="line">                long now = System.currentTimeMillis();</span><br><span class="line">                if (now - lastReportTimeStamp &gt; reportIntervalInMillSec) &#123;</span><br><span class="line">                    lastTaskGroupContainerCommunication = reportTaskGroupCommunication(</span><br><span class="line">                            lastTaskGroupContainerCommunication, taskCountInThisTaskGroup);</span><br><span class="line">                    lastReportTimeStamp = now;</span><br><span class="line">                    //taskMonitor对于正在运行的task，每reportIntervalInMillSec进行检查</span><br><span class="line">                    for(TaskExecutor taskExecutor:runTasks)&#123;   taskMonitor.report(taskExecutor.getTaskId(),this.containerCommunicator.getCommunication(taskExecutor.getTaskId()));</span><br><span class="line">                    &#125;</span><br><span class="line">​</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(sleepIntervalInMillSec);</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            //6.最后还要汇报一次</span><br><span class="line">            reportTaskGroupCommunication(lastTaskGroupContainerCommunication, taskCountInThisTaskGroup);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            Communication nowTaskGroupContainerCommunication = this.containerCommunicator.collect();</span><br><span class="line">            if (nowTaskGroupContainerCommunication.getThrowable() == null) &#123;</span><br><span class="line">                nowTaskGroupContainerCommunication.setThrowable(e);</span><br><span class="line">            &#125;</span><br><span class="line">            nowTaskGroupContainerCommunication.setState(State.FAILED);</span><br><span class="line">            this.containerCommunicator.report(nowTaskGroupContainerCommunication);</span><br><span class="line">            throw DataXException.asDataXException(</span><br><span class="line">                    FrameworkErrorCode.RUNTIME_ERROR, e);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(!PerfTrace.getInstance().isJob())&#123;</span><br><span class="line">                //最后打印cpu的平均消耗，GC的统计</span><br><span class="line">                VMInfo vmInfo = VMInfo.getVmInfo();</span><br><span class="line">                if (vmInfo != null) &#123;</span><br><span class="line">                    vmInfo.getDelta(false);</span><br><span class="line">                    LOG.info(vmInfo.totalString());</span><br><span class="line">                &#125;</span><br><span class="line">                LOG.info(PerfTrace.getInstance().summarizeNoException());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TaskExecute 具体执行类<br>开启了2个线程，分别进行读操作和写操作。</p>
<p>数据处理：读操作（ReaderRunner）把从数据库中读出来的每条数据封装为一个个Record放入Channel中,当数据读完时，写入一个TerminateRecord标识结束</p>
<p>写操作（WriterRunner）不断从Channel中读取Record，直到读到TerminateRecord标识数据以取完</p>
<p>ReaderRunner分别执行#init, #prepare, #startRead, #post 并记录每个阶段的处理信息(数据量，数据大小…)</p>
<p>WriterRunner分别执行#init, #prepare, #start, #post 并记录每个阶段的处理信息(数据量，数据大小…)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class TaskExecutor &#123;</span><br><span class="line">    private Configuration taskConfig;   //当前任务配置项</span><br><span class="line">    private Channel channel;    //管道 用于缓存读出来的数据</span><br><span class="line">    private Thread readerThread;    //读线程</span><br><span class="line">    private Thread writerThread;    //写线程</span><br><span class="line">    private ReaderRunner readerRunner;</span><br><span class="line">    private WriterRunner writerRunner;</span><br><span class="line">​</span><br><span class="line">    /**</span><br><span class="line">     * 该处的taskCommunication在多处用到：</span><br><span class="line">     * 1. channel</span><br><span class="line">     * 2. readerRunner和writerRunner</span><br><span class="line">     * 3. reader和writer的taskPluginCollector</span><br><span class="line">     */</span><br><span class="line">    private Communication taskCommunication;</span><br><span class="line">​</span><br><span class="line">    public TaskExecutor(Configuration taskConf, int attemptCount) &#123;</span><br><span class="line">        // 获取该taskExecutor的配置</span><br><span class="line">        this.taskConfig = taskConf;</span><br><span class="line">        //...</span><br><span class="line">        /**</span><br><span class="line">         * 由taskId得到该taskExecutor的Communication</span><br><span class="line">         * 要传给readerRunner和writerRunner，同时要传给channel作统计用</span><br><span class="line">         */</span><br><span class="line">        this.taskCommunication = containerCommunicator</span><br><span class="line">                .getCommunication(taskId);</span><br><span class="line">        //实例化存储读数据的管道</span><br><span class="line">        this.channel = ClassUtil.instantiate(channelClazz,</span><br><span class="line">                Channel.class, configuration);</span><br><span class="line">        this.channel.setCommunication(this.taskCommunication);</span><br><span class="line">        /**</span><br><span class="line">         * 获取transformer的参数</span><br><span class="line">         */</span><br><span class="line">        List&lt;TransformerExecution&gt; transformerInfoExecs = TransformerUtil.buildTransformerInfo(taskConfig);</span><br><span class="line">        /**</span><br><span class="line">         * 生成writerThread</span><br><span class="line">         */</span><br><span class="line">        writerRunner = (WriterRunner) generateRunner(PluginType.WRITER);</span><br><span class="line">        this.writerThread = new Thread(writerRunner,</span><br><span class="line">                String.format(&quot;%d-%d-%d-writer&quot;,</span><br><span class="line">                        jobId, taskGroupId, this.taskId));</span><br><span class="line">        //通过设置thread的contextClassLoader，即可实现同步和主程序不通的加载器</span><br><span class="line">        this.writerThread.setContextClassLoader(LoadUtil.getJarLoader(</span><br><span class="line">                PluginType.WRITER, this.taskConfig.getString(</span><br><span class="line">                        CoreConstant.JOB_WRITER_NAME)));</span><br><span class="line">        /**</span><br><span class="line">         * 生成readerThread</span><br><span class="line">         */</span><br><span class="line">        readerRunner = (ReaderRunner) generateRunner(PluginType.READER,transformerInfoExecs);</span><br><span class="line">        this.readerThread = new Thread(readerRunner,</span><br><span class="line">                String.format(&quot;%d-%d-%d-reader&quot;,</span><br><span class="line">                        jobId, taskGroupId, this.taskId));</span><br><span class="line">        /**</span><br><span class="line">         * 通过设置thread的contextClassLoader，即可实现同步和主程序不通的加载器</span><br><span class="line">         */</span><br><span class="line">        this.readerThread.setContextClassLoader(LoadUtil.getJarLoader(</span><br><span class="line">                PluginType.READER, this.taskConfig.getString(</span><br><span class="line">                        CoreConstant.JOB_READER_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    public void doStart() &#123;</span><br><span class="line">        this.writerThread.start();</span><br><span class="line">        // reader没有起来，writer不可能结束</span><br><span class="line">        if (!this.writerThread.isAlive() || this.taskCommunication.getState() == State.FAILED) &#123;</span><br><span class="line">            throw DataXException.asDataXException(</span><br><span class="line">                    FrameworkErrorCode.RUNTIME_ERROR,</span><br><span class="line">                    this.taskCommunication.getThrowable());</span><br><span class="line">        &#125;</span><br><span class="line">        this.readerThread.start();</span><br><span class="line">        // 这里reader可能很快结束</span><br><span class="line">        if (!this.readerThread.isAlive() &amp;&amp; this.taskCommunication.getState() == State.FAILED) &#123;</span><br><span class="line">            // 这里有可能出现Reader线上启动即挂情况 对于这类情况 需要立刻抛出异常</span><br><span class="line">            throw DataXException.asDataXException(</span><br><span class="line">                    FrameworkErrorCode.RUNTIME_ERROR,</span><br><span class="line">                    this.taskCommunication.getThrowable());</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以MySqlReader插件为例，ReaderRunner在执行#init, #prepare, #startRead, #post 时，实现在MysqlReader中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static class Task extends Reader.Task &#123;</span><br><span class="line">    public void startRead(RecordSender recordSender) &#123;</span><br><span class="line">        int fetchSize = this.readerSliceConfig.getInt(Constant.FETCH_SIZE);</span><br><span class="line">        //mysqlReader调commonRdbmsReaderTask读数据</span><br><span class="line">        this.commonRdbmsReaderTask.startRead(this.readerSliceConfig, recordSender,</span><br><span class="line">                super.getTaskPluginCollector(), fetchSize);</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public void startRead(Configuration readerSliceConfig,</span><br><span class="line">                      RecordSender recordSender,</span><br><span class="line">                      TaskPluginCollector taskPluginCollector, int fetchSize) &#123;</span><br><span class="line">    //获取job配置中的querySql</span><br><span class="line">    String querySql = readerSliceConfig.getString(Key.QUERY_SQL);</span><br><span class="line">    //获取job配置中的tabelName   querySql和table 不能并存,否则程序会提示配置错误</span><br><span class="line">    String table = readerSliceConfig.getString(Key.TABLE);</span><br><span class="line">    PerfTrace.getInstance().addTaskDetails(taskId, table + &quot;,&quot; + basicMsg);</span><br><span class="line">    LOG.info(&quot;Begin to read record by Sql: [&#123;&#125;\n] &#123;&#125;.&quot;,</span><br><span class="line">            querySql, basicMsg);</span><br><span class="line">    PerfRecord queryPerfRecord = new PerfRecord(taskGroupId,taskId, PerfRecord.PHASE.SQL_QUERY);</span><br><span class="line">    queryPerfRecord.start();</span><br><span class="line">    //获取数据库连接</span><br><span class="line">    Connection conn = DBUtil.getConnection(this.dataBaseType, jdbcUrl,</span><br><span class="line">            username, password);</span><br><span class="line">​</span><br><span class="line">    // session config .etc related</span><br><span class="line">    DBUtil.dealWithSessionConfig(conn, readerSliceConfig,</span><br><span class="line">            this.dataBaseType, basicMsg);</span><br><span class="line">    int columnNumber = 0;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        rs = DBUtil.query(conn, querySql, fetchSize);   //拿数据</span><br><span class="line">        queryPerfRecord.end();</span><br><span class="line">        //获取表原信息</span><br><span class="line">        ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line">        columnNumber = metaData.getColumnCount();</span><br><span class="line">        //这个统计干净的result_Next时间</span><br><span class="line">        PerfRecord allResultPerfRecord = new PerfRecord(taskGroupId, taskId, PerfRecord.PHASE.RESULT_NEXT_ALL);</span><br><span class="line">        allResultPerfRecord.start();</span><br><span class="line">        long rsNextUsedTime = 0;</span><br><span class="line">        long lastTime = System.nanoTime();</span><br><span class="line">        while (rs.next()) &#123;</span><br><span class="line">            rsNextUsedTime += (System.nanoTime() - lastTime);</span><br><span class="line">            //将读的数据放入recordSender对象的channel中</span><br><span class="line">            this.transportOneRecord(recordSender, rs,</span><br><span class="line">                    metaData, columnNumber, mandatoryEncoding, taskPluginCollector);</span><br><span class="line">            lastTime = System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        allResultPerfRecord.end(rsNextUsedTime);</span><br><span class="line">        //目前大盘是依赖这个打印，而之前这个Finish read record是包含了sql查询和result next的全部时间</span><br><span class="line">        LOG.info(&quot;Finished read record by Sql: [&#123;&#125;\n] &#123;&#125;.&quot;,</span><br><span class="line">                querySql, basicMsg);</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">        throw RdbmsException.asQueryException(this.dataBaseType, e, querySql, table, username);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        DBUtil.closeDBResources(null, conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">protected Record transportOneRecord(RecordSender recordSender, ResultSet rs, </span><br><span class="line">        ResultSetMetaData metaData, int columnNumber, String mandatoryEncoding, </span><br><span class="line">        TaskPluginCollector taskPluginCollector) &#123;</span><br><span class="line">    //每条数据组装一个record</span><br><span class="line">    Record record = buildRecord(recordSender,rs,metaData,columnNumber,mandatoryEncoding,taskPluginCollector); </span><br><span class="line">    //record放入recordSender缓存</span><br><span class="line">    recordSender.sendToWriter(record);</span><br><span class="line">    return record;</span><br><span class="line">&#125;</span><br><span class="line">flush</span><br><span class="line">public void sendToWriter(Record record) &#123;</span><br><span class="line">   //...</span><br><span class="line">   boolean isFull = (this.bufferIndex &gt;= this.bufferSize || this.memoryBytes.get() + record.getMemorySize() &gt; this.byteCapacity);</span><br><span class="line">   if (isFull) &#123;</span><br><span class="line">      flush();  //这里会把buffer放入channel中</span><br><span class="line">   &#125;</span><br><span class="line">   //放入集合列表</span><br><span class="line">   this.buffer.add(record);</span><br><span class="line">   this.bufferIndex++;</span><br><span class="line">   memoryBytes.addAndGet(record.getMemorySize());</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">public void flush() &#123;</span><br><span class="line">    //...</span><br><span class="line">    this.channel.pushAll(this.buffer);</span><br><span class="line">    //...清空buffer</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看完#flush可能会有个疑问,这里要进行判断是否ifFull才把buffer放入channel。那最后一批不满足ifFull条件的数据如何处理？</p>
<p>写入<br>taskReader.startRead(recordSender); &#x2F;&#x2F;读插件开始读<br>recordSender.terminate(); &#x2F;&#x2F;把缓存中剩余数据写如recordSender的channel中，并且写入TerminateRecord打上结束标记<br>至此读任务就结束了</p>
<p>接下来看写任务</p>
<p>以MySqlWriter插件为例，WriterRunner分别执行#init, #prepare, #start, #post， 实现在MySqlWriter中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static class Task extends Writer.Task &#123;</span><br><span class="line">    //TODO 改用连接池，确保每次获取的连接都是可用的（注意：连接可能需要每次都初始化其 session）</span><br><span class="line">    public void startWrite(RecordReceiver recordReceiver) &#123;</span><br><span class="line">        this.commonRdbmsWriterTask.startWrite(recordReceiver, this.writerSliceConfig,</span><br><span class="line">                super.getTaskPluginCollector());</span><br><span class="line">    &#125;</span><br><span class="line">     //...</span><br><span class="line">&#125;</span><br><span class="line">public void startWrite(RecordReceiver recordReceiver,</span><br><span class="line">                       Configuration writerSliceConfig,</span><br><span class="line">                       TaskPluginCollector taskPluginCollector) &#123;</span><br><span class="line">    Connection connection = DBUtil.getConnection(this.dataBaseType,</span><br><span class="line">            this.jdbcUrl, username, password);</span><br><span class="line">    DBUtil.dealWithSessionConfig(connection, writerSliceConfig,</span><br><span class="line">            this.dataBaseType, BASIC_MESSAGE);</span><br><span class="line">    startWriteWithConnection(recordReceiver, taskPluginCollector, connection);  //开始写</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;…清空缓存,关闭资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void startWriteWithConnection(RecordReceiver recordReceiver, TaskPluginCollector taskPluginCollector, Connection connection) &#123;</span><br><span class="line">    this.taskPluginCollector = taskPluginCollector;</span><br><span class="line">    // 用于写入数据的时候的类型根据目的表字段类型转换</span><br><span class="line">    this.resultSetMetaData = DBUtil.getColumnMetaData(connection,</span><br><span class="line">            this.table, StringUtils.join(this.columns, &quot;,&quot;));</span><br><span class="line">    // 写数据库的SQL语句</span><br><span class="line">    calcWriteRecordSql();</span><br><span class="line">    List&lt;Record&gt; writeBuffer = new ArrayList&lt;Record&gt;(this.batchSize);</span><br><span class="line">    int bufferBytes = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        Record record;</span><br><span class="line">        while ((record = recordReceiver.getFromReader()) != null) &#123;</span><br><span class="line">            //...读列与写列数量不一致，会抛异常,这里省略</span><br><span class="line">            //写缓存添加数据</span><br><span class="line">            writeBuffer.add(record);</span><br><span class="line">            bufferBytes += record.getMemorySize();</span><br><span class="line">            if (writeBuffer.size() &gt;= batchSize || bufferBytes &gt;= batchByteSize) &#123;</span><br><span class="line">                doBatchInsert(connection, writeBuffer); //开始批量写</span><br><span class="line">                writeBuffer.clear();</span><br><span class="line">                bufferBytes = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!writeBuffer.isEmpty()) &#123;</span><br><span class="line">            doBatchInsert(connection, writeBuffer);</span><br><span class="line">            writeBuffer.clear();</span><br><span class="line">            bufferBytes = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //...清空缓存,关闭资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写任务是批量操作,值得注意的是，当批量写操作出现错误时，程序会争取再执行一次写操作,对每条数据分别进行写操作</p>
<p>在#doOneInsert中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">protected void doBatchInsert(Connection connection, List&lt;Record&gt; buffer)</span><br><span class="line">        throws SQLException &#123;</span><br><span class="line">    PreparedStatement preparedStatement = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        connection.setAutoCommit(false);</span><br><span class="line">        preparedStatement = connection</span><br><span class="line">                .prepareStatement(this.writeRecordSql);</span><br><span class="line">        for (Record record : buffer) &#123;</span><br><span class="line">            preparedStatement = fillPreparedStatement(</span><br><span class="line">                    preparedStatement, record);</span><br><span class="line">            preparedStatement.addBatch();   //批量提交</span><br><span class="line">        &#125;</span><br><span class="line">        preparedStatement.executeBatch();   //批量执行</span><br><span class="line">        connection.commit();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        LOG.warn(&quot;回滚此次写入, 采用每次写入一行方式提交. 因为:&quot; + e.getMessage());</span><br><span class="line">        connection.rollback();</span><br><span class="line">        doOneInsert(connection, buffer);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw DataXException.asDataXException(</span><br><span class="line">                DBUtilErrorCode.WRITE_DATA_ERROR, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        DBUtil.closeDBResources(preparedStatement, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">protected void doOneInsert(Connection connection, List&lt;Record&gt; buffer) &#123;</span><br><span class="line">    PreparedStatement preparedStatement = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        connection.setAutoCommit(true);</span><br><span class="line">        preparedStatement = connection</span><br><span class="line">                .prepareStatement(this.writeRecordSql);</span><br><span class="line">        for (Record record : buffer) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                preparedStatement = fillPreparedStatement(</span><br><span class="line">                        preparedStatement, record);</span><br><span class="line">                preparedStatement.execute();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                LOG.debug(e.toString());</span><br><span class="line">                this.taskPluginCollector.collectDirtyRecord(record, e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 最后不要忘了关闭 preparedStatement</span><br><span class="line">                preparedStatement.clearParameters();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        //...抛异常</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //...关闭资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此写操作完毕</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ychang577/article/details/108226450"></a>总结</h2><p>整个应用，采用framework + read plugin + write plugin方式。对于核心配置文件core.json ，任务配置文件 job.json, 插件配置文件plugin.json 程序已经处理。并且结合Communication收集处理数据指标。我们只需要实现<br>Reader , Reader.Job , Reader.Task<br>Writer , Writer.Job , Writer.Task<br>根据项目的需求进行处理即可</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ychang577/article/details/108226450">https://blog.csdn.net/ychang577/article/details/108226450</a>，如有侵权，请联系删除。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hang Yu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/06/10/dataX/">http://example.com/2022/06/10/dataX/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Yu Hang-Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></div><div class="post_share"><div class="social-share" data-image="/./img/lKKp6BFFAriR7u6J.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/10/hadoop%E5%92%8Cspark/"><img class="prev-cover" src="https://picsum.photos/id/496/4288/2848" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spark和Hadoop的异同点分析</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BD%91%E5%9D%80/"><img class="next-cover" src="/./img/9mxCGCLU9bxyeQtM.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构网址</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/10/hadoop%E5%92%8Cspark/" title="Spark和Hadoop的异同点分析"><img class="cover" src="https://picsum.photos/id/496/4288/2848" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-10</div><div class="title">Spark和Hadoop的异同点分析</div></div></a></div><div><a href="/2020/06/10/ArrayList%E5%BA%95%E5%B1%82/" title="浅谈ArrayList"><img class="cover" src="https://picsum.photos/id/367/4928/3264" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-10</div><div class="title">浅谈ArrayList</div></div></a></div><div><a href="/2020/10/10/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/" title="CMS垃圾回收器"><img class="cover" src="https://picsum.photos/id/1010/5184/3456" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-10</div><div class="title">CMS垃圾回收器</div></div></a></div><div><a href="/2020/05/10/CAS/" title="CAS简单了解"><img class="cover" src="/./img/Gz6mGZmIsFQawF3T.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-10</div><div class="title">CAS简单了解</div></div></a></div><div><a href="/2021/09/10/HashMap/" title="HashMap"><img class="cover" src="/./img/Gz6mGZmIsFQawF3T.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-10</div><div class="title">HashMap</div></div></a></div><div><a href="/2020/12/10/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="G1垃圾回收器"><img class="cover" src="/./img/i5lBK9xbLj3UHwE3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-10</div><div class="title">G1垃圾回收器</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/touxiang.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Hang Yu</div><div class="author-info__description">欢迎来到我的王国</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yh94"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yh94" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/18720982524@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">人无再少年</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">源码剖析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/10/hadoop%E5%92%8Cspark/" title="Spark和Hadoop的异同点分析"><img src="https://picsum.photos/id/496/4288/2848" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark和Hadoop的异同点分析"/></a><div class="content"><a class="title" href="/2022/06/10/hadoop%E5%92%8Cspark/" title="Spark和Hadoop的异同点分析">Spark和Hadoop的异同点分析</a><time datetime="2022-06-09T16:00:00.000Z" title="发表于 2022-06-10 00:00:00">2022-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/10/dataX/" title="dataX剖析"><img src="/./img/lKKp6BFFAriR7u6J.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="dataX剖析"/></a><div class="content"><a class="title" href="/2022/06/10/dataX/" title="dataX剖析">dataX剖析</a><time datetime="2022-06-09T16:00:00.000Z" title="发表于 2022-06-10 00:00:00">2022-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BD%91%E5%9D%80/" title="数据结构网址"><img src="/./img/9mxCGCLU9bxyeQtM.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构网址"/></a><div class="content"><a class="title" href="/2022/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BD%91%E5%9D%80/" title="数据结构网址">数据结构网址</a><time datetime="2022-04-18T07:24:58.988Z" title="发表于 2022-04-18 15:24:58">2022-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/16/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6(%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8)/" title="idea代码神器"><img src="/./img/9mxCGCLU9bxyeQtM.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="idea代码神器"/></a><div class="content"><a class="title" href="/2022/03/16/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6(%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8)/" title="idea代码神器">idea代码神器</a><time datetime="2022-03-16T07:30:10.000Z" title="发表于 2022-03-16 15:30:10">2022-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/10/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" title="nginx"><img src="https://picsum.photos/id/366/4000/3000" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nginx"/></a><div class="content"><a class="title" href="/2022/02/10/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" title="nginx">nginx</a><time datetime="2022-02-09T16:00:00.000Z" title="发表于 2022-02-10 00:00:00">2022-02-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By Hang Yu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Can I make a friend with you ？</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>