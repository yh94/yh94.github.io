---
title: synchorized浅理解
date: 2021-03-05
tags: 
 - java
 - 锁 
categories:
 - java
 - 锁
---


## synchorized浅理解 ##
> 首先这是一种互斥锁，也是一种悲观锁，一次只能允许一个线程进入被锁住的代码块（吐槽：这些锁啊锁的是真的多，累了）
> 对象：代码块 ｜ 对象
- 实例方法 ：锁的是对象实例
- 静态方法 ：锁的是当前类的class实例
- 代码块 ： 锁得是传入synchorized的对象实例

> 我们都知道一个对象分为三块：对象头，对象实际数据，对齐填充（补满8字节）。
- 对象头：里面有个markword。这里会记住锁的信息，又因为每个对象都会有一个与之对应的monitor对象，这里面存着当前持有锁的线程
以及等待锁的线程队列。monitor对象会存储当前id，设置markword的monitor的对象地址，并把阻塞的线程存储到minitor的等待线程队列中

加锁的底层是依赖底层的操作系统的mutex，相关指令实现，有用户态和内核态之间的切换，性能损耗比较明显。

\
重磅消息：之前是重量级锁，而1.6之后引入了偏向锁和轻量级锁，不依赖系统了，性能得到提升。而markword一共记录了四种状态
 - 偏向锁：jvm认为只有某个线程才会执行同步代码（没有竞争的环境）。所以markword会记录线程ID，对比线程id是否相等，相等就能直接拿到锁，执行同步代码。
如果不相等就用CAS尝试修改当前线程ID，如果成功，则拿到锁，执行同步代码，如果CAS失败了，此时会撤销偏向锁，升级为轻量级锁。
 - 轻量级锁：当前线程会在栈帧下创建Lock Record， 然后把mark word信息拷贝进去，且有个owner指针指向加锁的对象。
线程此时执行到同步代码块时，用CAS试图将Mark word指向到栈帧的lock Record，如果CAS修改成功，则获得轻量级锁。
如果失败则（自旋），升级为重量级锁。
 - 重量级锁：依赖操作系统的monitor对象，耗性能。
 - 无锁
## 总结一下：
 > 偏向锁,只会用markword线程id进行比对，轻量级锁拷贝到Lock Record，+ CAS自旋获取，随后就是重量级锁了。
 
只有一个线程：偏向锁。

多个线程交替进入临界区：轻量级锁。

多线程同时进入临界区：重量级锁

 