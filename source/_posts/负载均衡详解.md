---
title: 负载均衡详解
date: 2019-09-16 
tags: 
 - java
 - 架构 
categories:
 - 系统 
---
 ## 负载均衡介绍
>负载均衡，英文名称为Load Balance，指由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，
都可以单独对外提供服务而无须其他服务器的辅助。
通过某种负载分担技术，将外部发送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。
负载均衡能够平均分配客户请求到服务器阵列，借此提供快速获取重要数据，解决大量并发访问服务问题，
这种集群技术可以用最少的投资获得接近于大型主机的性能。
## 负载均衡方式
> 负载均衡分为软件负载均衡和硬件负载均衡
## 软件负载均衡
> 常见的负载均衡软件有Nginx、LVS、HAProxy。
## 硬件负载均衡
> 常见的负载均衡硬件有Array、F5。
## 负载均衡算法
> 定义一个服务器列表，每个负载均衡的算法会从中挑出一个服务器作为算法的结果。
```
public class ServerIps {
﻿
    private static final List<String> LIST = Arrays.asList(
﻿
            "192.168.0.1",
﻿
            "192.168.0.2",
﻿
            "192.168.0.3",
﻿
            "192.168.0.4",
﻿
            "192.168.0.5",
﻿
            "192.168.0.6",
﻿
            "192.168.0.7",
﻿
            "192.168.0.8",
﻿
            "192.168.0.9",
﻿
            "192.168.0.10"
﻿
    );
﻿
}
```
- 随机算法-RandomLoadBalance
```
public class Random {
﻿
    public static String getServer() {
﻿
        // 生成一个随机数作为list的下标值
﻿
        java.util.Random random = new java.util.Random();
﻿
        int randomPos = random.nextInt(ServerIps.LIST.size());
﻿
        return ServerIps.LIST.get(randomPos);
﻿
    }
﻿
    public static void main(String[] args) {
﻿
        // 连续调用10次
﻿
        for (int i=0; i<10; i++) {
﻿
            System.out.println(getServer());
﻿
        }
﻿
    }
﻿
}
```
```
运行结果：
﻿
192.168.0.3
﻿
192.168.0.4
﻿
192.168.0.7
﻿
192.168.0.1
﻿
192.168.0.2
﻿
192.168.0.7
﻿
192.168.0.3
﻿
192.168.0.9
﻿
192.168.0.1
﻿
192.168.0.1
```
> 当调用次数比较少时，
Random 产生的随机数可能会比较集中，
此时多数请求会落到同一台服务器上，只有在经过多次请求后，
才能使调用请求进行“均匀”分配。调用量少这一点并没有什么关系
> ，负载均衡机制不正是为了应对请求量多的情况吗，所以随机算法也是用得比较多的一种算法。
> 
但是，上面的随机算法适用于每天机器的性能差不多的时候，实际上，生产中可能某些机器的性能更高一点，它可以处理更多的请求，所以，我们可以对每台服务器设置一个权重。
  在ServerIps类中增加服务器权重对应关系MAP，权重之和为50：
```angular2html

public static final Map<String, Integer> WEIGHT_LIST = new HashMap<String, Integer>();
﻿
    static {
﻿
        // 权重之和为50
﻿
        WEIGHT_LIST.put("192.168.0.1", 1);
﻿
        WEIGHT_LIST.put("192.168.0.2", 8);
﻿
        WEIGHT_LIST.put("192.168.0.3", 3);
﻿
        WEIGHT_LIST.put("192.168.0.4", 6);
﻿
        WEIGHT_LIST.put("192.168.0.5", 5);
﻿
        WEIGHT_LIST.put("192.168.0.6", 5);
﻿
        WEIGHT_LIST.put("192.168.0.7", 4);
﻿
        WEIGHT_LIST.put("192.168.0.8", 7);
﻿
        WEIGHT_LIST.put("192.168.0.9", 2);
﻿
        WEIGHT_LIST.put("192.168.0.10", 9);
﻿
    }
```
那么现在的随机算法应该要改成权重随机算法，当调用量比较多的时候，服务器使用的分布应该近似对应权重的分布。
- 权重随机算法

简单的实现思路是，把每个服务器按它所对应的服务器进行复制，具体看代码更加容易理解
```angular2html

public class WeightRandom {
﻿
    public static String getServer() {
﻿
        // 生成一个随机数作为list的下标值
﻿
        List<String> ips = new ArrayList<String>();
﻿
        for (String ip : ServerIps.WEIGHT_LIST.keySet()) {
﻿
            Integer weight = ServerIps.WEIGHT_LIST.get(ip);
﻿
            // 按权重进行复制
﻿
            for (int i=0; i<weight; i++) {
﻿
                ips.add(ip);
﻿
            }
﻿
        }
﻿
        java.util.Random random = new java.util.Random();
﻿
        int randomPos = random.nextInt(ips.size());
﻿
        return ips.get(randomPos);
﻿
    }
﻿
    public static void main(String[] args) {
﻿
        // 连续调用10次
﻿
        for (int i=0; i<10; i++) {
﻿
            System.out.println(getServer());
﻿
        }
﻿
    }
﻿
}
```
```angular2html
运行结果：
﻿
192.168.0.8
﻿
192.168.0.2
﻿
192.168.0.7
﻿
192.168.0.10
﻿
192.168.0.8
﻿
192.168.0.8
﻿
192.168.0.4
﻿
192.168.0.7
﻿
192.168.0.6
﻿
192.168.0.8
```
- 轮询算法-RoundRobinLoadBalance
```angular2html
public class RoundRobin {
﻿
    // 当前循环的位置
﻿
    private static Integer pos = 0;
﻿
    public static String getServer() {
﻿
        String ip = null;
﻿
        // pos同步
﻿
        synchronized (pos) {
﻿
            if (pos >= ServerIps.LIST.size()) {
﻿
                pos = 0;
﻿
            }
﻿
            ip = ServerIps.LIST.get(pos);
﻿
            pos++;
﻿
        }
﻿
        return ip;
﻿
    }
﻿
    public static void main(String[] args) {
﻿
        // 连续调用10次
﻿
        for (int i = 0; i < 11; i++) {
﻿
            System.out.println(getServer());
﻿
        }
﻿
    }
﻿
}
```
```angular2html

﻿
运行结果：
﻿
192.168.0.1
﻿
192.168.0.2
﻿
192.168.0.3
﻿
192.168.0.4
﻿
192.168.0.5
﻿
192.168.0.6
﻿
192.168.0.7
﻿
192.168.0.8
﻿
192.168.0.9
﻿
192.168.0.10
﻿
192.168.0.1
```
> 这种算法很简单，也很公平，每台服务轮流来进行服务，但是有的机器性能好，所以能者多劳，和随机算法一下，加上权重这个维度之后，其中一种实现方法就是复制法，这里就不演示了，这种复制算法的缺点和随机算法的是一样的，比较消耗内存，那么自然就有其他实现方法。我下面来介绍一种算法：
这种算法需要加入一个概念：调用编号，比如第1次调用为1， 第2次调用为2， 第100次调用为100，调用编号是递增的，所以我们可以根据这个调用编号推算出服务器。
假设我们有三台服务器 servers = [A, B, C]，对应的权重为 weights = [ 2, 5, 1], 总权重为8，我们可以理解为有8台“服务器”，这是8台“不具有并发功能”，其中有2台为A，5台为B，1台为C，一次调用过来的时候，需要按顺序访问，比如有10次调用，那么服务器调用顺序为AABBBBBCAA，
调用编号会越来越大，而服务器是固定的，所以需要把调用编号“缩小”，这里对调用编号进行取余，除数为总权重和，比如：
- 1号调用，1%8=1；
- 2号调用，2%8=2；
- 3号调用，3%8=3；
- 8号调用，8%8=0；
- 9号调用，9%8=1；
- 100号调用，100%8=4；
我们发现调用编号可以被缩小为0-7之间的8个数字，问题是怎么根据这个8个数字找到对应的服务器呢？和我们随机算法类似，这里也可以把权重想象为一个坐标轴“0-----2-----7-----8”
- 1号调用，1%8=1，offset = 1, offset <= 2 is true，取A；
- 2号调用，2%8=2；offset = 2，offset <= 2 is true, 取A;
- 3号调用，3%8=3；offset = 3, offset <= 2 is false, offset = offset - 2, offset = 1, offset <= 5，取B
- 8号调用，8%8=0；offset = 0, 特殊情况，offset = 8，offset <= 2 is false, offset = offset - 2, offset = 6, offset  <= 5 is false, offset = offset - 5, offset = 1, offset <= 1 is true, 取C;
- 9号调用，9%8=1；// ...
- 100号调用，100%8=4； //...
实现：
模拟调用编号获取工具：
```

public class Sequence {
﻿
    public static Integer num = 0;
﻿
    public static Integer getAndIncrement() {
﻿
        return ++num;
﻿
    }
﻿
}
```
```angular2html
public class WeightRoundRobin {
﻿
    private static Integer pos = 0;
﻿
    public static String getServer() {
﻿
        int totalWeight = 0;
﻿
        boolean sameWeight = true; // 如果所有权重都相等，那么随机一个ip就好了
﻿
        Object[] weights = ServerIps.WEIGHT_LIST.values().toArray();
﻿
        for (int i = 0; i < weights.length; i++) {
﻿
            Integer weight = (Integer) weights[i];
﻿
            totalWeight += weight;
﻿
            if (sameWeight && i > 0 && !weight.equals(weights[i - 1])) {
﻿
                sameWeight = false;
﻿
            }
﻿
        }
﻿
        Integer sequenceNum = Sequence.getAndIncrement();
﻿
        Integer offset = sequenceNum % totalWeight;
﻿
        offset = offset == 0 ?  totalWeight : offset;
﻿
        if (!sameWeight) {
﻿
            for (String ip : ServerIps.WEIGHT_LIST.keySet()) {
﻿
                Integer weight = ServerIps.WEIGHT_LIST.get(ip);
﻿
                if (offset <= weight) {
﻿
                    return ip;
﻿
                }
﻿
                offset = offset - weight;
﻿
            }
﻿
        }
﻿
        String ip = null;
﻿
        synchronized (pos) {
﻿
            if (pos >= ServerIps.LIST.size()) {
﻿
                pos = 0;
﻿
            }
﻿
            ip = ServerIps.LIST.get(pos);
﻿
            pos++;
﻿
        }
﻿
        return ip;
﻿
    }
﻿
    public static void main(String[] args) {
﻿
        // 连续调用11次
﻿
        for (int i = 0; i < 11; i++) {
﻿
            System.out.println(getServer());
﻿
        }
﻿
    }
﻿
}
```
```angular2html
运行结果：
﻿
192.168.0.1
﻿
192.168.0.2
﻿
192.168.0.2
﻿
192.168.0.2
﻿
192.168.0.2
﻿
192.168.0.2
﻿
192.168.0.2
﻿
192.168.0.2
﻿
192.168.0.2
﻿
192.168.0.3
﻿
192.168.0.3
```
> 但是这种算法有一个缺点：一台服务器的权重特别大的时候，他需要连续的的处理请求，但是实际上我们想达到的效果是，对于100次请求，只要有100*8/50=16次就够了，这16次不一定要连续的访问，比如假设我们有三台服务器 servers = [A, B, C]，对应的权重为 weights = [5, 1, 1] , 总权重为7，那么上述这个算法的结果是：AAAAABC，那么如果能够是这么一个结果呢：AABACAA，把B和C平均插入到5个A中间，这样是比较均衡的了

我们这里可以改成平滑加权轮询。
平滑加权轮询
思路：每个服务器对应两个权重，分别为 weight 和 currentWeight。其中 weight 是固定的，currentWeight 会动态调整，初始值为0。当有新的请求进来时，遍历服务器列表，让它的 currentWeight 加上自身权重。遍历完成后，找到最大的 currentWeight，并将其减去权重总和，然后返回相应的服务器即可。
