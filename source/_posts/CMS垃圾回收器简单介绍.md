---
title: CMS垃圾回收器
date: 2020-10-10
tags:
 - java
 - 垃圾回收
 - jvm
categories:
 - java
---

## CMS垃圾回收器
>CMS叫做并发标记清除。
用CMS对比 Seria和Parallel 和 ParNew ：最大的的不同点就是并发：在GC线程工作的时候，用户线程不会完全停止，用户线程在部分场景下与GC线程一起并发执行。
CMS设计目标：避免老年代长时间卡顿。

CMS分为5个步骤：初始标记，并发标记，并发预清理，重新标记，以及并发清除。
不难看出cms，使用了【标记清除】垃圾回收算法
- 初始标记 ：会标记GCroots直接关联的对象和年轻代指向老年代的对象，过程比较快，初始标记这个过程是会发生stw。

为什么要扫描年轻代，因为回收老年代，年轻代可能会指向老年代。
- 并发标记：这个过程是不会停止用户线程的（stw），这一阶段主要进行可达性分析，因为要追溯所以比较耗时间。
- 并发预清理：希望能减少下一个阶段【重新标记】的时间，因为上一个阶段【并发标记】线程是没有被挂起的，导致对象之间和对象本身的root发生了改变，有几种情况
    - 新生代变成了老年代
    - 有些对象直接分到了老年代
    - 老年代和新生代之间对象引用发生了变化
      针对老年代的对象可以借助card table存储，将老年代发生的卡页标记为dirty，所以并发预处理会再扫描一遍标记为dirty的卡页
      对于新生代的的对象我们还得遍历新生代来看看在并发标记有没有对象引用到老年代，有可能在这里会触发minor gc
- 重新标记：会stw，停顿时间取决于上面的并发预处理
  可以发现这是一个追赶的过程，一边标记存货对象，一边用户线程在执行产生垃圾
- 并发清除：不会stw，一边用户在执行，一边GC线程在回收不可达的对象

整个过程还是有可能在不断产生垃圾，只能留到下次处理。产生的垃圾叫做浮动垃圾。完了之后会重置cms算法相关的内部数据，为下一次gc做准备

## 总结
其实就是把垃圾回收过程细分了，然后在某个阶段不停止用户线程，一边回收垃圾，一边处理请求，来减少每次垃圾回收时stw的时间。
当然中间也有很多优化，dirty card 标记，可能途中触发minor gc 等等，这些都提供了相应的cms参数。
两个缺点：
1、空间需要预留。
2、内存碎片问题。